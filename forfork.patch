diff --git a/allocsld/chain.s b/allocsld/chain.s
deleted file mode 100644
index 07b4a26..0000000
--- a/allocsld/chain.s
+++ /dev/null
@@ -1,4840 +0,0 @@
-	.file	"chain.c"
-	.text
-.Ltext0:
-	.type	dynamic_lookup, @function
-dynamic_lookup:
-.LFB17:
-	.file 1 "/usr/local/src/liballocs/contrib/libsystrap/contrib/librunt/include/relf.h"
-	.loc 1 462 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	movq	%rdi, -24(%rbp)
-	movl	%esi, -28(%rbp)
-.LBB2:
-	.loc 1 463 17
-	movq	-24(%rbp), %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 463 2
-	jmp	.L2
-.L5:
-	.loc 1 465 10
-	movq	-8(%rbp), %rax
-	movq	(%rax), %rdx
-	.loc 1 465 18
-	movl	-28(%rbp), %eax
-	cltq
-	.loc 1 465 6
-	cmpq	%rax, %rdx
-	jne	.L3
-	.loc 1 467 11
-	movq	-8(%rbp), %rax
-	jmp	.L4
-.L3:
-	.loc 1 463 49 discriminator 2
-	addq	$16, -8(%rbp)
-.L2:
-	.loc 1 463 29 discriminator 1
-	movq	-8(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 463 2 discriminator 1
-	testq	%rax, %rax
-	jne	.L5
-.LBE2:
-	.loc 1 470 8
-	movl	$0, %eax
-.L4:
-	.loc 1 471 1
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE17:
-	.size	dynamic_lookup, .-dynamic_lookup
-	.section	.rodata
-	.align 8
-.LC0:
-	.string	"/usr/local/src/liballocs/contrib/libsystrap/contrib/librunt/include/relf.h"
-.LC1:
-	.string	"expected dynamic tag"
-	.text
-	.type	dynamic_xlookup, @function
-dynamic_xlookup:
-.LFB18:
-	.loc 1 475 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	movq	%rdi, -24(%rbp)
-	movl	%esi, -28(%rbp)
-	.loc 1 476 20
-	movl	-28(%rbp), %edx
-	movq	-24(%rbp), %rax
-	movl	%edx, %esi
-	movq	%rax, %rdi
-	call	dynamic_lookup
-	movq	%rax, -8(%rbp)
-	.loc 1 477 5
-	cmpq	$0, -8(%rbp)
-	jne	.L7
-	.loc 1 477 14 discriminator 1
-	leaq	__func__.4434(%rip), %rcx
-	movl	$477, %edx
-	leaq	.LC0(%rip), %rsi
-	leaq	.LC1(%rip), %rdi
-	call	__assert_fail@PLT
-.L7:
-	.loc 1 478 9
-	movq	-8(%rbp), %rax
-	.loc 1 479 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE18:
-	.size	dynamic_xlookup, .-dynamic_xlookup
-	.type	elf64_hash, @function
-elf64_hash:
-.LFB20:
-	.loc 1 490 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	movq	%rdi, -24(%rbp)
-	.loc 1 491 11
-	movq	$0, -8(%rbp)
-	.loc 1 492 8
-	jmp	.L10
-.L12:
-	.loc 1 494 10
-	movq	-8(%rbp), %rax
-	salq	$4, %rax
-	movq	%rax, %rcx
-	.loc 1 494 23
-	movq	-24(%rbp), %rax
-	leaq	1(%rax), %rdx
-	movq	%rdx, -24(%rbp)
-	.loc 1 494 18
-	movzbl	(%rax), %eax
-	movzbl	%al, %eax
-	.loc 1 494 5
-	addq	%rcx, %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 495 15
-	movq	-8(%rbp), %rax
-	andl	$4026531840, %eax
-	movq	%rax, -16(%rbp)
-	.loc 1 495 6
-	cmpq	$0, -16(%rbp)
-	je	.L11
-	.loc 1 495 43 discriminator 1
-	movq	-16(%rbp), %rax
-	shrq	$24, %rax
-	.loc 1 495 38 discriminator 1
-	xorq	%rax, -8(%rbp)
-.L11:
-	.loc 1 496 5
-	andq	$268435455, -8(%rbp)
-.L10:
-	.loc 1 492 9
-	movq	-24(%rbp), %rax
-	movzbl	(%rax), %eax
-	.loc 1 492 8
-	testb	%al, %al
-	jne	.L12
-	.loc 1 498 9
-	movq	-8(%rbp), %rax
-	.loc 1 499 1
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE20:
-	.size	elf64_hash, .-elf64_hash
-	.type	get_dynsym_from_dyn, @function
-get_dynsym_from_dyn:
-.LFB31:
-	.loc 1 691 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	movq	%rdi, -24(%rbp)
-	movq	%rsi, -32(%rbp)
-	.loc 1 692 16
-	movq	-24(%rbp), %rax
-	movl	$6, %esi
-	movq	%rax, %rdi
-	call	dynamic_xlookup
-	.loc 1 692 12
-	movq	8(%rax), %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 693 224
-	cmpq	$0, -8(%rbp)
-	je	.L15
-	.loc 1 693 13 discriminator 1
-	movq	-8(%rbp), %rax
-	cmpq	-32(%rbp), %rax
-	jb	.L16
-	.loc 1 693 121 discriminator 4
-	movl	$4294967295, %edx
-	movq	-32(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 693 75 discriminator 4
-	cmpq	%rax, -8(%rbp)
-	jb	.L17
-.L16:
-	.loc 1 693 202 discriminator 5
-	movq	-32(%rbp), %rdx
-	movq	-8(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 693 224 discriminator 5
-	jmp	.L20
-.L17:
-	.loc 1 693 13 discriminator 6
-	movq	-8(%rbp), %rax
-	.loc 1 693 224 discriminator 6
-	jmp	.L20
-.L15:
-	.loc 1 693 224 is_stmt 0 discriminator 2
-	movl	$0, %eax
-.L20:
-	.loc 1 694 1 is_stmt 1 discriminator 11
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE31:
-	.size	get_dynsym_from_dyn, .-get_dynsym_from_dyn
-	.type	get_gnu_hash_from_dyn, @function
-get_gnu_hash_from_dyn:
-.LFB33:
-	.loc 1 702 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	movq	%rdi, -24(%rbp)
-	movq	%rsi, -32(%rbp)
-	.loc 1 703 27
-	movq	-24(%rbp), %rax
-	movl	$1879047925, %esi
-	movq	%rax, %rdi
-	call	dynamic_lookup
-	movq	%rax, -8(%rbp)
-	.loc 1 704 344
-	cmpq	$0, -8(%rbp)
-	je	.L22
-	.loc 1 704 89 discriminator 1
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 704 39 discriminator 1
-	cmpq	%rax, -32(%rbp)
-	ja	.L23
-	.loc 1 704 160 discriminator 3
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 704 195 discriminator 3
-	movl	$4294967295, %ecx
-	movq	-32(%rbp), %rdx
-	addq	%rcx, %rdx
-	.loc 1 704 126 discriminator 3
-	cmpq	%rdx, %rax
-	jnb	.L23
-	.loc 1 704 263 discriminator 5
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 704 39 discriminator 5
-	jmp	.L25
-.L23:
-	.loc 1 704 331 discriminator 6
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 1 704 299 discriminator 6
-	movq	-32(%rbp), %rax
-	addq	%rdx, %rax
-	jmp	.L25
-.L22:
-	.loc 1 704 344 discriminator 2
-	movl	$0, %eax
-.L25:
-	.loc 1 704 13 discriminator 10
-	movq	%rax, -16(%rbp)
-	.loc 1 705 9 discriminator 10
-	movq	-16(%rbp), %rax
-	.loc 1 706 1 discriminator 10
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE33:
-	.size	get_gnu_hash_from_dyn, .-get_gnu_hash_from_dyn
-	.type	get_sysv_hash_from_dyn, @function
-get_sysv_hash_from_dyn:
-.LFB35:
-	.loc 1 714 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	movq	%rdi, -24(%rbp)
-	movq	%rsi, -32(%rbp)
-	.loc 1 715 23
-	movq	-24(%rbp), %rax
-	movl	$4, %esi
-	movq	%rax, %rdi
-	call	dynamic_lookup
-	movq	%rax, -8(%rbp)
-	.loc 1 716 320
-	cmpq	$0, -8(%rbp)
-	je	.L28
-	.loc 1 716 77 discriminator 1
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 716 31 discriminator 1
-	cmpq	%rax, -32(%rbp)
-	ja	.L29
-	.loc 1 716 144 discriminator 3
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 716 179 discriminator 3
-	movl	$4294967295, %ecx
-	movq	-32(%rbp), %rdx
-	addq	%rcx, %rdx
-	.loc 1 716 114 discriminator 3
-	cmpq	%rdx, %rax
-	jnb	.L29
-	.loc 1 716 243 discriminator 5
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 716 31 discriminator 5
-	jmp	.L31
-.L29:
-	.loc 1 716 307 discriminator 6
-	movq	-8(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 1 716 279 discriminator 6
-	movq	-32(%rbp), %rax
-	addq	%rdx, %rax
-	jmp	.L31
-.L28:
-	.loc 1 716 320 discriminator 2
-	movl	$0, %eax
-.L31:
-	.loc 1 716 13 discriminator 10
-	movq	%rax, -16(%rbp)
-	.loc 1 717 9 discriminator 10
-	movq	-16(%rbp), %rax
-	.loc 1 718 1 discriminator 10
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE35:
-	.size	get_sysv_hash_from_dyn, .-get_sysv_hash_from_dyn
-	.type	get_dynstr_from_dyn, @function
-get_dynstr_from_dyn:
-.LFB37:
-	.loc 1 726 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	movq	%rdi, -24(%rbp)
-	movq	%rsi, -32(%rbp)
-	.loc 1 727 61
-	movq	-24(%rbp), %rax
-	movl	$5, %esi
-	movq	%rax, %rdi
-	call	dynamic_xlookup
-	.loc 1 727 50
-	movq	8(%rax), %rax
-	.loc 1 727 26
-	cmpq	%rax, -32(%rbp)
-	ja	.L34
-	.loc 1 727 103 discriminator 1
-	movq	-24(%rbp), %rax
-	movl	$5, %esi
-	movq	%rax, %rdi
-	call	dynamic_xlookup
-	.loc 1 727 50 discriminator 1
-	movq	8(%rax), %rax
-	.loc 1 727 85 discriminator 1
-	movl	$4294967295, %ecx
-	movq	-32(%rbp), %rdx
-	addq	%rcx, %rdx
-	.loc 1 727 87 discriminator 1
-	cmpq	%rdx, %rax
-	jnb	.L34
-	.loc 1 727 135 discriminator 3
-	movq	-24(%rbp), %rax
-	movl	$5, %esi
-	movq	%rax, %rdi
-	call	dynamic_xlookup
-	.loc 1 727 50 discriminator 3
-	movq	8(%rax), %rax
-	.loc 1 727 26 discriminator 3
-	jmp	.L35
-.L34:
-	.loc 1 727 100 discriminator 4
-	movq	-24(%rbp), %rax
-	movl	$5, %esi
-	movq	%rax, %rdi
-	call	dynamic_xlookup
-	.loc 1 727 50 discriminator 4
-	movq	8(%rax), %rdx
-	.loc 1 727 86 discriminator 4
-	movq	-32(%rbp), %rax
-	addq	%rdx, %rax
-.L35:
-	.loc 1 727 17 discriminator 6
-	movq	%rax, -8(%rbp)
-	.loc 1 728 9 discriminator 6
-	movq	-8(%rbp), %rax
-	.loc 1 729 1 discriminator 6
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE37:
-	.size	get_dynstr_from_dyn, .-get_dynstr_from_dyn
-	.section	.rodata
-	.align 8
-.LC2:
-	.string	"(unsigned char *) dynstr > (unsigned char *) dynsym"
-	.text
-	.type	dynamic_symbol_count_fast, @function
-dynamic_symbol_count_fast:
-.LFB39:
-	.loc 1 738 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	movq	%rdi, -8(%rbp)
-	movq	%rsi, -16(%rbp)
-	movq	%rdx, -24(%rbp)
-	.loc 1 739 5
-	cmpq	$0, -24(%rbp)
-	je	.L38
-	.loc 1 739 33 discriminator 1
-	movq	-24(%rbp), %rax
-	addq	$4, %rax
-	movl	(%rax), %eax
-	movl	%eax, %eax
-	jmp	.L39
-.L38:
-	.loc 1 740 5
-	cmpq	$0, -8(%rbp)
-	je	.L40
-	.loc 1 740 14 discriminator 2
-	cmpq	$0, -16(%rbp)
-	jne	.L41
-.L40:
-	.loc 1 740 33 discriminator 3
-	movl	$0, %eax
-	jmp	.L39
-.L41:
-	.loc 1 743 33
-	movq	-16(%rbp), %rax
-	cmpq	-8(%rbp), %rax
-	ja	.L42
-	.loc 1 743 10 discriminator 1
-	leaq	__PRETTY_FUNCTION__.4547(%rip), %rcx
-	movl	$743, %edx
-	leaq	.LC0(%rip), %rsi
-	leaq	.LC2(%rip), %rdi
-	call	__assert_fail@PLT
-.L42:
-	.loc 1 745 35
-	movq	-16(%rbp), %rax
-	subq	-8(%rbp), %rax
-	.loc 1 745 63
-	movabsq	$-6148914691236517205, %rdx
-	mulq	%rdx
-	movq	%rdx, %rax
-	shrq	$4, %rax
-.L39:
-	.loc 1 746 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE39:
-	.size	dynamic_symbol_count_fast, .-dynamic_symbol_count_fast
-	.type	dynamic_symbol_count_from_dyn, @function
-dynamic_symbol_count_from_dyn:
-.LFB40:
-	.loc 1 749 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$48, %rsp
-	movq	%rdi, -40(%rbp)
-	movq	%rsi, -48(%rbp)
-	.loc 1 750 20
-	movq	-48(%rbp), %rdx
-	movq	-40(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_sysv_hash_from_dyn
-	movq	%rax, -8(%rbp)
-	.loc 1 751 5
-	cmpq	$0, -8(%rbp)
-	je	.L44
-	.loc 1 751 19 discriminator 1
-	movq	-8(%rbp), %rax
-	movq	%rax, %rdx
-	movl	$0, %esi
-	movl	$0, %edi
-	call	dynamic_symbol_count_fast
-	jmp	.L45
-.L44:
-	.loc 1 752 21
-	movq	-48(%rbp), %rdx
-	movq	-40(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_dynsym_from_dyn
-	movq	%rax, -16(%rbp)
-	.loc 1 753 26
-	movq	-48(%rbp), %rdx
-	movq	-40(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_dynstr_from_dyn
-	movq	%rax, -24(%rbp)
-	.loc 1 754 9
-	movq	-8(%rbp), %rdx
-	movq	-24(%rbp), %rcx
-	movq	-16(%rbp), %rax
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	dynamic_symbol_count_fast
-.L45:
-	.loc 1 755 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE40:
-	.size	dynamic_symbol_count_from_dyn, .-dynamic_symbol_count_from_dyn
-	.type	hash_lookup, @function
-hash_lookup:
-.LFB42:
-	.loc 1 764 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$96, %rsp
-	movq	%rdi, -72(%rbp)
-	movq	%rsi, -80(%rbp)
-	movq	%rdx, -88(%rbp)
-	movq	%rcx, -96(%rbp)
-	.loc 1 765 12
-	movq	$0, -8(%rbp)
-	.loc 1 766 12
-	movq	-72(%rbp), %rax
-	movl	(%rax), %eax
-	movl	%eax, -16(%rbp)
-	.loc 1 767 12
-	movq	-72(%rbp), %rax
-	movl	4(%rax), %eax
-	movl	%eax, -20(%rbp)
-	.loc 1 769 14
-	movq	-72(%rbp), %rax
-	addq	$8, %rax
-	movq	%rax, -32(%rbp)
-	.loc 1 770 62
-	movl	-16(%rbp), %eax
-	addl	$2, %eax
-	movl	%eax, %eax
-	.loc 1 770 59
-	leaq	0(,%rax,4), %rdx
-	.loc 1 770 14
-	movq	-72(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -40(%rbp)
-	.loc 1 772 20
-	movq	-96(%rbp), %rax
-	movq	%rax, %rdi
-	call	elf64_hash
-	movq	%rax, -48(%rbp)
-	.loc 1 773 40
-	movl	-16(%rbp), %ecx
-	movq	-48(%rbp), %rax
-	movl	$0, %edx
-	divq	%rcx
-	.loc 1 773 12
-	movq	-32(%rbp), %rax
-	movl	(%rax,%rdx,4), %eax
-	movl	%eax, -52(%rbp)
-	.loc 1 774 12
-	movl	-52(%rbp), %eax
-	movl	%eax, -12(%rbp)
-	.loc 1 775 2
-	jmp	.L47
-.L50:
-.LBB3:
-	.loc 1 777 28
-	movl	-12(%rbp), %edx
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	.loc 1 777 13
-	movq	-80(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -64(%rbp)
-	.loc 1 778 47
-	movq	-64(%rbp), %rax
-	movl	(%rax), %eax
-	movl	%eax, %edx
-	.loc 1 778 34
-	movq	-88(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 778 12
-	movq	-96(%rbp), %rax
-	movq	%rax, %rsi
-	movq	%rdx, %rdi
-	call	strcmp@PLT
-	.loc 1 778 6
-	testl	%eax, %eax
-	jne	.L48
-	.loc 1 781 14
-	movq	-64(%rbp), %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 782 4
-	jmp	.L49
-.L48:
-.LBE3:
-	.loc 1 775 36
-	movq	-40(%rbp), %rax
-	movl	-12(%rbp), %edx
-	movl	(%rax,%rdx,4), %eax
-	movl	%eax, -12(%rbp)
-.L47:
-	.loc 1 775 2 discriminator 1
-	cmpl	$0, -12(%rbp)
-	jne	.L50
-.L49:
-	.loc 1 786 9
-	movq	-8(%rbp), %rax
-	.loc 1 787 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE42:
-	.size	hash_lookup, .-hash_lookup
-	.type	dl_new_hash, @function
-dl_new_hash:
-.LFB44:
-	.loc 1 813 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	movq	%rdi, -24(%rbp)
-	.loc 1 814 16
-	movq	$5381, -8(%rbp)
-.LBB4:
-	.loc 1 815 25
-	movq	-24(%rbp), %rax
-	movzbl	(%rax), %eax
-	.loc 1 815 21
-	movb	%al, -9(%rbp)
-	.loc 1 815 2
-	jmp	.L53
-.L54:
-	.loc 1 817 9 discriminator 3
-	movq	-8(%rbp), %rdx
-	movq	%rdx, %rax
-	salq	$5, %rax
-	addq	%rax, %rdx
-	.loc 1 817 14 discriminator 3
-	movzbl	-9(%rbp), %eax
-	.loc 1 817 5 discriminator 3
-	addq	%rdx, %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 815 42 discriminator 3
-	addq	$1, -24(%rbp)
-	.loc 1 815 44 discriminator 3
-	movq	-24(%rbp), %rax
-	movzbl	(%rax), %eax
-	.loc 1 815 42 discriminator 3
-	movb	%al, -9(%rbp)
-.L53:
-	.loc 1 815 2 discriminator 1
-	cmpb	$0, -9(%rbp)
-	jne	.L54
-.LBE4:
-	.loc 1 819 11
-	movq	-8(%rbp), %rax
-	movl	%eax, %eax
-	.loc 1 820 1
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE44:
-	.size	dl_new_hash, .-dl_new_hash
-	.type	gnu_hash_lookup, @function
-gnu_hash_lookup:
-.LFB45:
-	.loc 1 824 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	addq	$-128, %rsp
-	movq	%rdi, -104(%rbp)
-	movq	%rsi, -112(%rbp)
-	movq	%rdx, -120(%rbp)
-	movq	%rcx, -128(%rbp)
-	.loc 1 825 12
-	movq	$0, -8(%rbp)
-	.loc 1 826 21
-	movq	-128(%rbp), %rax
-	movq	%rax, %rdi
-	call	dl_new_hash
-	.loc 1 826 11
-	movl	%eax, -16(%rbp)
-	.loc 1 828 12
-	movq	-104(%rbp), %rax
-	movq	%rax, -24(%rbp)
-	.loc 1 829 11
-	movq	-24(%rbp), %rax
-	movl	(%rax), %eax
-	movl	%eax, -28(%rbp)
-	.loc 1 830 11
-	movq	-24(%rbp), %rax
-	movl	4(%rax), %eax
-	movl	%eax, -32(%rbp)
-	.loc 1 831 11
-	movq	-24(%rbp), %rax
-	movl	8(%rax), %eax
-	movl	%eax, -36(%rbp)
-	.loc 1 832 11
-	movq	-24(%rbp), %rax
-	movl	12(%rax), %eax
-	movl	%eax, -40(%rbp)
-	.loc 1 834 12
-	movq	-24(%rbp), %rax
-	addq	$16, %rax
-	movq	%rax, -48(%rbp)
-	.loc 1 835 41
-	movl	-36(%rbp), %eax
-	leaq	0(,%rax,8), %rdx
-	.loc 1 835 12
-	movq	-48(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -56(%rbp)
-	.loc 1 836 30
-	movl	-28(%rbp), %eax
-	leaq	0(,%rax,4), %rdx
-	.loc 1 836 12
-	movq	-56(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -64(%rbp)
-	.loc 1 880 5
-	movl	-16(%rbp), %eax
-	shrl	$6, %eax
-	movl	%eax, %edx
-	.loc 1 880 18
-	movl	-36(%rbp), %eax
-	subl	$1, %eax
-	.loc 1 880 5
-	andl	%edx, %eax
-	movl	%eax, %eax
-	.loc 1 879 10
-	leaq	0(,%rax,8), %rdx
-	movq	-48(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 878 11
-	movq	(%rax), %rax
-	movq	%rax, -72(%rbp)
-	.loc 1 882 15
-	movl	-16(%rbp), %eax
-	andl	$63, %eax
-	movl	%eax, -76(%rbp)
-	.loc 1 883 40
-	movl	-40(%rbp), %eax
-	movl	-16(%rbp), %edx
-	movl	%eax, %ecx
-	shrl	%cl, %edx
-	movl	%edx, %eax
-	.loc 1 883 15
-	andl	$63, %eax
-	movl	%eax, -80(%rbp)
-	.loc 1 885 18
-	movl	-76(%rbp), %eax
-	movq	-72(%rbp), %rdx
-	movl	%eax, %ecx
-	shrq	%cl, %rdx
-	movq	%rdx, %rax
-	.loc 1 885 35
-	andl	$1, %eax
-	.loc 1 885 5
-	testq	%rax, %rax
-	je	.L57
-	.loc 1 886 19
-	movl	-80(%rbp), %eax
-	movq	-72(%rbp), %rdx
-	movl	%eax, %ecx
-	shrq	%cl, %rdx
-	movq	%rdx, %rax
-	.loc 1 886 36
-	andl	$1, %eax
-	.loc 1 886 4
-	testq	%rax, %rax
-	je	.L57
-.LBB5:
-	.loc 1 910 44
-	movl	-16(%rbp), %eax
-	movl	$0, %edx
-	divl	-28(%rbp)
-	movl	%edx, %eax
-	movl	%eax, %eax
-	.loc 1 910 35
-	leaq	0(,%rax,4), %rdx
-	movq	-56(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 910 12
-	movl	(%rax), %eax
-	movl	%eax, -84(%rbp)
-.LBB6:
-	.loc 1 911 17
-	movl	-84(%rbp), %eax
-	movl	%eax, -12(%rbp)
-	.loc 1 911 3
-	jmp	.L58
-.L62:
-	.loc 1 919 25
-	movl	-12(%rbp), %eax
-	subl	-32(%rbp), %eax
-	movl	%eax, %eax
-	.loc 1 919 17
-	leaq	0(,%rax,4), %rdx
-	movq	-64(%rbp), %rax
-	addq	%rdx, %rax
-	movl	(%rax), %eax
-	.loc 1 919 36
-	xorl	-16(%rbp), %eax
-	.loc 1 919 47
-	shrl	%eax
-	.loc 1 919 7
-	testl	%eax, %eax
-	jne	.L59
-	.loc 1 921 50
-	movl	-12(%rbp), %edx
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-112(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 921 58
-	movl	(%rax), %eax
-	movl	%eax, %edx
-	.loc 1 921 36
-	movq	-120(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 921 14
-	movq	-128(%rbp), %rax
-	movq	%rax, %rsi
-	movq	%rdx, %rdi
-	call	strcmp@PLT
-	.loc 1 921 8
-	testl	%eax, %eax
-	jne	.L59
-	.loc 1 923 25
-	movl	-12(%rbp), %edx
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	.loc 1 923 16
-	movq	-112(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 924 6
-	jmp	.L57
-.L59:
-	.loc 1 913 32
-	movl	-12(%rbp), %eax
-	subl	-32(%rbp), %eax
-	movl	%eax, %eax
-	.loc 1 913 24
-	leaq	0(,%rax,4), %rdx
-	movq	-64(%rbp), %rax
-	addq	%rdx, %rax
-	movl	(%rax), %eax
-	.loc 1 913 43
-	andl	$1, %eax
-	.loc 1 913 62
-	testl	%eax, %eax
-	jne	.L60
-	.loc 1 913 62 is_stmt 0 discriminator 1
-	movl	-12(%rbp), %eax
-	addl	$1, %eax
-	jmp	.L61
-.L60:
-	.loc 1 913 62 discriminator 2
-	movl	$0, %eax
-.L61:
-	.loc 1 913 12 is_stmt 1 discriminator 4
-	movl	%eax, -12(%rbp)
-.L58:
-	.loc 1 911 3 discriminator 1
-	cmpl	$0, -12(%rbp)
-	jne	.L62
-.L57:
-.LBE6:
-.LBE5:
-	.loc 1 930 9
-	movq	-8(%rbp), %rax
-	.loc 1 931 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE45:
-	.size	gnu_hash_lookup, .-gnu_hash_lookup
-	.type	symbol_lookup_linear, @function
-symbol_lookup_linear:
-.LFB49:
-	.loc 1 998 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$80, %rsp
-	movq	%rdi, -40(%rbp)
-	movq	%rsi, -48(%rbp)
-	movq	%rdx, -56(%rbp)
-	movq	%rcx, -64(%rbp)
-	movq	%r8, -72(%rbp)
-	.loc 1 999 12
-	movq	$0, -8(%rbp)
-.LBB7:
-	.loc 1 1000 17
-	movq	-40(%rbp), %rax
-	movq	%rax, -16(%rbp)
-	.loc 1 1000 2
-	jmp	.L65
-.L68:
-.LBB8:
-	.loc 1 1002 62
-	movq	-16(%rbp), %rax
-	movl	(%rax), %eax
-	movl	%eax, %edx
-	.loc 1 1002 49
-	movq	-56(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 1002 11
-	movq	-64(%rbp), %rax
-	subq	%rdx, %rax
-	movq	%rax, -24(%rbp)
-	.loc 1 1003 6
-	cmpq	$0, -24(%rbp)
-	jle	.L66
-	.loc 1 1004 9 discriminator 1
-	movq	-24(%rbp), %rdx
-	.loc 1 1004 44 discriminator 1
-	movq	-16(%rbp), %rax
-	movl	(%rax), %eax
-	movl	%eax, %ecx
-	.loc 1 1004 31 discriminator 1
-	movq	-56(%rbp), %rax
-	addq	%rax, %rcx
-	.loc 1 1004 9 discriminator 1
-	movq	-72(%rbp), %rax
-	movq	%rax, %rsi
-	movq	%rcx, %rdi
-	call	strncmp@PLT
-	.loc 1 1003 34 discriminator 1
-	testl	%eax, %eax
-	jne	.L66
-	.loc 1 1007 14
-	movq	-16(%rbp), %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 1008 4
-	jmp	.L67
-.L66:
-.LBE8:
-	.loc 1 1000 58 discriminator 2
-	addq	$24, -16(%rbp)
-.L65:
-	.loc 1 1000 2 discriminator 1
-	movq	-16(%rbp), %rax
-	cmpq	-48(%rbp), %rax
-	jbe	.L68
-.L67:
-.LBE7:
-	.loc 1 1012 9
-	movq	-8(%rbp), %rax
-	.loc 1 1013 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE49:
-	.size	symbol_lookup_linear, .-symbol_lookup_linear
-	.type	symbol_lookup_in_dyn, @function
-symbol_lookup_in_dyn:
-.LFB53:
-	.loc 1 1048 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$96, %rsp
-	movq	%rdi, -72(%rbp)
-	movq	%rsi, -80(%rbp)
-	movq	%rdx, -88(%rbp)
-	.loc 1 1049 20
-	movq	-80(%rbp), %rdx
-	movq	-72(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_sysv_hash_from_dyn
-	movq	%rax, -16(%rbp)
-	.loc 1 1050 24
-	movq	-80(%rbp), %rdx
-	movq	-72(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_gnu_hash_from_dyn
-	movq	%rax, -24(%rbp)
-	.loc 1 1051 21
-	movq	-80(%rbp), %rdx
-	movq	-72(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_dynsym_from_dyn
-	movq	%rax, -32(%rbp)
-	.loc 1 1052 5
-	cmpq	$0, -32(%rbp)
-	jne	.L71
-	.loc 1 1052 22 discriminator 1
-	movl	$0, %eax
-	jmp	.L72
-.L71:
-	.loc 1 1053 34
-	movq	-80(%rbp), %rdx
-	movq	-72(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	dynamic_symbol_count_from_dyn
-	movq	%rax, %rdx
-	.loc 1 1053 32
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	.loc 1 1053 12
-	movq	-32(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -40(%rbp)
-	.loc 1 1054 26
-	movq	-80(%rbp), %rdx
-	movq	-72(%rbp), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	get_dynstr_from_dyn
-	movq	%rax, -48(%rbp)
-	.loc 1 1055 39
-	movq	-72(%rbp), %rax
-	movl	$10, %esi
-	movq	%rax, %rdi
-	call	dynamic_xlookup
-	.loc 1 1055 72
-	movq	8(%rax), %rdx
-	.loc 1 1055 17
-	movq	-48(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -56(%rbp)
-	.loc 1 1059 12
-	movq	$0, -8(%rbp)
-	.loc 1 1060 5
-	cmpq	$0, -24(%rbp)
-	je	.L73
-	.loc 1 1060 24 discriminator 1
-	movq	-88(%rbp), %rcx
-	movq	-48(%rbp), %rdx
-	movq	-32(%rbp), %rsi
-	movq	-24(%rbp), %rax
-	movq	%rax, %rdi
-	call	gnu_hash_lookup
-	movq	%rax, -8(%rbp)
-	jmp	.L74
-.L73:
-	.loc 1 1061 10
-	cmpq	$0, -16(%rbp)
-	je	.L75
-	.loc 1 1061 25 discriminator 1
-	movq	-88(%rbp), %rcx
-	movq	-48(%rbp), %rdx
-	movq	-32(%rbp), %rsi
-	movq	-16(%rbp), %rax
-	movq	%rax, %rdi
-	call	hash_lookup
-	movq	%rax, -8(%rbp)
-	jmp	.L74
-.L75:
-	.loc 1 1062 15
-	movq	-88(%rbp), %rdi
-	movq	-56(%rbp), %rcx
-	movq	-48(%rbp), %rdx
-	movq	-40(%rbp), %rsi
-	movq	-32(%rbp), %rax
-	movq	%rdi, %r8
-	movq	%rax, %rdi
-	call	symbol_lookup_linear
-	movq	%rax, -8(%rbp)
-.L74:
-	.loc 1 1063 9
-	movq	-8(%rbp), %rax
-.L72:
-	.loc 1 1064 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE53:
-	.size	symbol_lookup_in_dyn, .-symbol_lookup_in_dyn
-	.globl	_dl_debug_state
-	.hidden	_dl_debug_state
-	.type	_dl_debug_state, @function
-_dl_debug_state:
-.LFB61:
-	.file 2 "chain.c"
-	.loc 2 49 28
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	.loc 2 49 1
-	nop
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE61:
-	.size	_dl_debug_state, .-_dl_debug_state
-	.section	.rodata
-	.align 8
-.LC3:
-	.string	"allocsld: could not find the program phdrs\n"
-	.align 8
-.LC4:
-	.string	"allocsld: could not infer program base address (no PT_PHDR?)\n"
-	.align 8
-.LC5:
-	.string	"allocsld: PT_INTERP is not writable, so can't transparently chain-load ld.so\nspecial args are required when setting allocsld.so as the dynamic linker\n"
-	.align 8
-.LC6:
-	.string	"allocsld: could not find PT_INTERP header in the target program\n"
-	.align 8
-.LC7:
-	.string	"allocsld: insufficient space for ld.so interp string (size %d)\n"
-.LC8:
-	.string	"_r_debug"
-.LC9:
-	.string	"_dl_debug_state"
-.LC10:
-	.string	"chain.c"
-.LC11:
-	.string	"fs"
-	.text
-	.globl	cover_tracks
-	.hidden	cover_tracks
-	.type	cover_tracks, @function
-cover_tracks:
-.LFB62:
-	.loc 2 53 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$160, %rsp
-	movl	%edi, %eax
-	movq	%rsi, -128(%rbp)
-	movl	%edx, -120(%rbp)
-	movq	%rcx, -136(%rbp)
-	movq	%r8, -144(%rbp)
-	movq	%r9, -152(%rbp)
-	movb	%al, -116(%rbp)
-	.loc 2 107 6
-	movzbl	-116(%rbp), %eax
-	xorl	$1, %eax
-	.loc 2 107 5
-	testb	%al, %al
-	je	.L93
-.LBB9:
-	.loc 2 109 9
-	movq	$0, -8(%rbp)
-	.loc 2 110 10
-	movq	$0, -16(%rbp)
-	.loc 2 111 6
-	cmpq	$0, -128(%rbp)
-	jne	.L79
-	.loc 2 111 28 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	%rax, %rcx
-	movl	$43, %edx
-	movl	$1, %esi
-	leaq	.LC3(%rip), %rdi
-	call	fwrite@PLT
-	.loc 2 111 79 discriminator 1
-	movl	$-1, %edi
-	call	exit@PLT
-.L79:
-	.loc 2 114 13
-	movq	$0, -24(%rbp)
-.LBB10:
-	.loc 2 115 12
-	movl	$0, -28(%rbp)
-	.loc 2 115 3
-	jmp	.L80
-.L82:
-	.loc 2 117 21
-	movl	-28(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-128(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 117 24
-	movl	(%rax), %eax
-	.loc 2 117 7
-	cmpl	$6, %eax
-	jne	.L81
-	.loc 2 119 25
-	movq	-128(%rbp), %rcx
-	.loc 2 120 21
-	movl	-28(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-128(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 120 24
-	movq	16(%rax), %rax
-	.loc 2 119 23
-	subq	%rax, %rcx
-	movq	%rcx, %rax
-	movq	%rax, -24(%rbp)
-.L81:
-	.loc 2 115 38 discriminator 2
-	addl	$1, -28(%rbp)
-.L80:
-	.loc 2 115 21 discriminator 1
-	movl	-28(%rbp), %eax
-	.loc 2 115 3 discriminator 1
-	cmpl	%eax, -120(%rbp)
-	ja	.L82
-.LBE10:
-	.loc 2 123 6
-	cmpq	$0, -24(%rbp)
-	jne	.L83
-	.loc 2 123 32 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	%rax, %rcx
-	movl	$61, %edx
-	movl	$1, %esi
-	leaq	.LC4(%rip), %rdi
-	call	fwrite@PLT
-	.loc 2 123 101 discriminator 1
-	movl	$-1, %edi
-	call	exit@PLT
-.L83:
-.LBB11:
-	.loc 2 124 12
-	movl	$0, -32(%rbp)
-	.loc 2 124 3
-	jmp	.L84
-.L87:
-	.loc 2 126 21
-	movl	-32(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-128(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 126 24
-	movl	(%rax), %eax
-	.loc 2 126 7
-	cmpl	$3, %eax
-	jne	.L85
-	.loc 2 129 9
-	movzbl	-116(%rbp), %eax
-	xorl	$1, %eax
-	.loc 2 129 8
-	testb	%al, %al
-	je	.L86
-	.loc 2 129 47 discriminator 1
-	movl	-32(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-128(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 129 50 discriminator 1
-	movl	4(%rax), %eax
-	.loc 2 129 59 discriminator 1
-	andl	$2, %eax
-	.loc 2 129 29 discriminator 1
-	testl	%eax, %eax
-	jne	.L86
-	.loc 2 131 11
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	%rax, %rcx
-	movl	$150, %edx
-	movl	$1, %esi
-	leaq	.LC5(%rip), %rdi
-	call	fwrite@PLT
-	.loc 2 131 173
-	movl	$-1, %edi
-	call	exit@PLT
-.L86:
-	.loc 2 134 61
-	movl	-32(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-128(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 134 64
-	movq	16(%rax), %rdx
-	.loc 2 134 46
-	movq	-24(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 134 17
-	movq	%rax, -8(%rbp)
-	.loc 2 135 30
-	movl	-32(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-128(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 135 15
-	movq	32(%rax), %rax
-	movq	%rax, -16(%rbp)
-.L85:
-	.loc 2 124 38 discriminator 2
-	addl	$1, -32(%rbp)
-.L84:
-	.loc 2 124 21 discriminator 1
-	movl	-32(%rbp), %eax
-	.loc 2 124 3 discriminator 1
-	cmpl	%eax, -120(%rbp)
-	ja	.L87
-.LBE11:
-	.loc 2 138 6
-	cmpq	$0, -8(%rbp)
-	jne	.L88
-	.loc 2 138 26 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	%rax, %rcx
-	movl	$64, %edx
-	movl	$1, %esi
-	leaq	.LC6(%rip), %rdi
-	call	fwrite@PLT
-	.loc 2 138 98 discriminator 1
-	movl	$-1, %edi
-	call	exit@PLT
-.L88:
-	.loc 2 139 19
-	movq	-136(%rbp), %rax
-	movq	%rax, %rdi
-	call	strlen@PLT
-	.loc 2 139 37
-	addq	$1, %rax
-	.loc 2 139 6
-	cmpq	%rax, -16(%rbp)
-	jnb	.L89
-	.loc 2 141 9
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-16(%rbp), %rdx
-	leaq	.LC7(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 2 141 92
-	movl	$-1, %edi
-	call	exit@PLT
-.L89:
-	.loc 2 143 34
-	movq	-136(%rbp), %rax
-	movq	%rax, %rdi
-	call	strlen@PLT
-	.loc 2 143 3
-	leaq	1(%rax), %rdx
-	movq	-136(%rbp), %rcx
-	movq	-8(%rbp), %rax
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	memcpy@PLT
-	.loc 2 151 54
-	movq	-144(%rbp), %rdx
-	movq	-152(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 151 13
-	movq	%rax, -40(%rbp)
-	.loc 2 152 18
-	movq	-152(%rbp), %rcx
-	movq	-40(%rbp), %rax
-	leaq	.LC8(%rip), %rdx
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	symbol_lookup_in_dyn
-	movq	%rax, -48(%rbp)
-	.loc 2 154 45
-	movq	-48(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 2 154 41
-	movq	-152(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 154 19
-	movq	%rax, -56(%rbp)
-	.loc 2 155 18
-	movq	-152(%rbp), %rcx
-	movq	-40(%rbp), %rax
-	leaq	.LC9(%rip), %rdx
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	symbol_lookup_in_dyn
-	movq	%rax, -64(%rbp)
-	.loc 2 156 34
-	cmpq	$0, -64(%rbp)
-	jne	.L90
-	.loc 2 156 11 discriminator 1
-	leaq	__PRETTY_FUNCTION__.4825(%rip), %rcx
-	movl	$156, %edx
-	leaq	.LC10(%rip), %rsi
-	leaq	.LC11(%rip), %rdi
-	call	__assert_fail@PLT
-.L90:
-	.loc 2 170 35
-	movq	-64(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 2 170 31
-	movq	-152(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 170 9
-	movq	%rax, -72(%rbp)
-	.loc 2 172 31
-	movq	-72(%rbp), %rax
-	.loc 2 172 59
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	movq	%rdx, %rax
-	.loc 2 172 21
-	testq	%rax, %rax
-	je	.L91
-	.loc 2 172 139 discriminator 1
-	movq	-72(%rbp), %rax
-	.loc 2 172 166 discriminator 1
-	movq	page_size(%rip), %rsi
-	movl	$0, %edx
-	divq	%rsi
-	movq	%rax, %rdx
-	.loc 2 172 111 discriminator 1
-	movq	page_size(%rip), %rax
-	imulq	%rdx, %rax
-	jmp	.L92
-.L91:
-	.loc 2 172 21 discriminator 2
-	movq	-72(%rbp), %rax
-.L92:
-	.loc 2 172 9 discriminator 4
-	movq	%rax, -80(%rbp)
-	.loc 2 173 13 discriminator 4
-	movq	page_size(%rip), %rcx
-	movq	-80(%rbp), %rax
-	movl	$3, %edx
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	mprotect@PLT
-	movl	%eax, -84(%rbp)
-	.loc 2 175 8 discriminator 4
-	movb	$72, -96(%rbp)
-	movb	$-72, -95(%rbp)
-	movb	$-16, -94(%rbp)
-	movb	$-34, -93(%rbp)
-	movb	$-68, -92(%rbp)
-	movb	$-102, -91(%rbp)
-	movb	$120, -90(%rbp)
-	movb	$86, -89(%rbp)
-	movb	$52, -88(%rbp)
-	movb	$18, -87(%rbp)
-	movb	$-1, -86(%rbp)
-	movb	$-32, -85(%rbp)
-	.loc 2 177 30 discriminator 4
-	leaq	_dl_debug_state(%rip), %rax
-	.loc 2 177 13 discriminator 4
-	movq	%rax, -104(%rbp)
-	.loc 2 178 3 discriminator 4
-	leaq	-96(%rbp), %rax
-	addq	$2, %rax
-	movq	-104(%rbp), %rdx
-	movq	%rdx, (%rax)
-	.loc 2 179 3 discriminator 4
-	movq	-72(%rbp), %rax
-	movq	-96(%rbp), %rdx
-	movq	%rdx, (%rax)
-	movl	-88(%rbp), %edx
-	movl	%edx, 8(%rax)
-	.loc 2 180 3 discriminator 4
-	movq	page_size(%rip), %rcx
-	movq	-80(%rbp), %rax
-	movl	$5, %edx
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	mprotect@PLT
-.L93:
-.LBE9:
-	.loc 2 185 1
-	nop
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE62:
-	.size	cover_tracks, .-cover_tracks
-	.section	.rodata
-	.align 8
-	.type	__PRETTY_FUNCTION__.4825, @object
-	.size	__PRETTY_FUNCTION__.4825, 13
-__PRETTY_FUNCTION__.4825:
-	.string	"cover_tracks"
-	.align 16
-	.type	__PRETTY_FUNCTION__.4547, @object
-	.size	__PRETTY_FUNCTION__.4547, 26
-__PRETTY_FUNCTION__.4547:
-	.string	"dynamic_symbol_count_fast"
-	.align 16
-	.type	__func__.4434, @object
-	.size	__func__.4434, 16
-__func__.4434:
-	.string	"dynamic_xlookup"
-	.text
-.Letext0:
-	.file 3 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
-	.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
-	.file 5 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
-	.file 6 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
-	.file 7 "/usr/include/stdio.h"
-	.file 8 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
-	.file 9 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
-	.file 10 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
-	.file 11 "/usr/include/stdint.h"
-	.file 12 "/usr/include/elf.h"
-	.file 13 "/usr/include/unistd.h"
-	.file 14 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
-	.file 15 "/usr/local/src/liballocs/contrib/donald/src/donald.h"
-	.file 16 "/usr/include/link.h"
-	.section	.debug_info,"",@progbits
-.Ldebug_info0:
-	.long	0x1173
-	.value	0x4
-	.long	.Ldebug_abbrev0
-	.byte	0x8
-	.uleb128 0x1
-	.long	.LASF198
-	.byte	0xc
-	.long	.LASF199
-	.long	.LASF200
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.long	.Ldebug_line0
-	.uleb128 0x2
-	.long	.LASF6
-	.byte	0x3
-	.byte	0xd8
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF0
-	.uleb128 0x3
-	.byte	0x4
-	.byte	0x7
-	.long	.LASF1
-	.uleb128 0x4
-	.byte	0x8
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x8
-	.long	.LASF2
-	.uleb128 0x5
-	.long	0x49
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x7
-	.long	.LASF3
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF4
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x5
-	.long	.LASF5
-	.uleb128 0x2
-	.long	.LASF7
-	.byte	0x4
-	.byte	0x27
-	.byte	0x1c
-	.long	0x55
-	.uleb128 0x2
-	.long	.LASF8
-	.byte	0x4
-	.byte	0x28
-	.byte	0x14
-	.long	0x82
-	.uleb128 0x6
-	.byte	0x4
-	.byte	0x5
-	.string	"int"
-	.uleb128 0x2
-	.long	.LASF9
-	.byte	0x4
-	.byte	0x29
-	.byte	0x16
-	.long	0x40
-	.uleb128 0x2
-	.long	.LASF10
-	.byte	0x4
-	.byte	0x2b
-	.byte	0x19
-	.long	0xa1
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF11
-	.uleb128 0x2
-	.long	.LASF12
-	.byte	0x4
-	.byte	0x2c
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF13
-	.byte	0x4
-	.byte	0x96
-	.byte	0x12
-	.long	0xa1
-	.uleb128 0x2
-	.long	.LASF14
-	.byte	0x4
-	.byte	0x97
-	.byte	0x12
-	.long	0xa1
-	.uleb128 0x2
-	.long	.LASF15
-	.byte	0x4
-	.byte	0xbf
-	.byte	0x12
-	.long	0xa1
-	.uleb128 0x7
-	.byte	0x8
-	.long	0xde
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF16
-	.uleb128 0x5
-	.long	0xde
-	.uleb128 0x8
-	.long	.LASF116
-	.byte	0xd8
-	.byte	0x5
-	.byte	0x31
-	.byte	0x8
-	.long	0x271
-	.uleb128 0x9
-	.long	.LASF17
-	.byte	0x5
-	.byte	0x33
-	.byte	0x7
-	.long	0x82
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF18
-	.byte	0x5
-	.byte	0x36
-	.byte	0x9
-	.long	0xd8
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF19
-	.byte	0x5
-	.byte	0x37
-	.byte	0x9
-	.long	0xd8
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF20
-	.byte	0x5
-	.byte	0x38
-	.byte	0x9
-	.long	0xd8
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF21
-	.byte	0x5
-	.byte	0x39
-	.byte	0x9
-	.long	0xd8
-	.byte	0x20
-	.uleb128 0x9
-	.long	.LASF22
-	.byte	0x5
-	.byte	0x3a
-	.byte	0x9
-	.long	0xd8
-	.byte	0x28
-	.uleb128 0x9
-	.long	.LASF23
-	.byte	0x5
-	.byte	0x3b
-	.byte	0x9
-	.long	0xd8
-	.byte	0x30
-	.uleb128 0x9
-	.long	.LASF24
-	.byte	0x5
-	.byte	0x3c
-	.byte	0x9
-	.long	0xd8
-	.byte	0x38
-	.uleb128 0x9
-	.long	.LASF25
-	.byte	0x5
-	.byte	0x3d
-	.byte	0x9
-	.long	0xd8
-	.byte	0x40
-	.uleb128 0x9
-	.long	.LASF26
-	.byte	0x5
-	.byte	0x40
-	.byte	0x9
-	.long	0xd8
-	.byte	0x48
-	.uleb128 0x9
-	.long	.LASF27
-	.byte	0x5
-	.byte	0x41
-	.byte	0x9
-	.long	0xd8
-	.byte	0x50
-	.uleb128 0x9
-	.long	.LASF28
-	.byte	0x5
-	.byte	0x42
-	.byte	0x9
-	.long	0xd8
-	.byte	0x58
-	.uleb128 0x9
-	.long	.LASF29
-	.byte	0x5
-	.byte	0x44
-	.byte	0x16
-	.long	0x28a
-	.byte	0x60
-	.uleb128 0x9
-	.long	.LASF30
-	.byte	0x5
-	.byte	0x46
-	.byte	0x14
-	.long	0x290
-	.byte	0x68
-	.uleb128 0x9
-	.long	.LASF31
-	.byte	0x5
-	.byte	0x48
-	.byte	0x7
-	.long	0x82
-	.byte	0x70
-	.uleb128 0x9
-	.long	.LASF32
-	.byte	0x5
-	.byte	0x49
-	.byte	0x7
-	.long	0x82
-	.byte	0x74
-	.uleb128 0x9
-	.long	.LASF33
-	.byte	0x5
-	.byte	0x4a
-	.byte	0xb
-	.long	0xb4
-	.byte	0x78
-	.uleb128 0x9
-	.long	.LASF34
-	.byte	0x5
-	.byte	0x4d
-	.byte	0x12
-	.long	0x55
-	.byte	0x80
-	.uleb128 0x9
-	.long	.LASF35
-	.byte	0x5
-	.byte	0x4e
-	.byte	0xf
-	.long	0x5c
-	.byte	0x82
-	.uleb128 0x9
-	.long	.LASF36
-	.byte	0x5
-	.byte	0x4f
-	.byte	0x8
-	.long	0x296
-	.byte	0x83
-	.uleb128 0x9
-	.long	.LASF37
-	.byte	0x5
-	.byte	0x51
-	.byte	0xf
-	.long	0x2a6
-	.byte	0x88
-	.uleb128 0x9
-	.long	.LASF38
-	.byte	0x5
-	.byte	0x59
-	.byte	0xd
-	.long	0xc0
-	.byte	0x90
-	.uleb128 0x9
-	.long	.LASF39
-	.byte	0x5
-	.byte	0x5b
-	.byte	0x17
-	.long	0x2b1
-	.byte	0x98
-	.uleb128 0x9
-	.long	.LASF40
-	.byte	0x5
-	.byte	0x5c
-	.byte	0x19
-	.long	0x2bc
-	.byte	0xa0
-	.uleb128 0x9
-	.long	.LASF41
-	.byte	0x5
-	.byte	0x5d
-	.byte	0x14
-	.long	0x290
-	.byte	0xa8
-	.uleb128 0x9
-	.long	.LASF42
-	.byte	0x5
-	.byte	0x5e
-	.byte	0x9
-	.long	0x47
-	.byte	0xb0
-	.uleb128 0x9
-	.long	.LASF43
-	.byte	0x5
-	.byte	0x5f
-	.byte	0xa
-	.long	0x2d
-	.byte	0xb8
-	.uleb128 0x9
-	.long	.LASF44
-	.byte	0x5
-	.byte	0x60
-	.byte	0x7
-	.long	0x82
-	.byte	0xc0
-	.uleb128 0x9
-	.long	.LASF45
-	.byte	0x5
-	.byte	0x62
-	.byte	0x8
-	.long	0x2c2
-	.byte	0xc4
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF46
-	.byte	0x6
-	.byte	0x7
-	.byte	0x19
-	.long	0xea
-	.uleb128 0xa
-	.long	.LASF201
-	.byte	0x5
-	.byte	0x2b
-	.byte	0xe
-	.uleb128 0xb
-	.long	.LASF47
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x285
-	.uleb128 0x7
-	.byte	0x8
-	.long	0xea
-	.uleb128 0xc
-	.long	0xde
-	.long	0x2a6
-	.uleb128 0xd
-	.long	0x39
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x27d
-	.uleb128 0xb
-	.long	.LASF48
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x2ac
-	.uleb128 0xb
-	.long	.LASF49
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x2b7
-	.uleb128 0xc
-	.long	0xde
-	.long	0x2d2
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x13
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF50
-	.byte	0x7
-	.byte	0x4d
-	.byte	0x13
-	.long	0xcc
-	.uleb128 0xe
-	.long	.LASF51
-	.byte	0x7
-	.byte	0x89
-	.byte	0xe
-	.long	0x2ea
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x271
-	.uleb128 0xe
-	.long	.LASF52
-	.byte	0x7
-	.byte	0x8a
-	.byte	0xe
-	.long	0x2ea
-	.uleb128 0xe
-	.long	.LASF53
-	.byte	0x7
-	.byte	0x8b
-	.byte	0xe
-	.long	0x2ea
-	.uleb128 0xe
-	.long	.LASF54
-	.byte	0x8
-	.byte	0x1a
-	.byte	0xc
-	.long	0x82
-	.uleb128 0xc
-	.long	0x32a
-	.long	0x31f
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0x5
-	.long	0x314
-	.uleb128 0x7
-	.byte	0x8
-	.long	0xe5
-	.uleb128 0x5
-	.long	0x324
-	.uleb128 0xe
-	.long	.LASF55
-	.byte	0x8
-	.byte	0x1b
-	.byte	0x1a
-	.long	0x31f
-	.uleb128 0x2
-	.long	.LASF56
-	.byte	0x9
-	.byte	0x1a
-	.byte	0x13
-	.long	0x76
-	.uleb128 0x2
-	.long	.LASF57
-	.byte	0x9
-	.byte	0x1b
-	.byte	0x13
-	.long	0x95
-	.uleb128 0x2
-	.long	.LASF58
-	.byte	0xa
-	.byte	0x19
-	.byte	0x14
-	.long	0x6a
-	.uleb128 0x2
-	.long	.LASF59
-	.byte	0xa
-	.byte	0x1a
-	.byte	0x14
-	.long	0x89
-	.uleb128 0x2
-	.long	.LASF60
-	.byte	0xa
-	.byte	0x1b
-	.byte	0x14
-	.long	0xa8
-	.uleb128 0x2
-	.long	.LASF61
-	.byte	0xb
-	.byte	0x4a
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF62
-	.byte	0xb
-	.byte	0x5a
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF63
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF64
-	.uleb128 0x2
-	.long	.LASF65
-	.byte	0xc
-	.byte	0x25
-	.byte	0x12
-	.long	0x35f
-	.uleb128 0x2
-	.long	.LASF66
-	.byte	0xc
-	.byte	0x26
-	.byte	0x11
-	.long	0x33b
-	.uleb128 0x2
-	.long	.LASF67
-	.byte	0xc
-	.byte	0x2b
-	.byte	0x12
-	.long	0x36b
-	.uleb128 0x2
-	.long	.LASF68
-	.byte	0xc
-	.byte	0x2c
-	.byte	0x11
-	.long	0x347
-	.uleb128 0x2
-	.long	.LASF69
-	.byte	0xc
-	.byte	0x30
-	.byte	0x12
-	.long	0x36b
-	.uleb128 0x2
-	.long	.LASF70
-	.byte	0xc
-	.byte	0x34
-	.byte	0x12
-	.long	0x36b
-	.uleb128 0x2
-	.long	.LASF71
-	.byte	0xc
-	.byte	0x38
-	.byte	0x12
-	.long	0x353
-	.uleb128 0x10
-	.byte	0x18
-	.byte	0xc
-	.value	0x210
-	.byte	0x9
-	.long	0x450
-	.uleb128 0x11
-	.long	.LASF72
-	.byte	0xc
-	.value	0x212
-	.byte	0xe
-	.long	0x39d
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF73
-	.byte	0xc
-	.value	0x213
-	.byte	0x11
-	.long	0x49
-	.byte	0x4
-	.uleb128 0x11
-	.long	.LASF74
-	.byte	0xc
-	.value	0x214
-	.byte	0x11
-	.long	0x49
-	.byte	0x5
-	.uleb128 0x11
-	.long	.LASF75
-	.byte	0xc
-	.value	0x215
-	.byte	0x11
-	.long	0x3e5
-	.byte	0x6
-	.uleb128 0x11
-	.long	.LASF76
-	.byte	0xc
-	.value	0x216
-	.byte	0xe
-	.long	0x3cd
-	.byte	0x8
-	.uleb128 0x11
-	.long	.LASF77
-	.byte	0xc
-	.value	0x217
-	.byte	0xf
-	.long	0x3b5
-	.byte	0x10
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF78
-	.byte	0xc
-	.value	0x218
-	.byte	0x3
-	.long	0x3f1
-	.uleb128 0x10
-	.byte	0x38
-	.byte	0xc
-	.value	0x2b2
-	.byte	0x9
-	.long	0x4d8
-	.uleb128 0x11
-	.long	.LASF79
-	.byte	0xc
-	.value	0x2b4
-	.byte	0xe
-	.long	0x39d
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF80
-	.byte	0xc
-	.value	0x2b5
-	.byte	0xe
-	.long	0x39d
-	.byte	0x4
-	.uleb128 0x11
-	.long	.LASF81
-	.byte	0xc
-	.value	0x2b6
-	.byte	0xd
-	.long	0x3d9
-	.byte	0x8
-	.uleb128 0x11
-	.long	.LASF82
-	.byte	0xc
-	.value	0x2b7
-	.byte	0xe
-	.long	0x3cd
-	.byte	0x10
-	.uleb128 0x11
-	.long	.LASF83
-	.byte	0xc
-	.value	0x2b8
-	.byte	0xe
-	.long	0x3cd
-	.byte	0x18
-	.uleb128 0x11
-	.long	.LASF84
-	.byte	0xc
-	.value	0x2b9
-	.byte	0xf
-	.long	0x3b5
-	.byte	0x20
-	.uleb128 0x11
-	.long	.LASF85
-	.byte	0xc
-	.value	0x2ba
-	.byte	0xf
-	.long	0x3b5
-	.byte	0x28
-	.uleb128 0x11
-	.long	.LASF86
-	.byte	0xc
-	.value	0x2bb
-	.byte	0xf
-	.long	0x3b5
-	.byte	0x30
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF87
-	.byte	0xc
-	.value	0x2bc
-	.byte	0x3
-	.long	0x45d
-	.uleb128 0x13
-	.byte	0x8
-	.byte	0xc
-	.value	0x340
-	.byte	0x3
-	.long	0x50a
-	.uleb128 0x14
-	.long	.LASF88
-	.byte	0xc
-	.value	0x342
-	.byte	0x13
-	.long	0x3b5
-	.uleb128 0x14
-	.long	.LASF89
-	.byte	0xc
-	.value	0x343
-	.byte	0x12
-	.long	0x3cd
-	.byte	0
-	.uleb128 0x10
-	.byte	0x10
-	.byte	0xc
-	.value	0x33d
-	.byte	0x9
-	.long	0x531
-	.uleb128 0x11
-	.long	.LASF90
-	.byte	0xc
-	.value	0x33f
-	.byte	0x10
-	.long	0x3c1
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF91
-	.byte	0xc
-	.value	0x344
-	.byte	0x7
-	.long	0x4e5
-	.byte	0x8
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF92
-	.byte	0xc
-	.value	0x345
-	.byte	0x3
-	.long	0x50a
-	.uleb128 0x13
-	.byte	0x8
-	.byte	0xc
-	.value	0x470
-	.byte	0x3
-	.long	0x556
-	.uleb128 0x14
-	.long	.LASF93
-	.byte	0xc
-	.value	0x472
-	.byte	0x10
-	.long	0x36b
-	.byte	0
-	.uleb128 0x10
-	.byte	0x10
-	.byte	0xc
-	.value	0x46d
-	.byte	0x9
-	.long	0x57d
-	.uleb128 0x11
-	.long	.LASF94
-	.byte	0xc
-	.value	0x46f
-	.byte	0xc
-	.long	0x36b
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF95
-	.byte	0xc
-	.value	0x476
-	.byte	0x7
-	.long	0x53e
-	.byte	0x8
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF96
-	.byte	0xc
-	.value	0x477
-	.byte	0x3
-	.long	0x556
-	.uleb128 0x15
-	.long	.LASF97
-	.byte	0xd
-	.value	0x21f
-	.byte	0xf
-	.long	0x597
-	.uleb128 0x7
-	.byte	0x8
-	.long	0xd8
-	.uleb128 0xe
-	.long	.LASF98
-	.byte	0xe
-	.byte	0x24
-	.byte	0xe
-	.long	0xd8
-	.uleb128 0xe
-	.long	.LASF99
-	.byte	0xe
-	.byte	0x32
-	.byte	0xc
-	.long	0x82
-	.uleb128 0xe
-	.long	.LASF100
-	.byte	0xe
-	.byte	0x37
-	.byte	0xc
-	.long	0x82
-	.uleb128 0xe
-	.long	.LASF101
-	.byte	0xe
-	.byte	0x3b
-	.byte	0xc
-	.long	0x82
-	.uleb128 0xe
-	.long	.LASF102
-	.byte	0xf
-	.byte	0x32
-	.byte	0xc
-	.long	0x82
-	.uleb128 0xe
-	.long	.LASF103
-	.byte	0xf
-	.byte	0x33
-	.byte	0xf
-	.long	0x597
-	.uleb128 0xe
-	.long	.LASF104
-	.byte	0xf
-	.byte	0x34
-	.byte	0x13
-	.long	0x5f1
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x531
-	.uleb128 0xe
-	.long	.LASF105
-	.byte	0xf
-	.byte	0x35
-	.byte	0x16
-	.long	0x603
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x57d
-	.uleb128 0xe
-	.long	.LASF106
-	.byte	0xf
-	.byte	0x36
-	.byte	0x16
-	.long	0x39
-	.uleb128 0xe
-	.long	.LASF107
-	.byte	0xf
-	.byte	0x37
-	.byte	0xe
-	.long	0x47
-	.uleb128 0xc
-	.long	0x531
-	.long	0x62c
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF108
-	.byte	0xf
-	.byte	0x38
-	.byte	0x12
-	.long	0x621
-	.uleb128 0x3
-	.byte	0x4
-	.byte	0x4
-	.long	.LASF109
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x4
-	.long	.LASF110
-	.uleb128 0x3
-	.byte	0x10
-	.byte	0x5
-	.long	.LASF111
-	.uleb128 0x3
-	.byte	0x10
-	.byte	0x4
-	.long	.LASF112
-	.uleb128 0x16
-	.byte	0x7
-	.byte	0x4
-	.long	0x40
-	.byte	0x10
-	.byte	0x37
-	.byte	0x7
-	.long	0x675
-	.uleb128 0x17
-	.long	.LASF113
-	.byte	0
-	.uleb128 0x17
-	.long	.LASF114
-	.byte	0x1
-	.uleb128 0x17
-	.long	.LASF115
-	.byte	0x2
-	.byte	0
-	.uleb128 0x8
-	.long	.LASF117
-	.byte	0x28
-	.byte	0x10
-	.byte	0x2a
-	.byte	0x8
-	.long	0x6c4
-	.uleb128 0x9
-	.long	.LASF118
-	.byte	0x10
-	.byte	0x2c
-	.byte	0x9
-	.long	0x82
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF119
-	.byte	0x10
-	.byte	0x2e
-	.byte	0x16
-	.long	0x713
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF120
-	.byte	0x10
-	.byte	0x35
-	.byte	0x10
-	.long	0x3cd
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF121
-	.byte	0x10
-	.byte	0x3d
-	.byte	0x9
-	.long	0x654
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF122
-	.byte	0x10
-	.byte	0x3f
-	.byte	0x10
-	.long	0x3cd
-	.byte	0x20
-	.byte	0
-	.uleb128 0x8
-	.long	.LASF123
-	.byte	0x28
-	.byte	0x10
-	.byte	0x54
-	.byte	0x8
-	.long	0x713
-	.uleb128 0x9
-	.long	.LASF124
-	.byte	0x10
-	.byte	0x59
-	.byte	0x10
-	.long	0x3cd
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF125
-	.byte	0x10
-	.byte	0x5b
-	.byte	0xb
-	.long	0xd8
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF126
-	.byte	0x10
-	.byte	0x5c
-	.byte	0x10
-	.long	0x5f1
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF127
-	.byte	0x10
-	.byte	0x5d
-	.byte	0x16
-	.long	0x713
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF128
-	.byte	0x10
-	.byte	0x5d
-	.byte	0x1f
-	.long	0x713
-	.byte	0x20
-	.byte	0
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x6c4
-	.uleb128 0xe
-	.long	.LASF129
-	.byte	0x10
-	.byte	0x43
-	.byte	0x17
-	.long	0x675
-	.uleb128 0xe
-	.long	.LASF130
-	.byte	0x1
-	.byte	0x8d
-	.byte	0xc
-	.long	0x82
-	.uleb128 0xe
-	.long	.LASF131
-	.byte	0x1
-	.byte	0x8e
-	.byte	0xc
-	.long	0x82
-	.uleb128 0x15
-	.long	.LASF132
-	.byte	0x1
-	.value	0x12c
-	.byte	0xe
-	.long	0x47
-	.uleb128 0x15
-	.long	.LASF133
-	.byte	0x1
-	.value	0x27f
-	.byte	0xc
-	.long	0x82
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x450
-	.uleb128 0x18
-	.long	.LASF202
-	.byte	0x2
-	.byte	0x34
-	.byte	0x6
-	.quad	.LFB62
-	.quad	.LFE62-.LFB62
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x8f6
-	.uleb128 0x19
-	.long	.LASF134
-	.byte	0x2
-	.byte	0x34
-	.byte	0x19
-	.long	0x8f6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -132
-	.uleb128 0x19
-	.long	.LASF135
-	.byte	0x2
-	.byte	0x34
-	.byte	0x38
-	.long	0x8fd
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -144
-	.uleb128 0x19
-	.long	.LASF136
-	.byte	0x2
-	.byte	0x34
-	.byte	0x50
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -136
-	.uleb128 0x19
-	.long	.LASF137
-	.byte	0x2
-	.byte	0x34
-	.byte	0x6b
-	.long	0x324
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -152
-	.uleb128 0x19
-	.long	.LASF138
-	.byte	0x2
-	.byte	0x34
-	.byte	0x80
-	.long	0x383
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -160
-	.uleb128 0x19
-	.long	.LASF139
-	.byte	0x2
-	.byte	0x34
-	.byte	0xa2
-	.long	0x383
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -168
-	.uleb128 0x1a
-	.long	.LASF187
-	.long	0x913
-	.uleb128 0x9
-	.byte	0x3
-	.quad	__PRETTY_FUNCTION__.4825
-	.uleb128 0x1b
-	.quad	.LBB9
-	.quad	.LBE9-.LBB9
-	.uleb128 0x1c
-	.long	.LASF140
-	.byte	0x2
-	.byte	0x6d
-	.byte	0x9
-	.long	0xd8
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x1c
-	.long	.LASF141
-	.byte	0x2
-	.byte	0x6e
-	.byte	0xa
-	.long	0x2d
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x1c
-	.long	.LASF142
-	.byte	0x2
-	.byte	0x72
-	.byte	0xd
-	.long	0x3cd
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x1d
-	.string	"d"
-	.byte	0x2
-	.byte	0x97
-	.byte	0xd
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x1d
-	.string	"rs"
-	.byte	0x2
-	.byte	0x98
-	.byte	0xd
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x1d
-	.string	"r"
-	.byte	0x2
-	.byte	0x9a
-	.byte	0x13
-	.long	0x918
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -72
-	.uleb128 0x1d
-	.string	"fs"
-	.byte	0x2
-	.byte	0x9b
-	.byte	0xd
-	.long	0x757
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.uleb128 0x1d
-	.string	"f"
-	.byte	0x2
-	.byte	0xaa
-	.byte	0x9
-	.long	0x47
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.uleb128 0x1c
-	.long	.LASF143
-	.byte	0x2
-	.byte	0xac
-	.byte	0x9
-	.long	0x47
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -96
-	.uleb128 0x1d
-	.string	"ret"
-	.byte	0x2
-	.byte	0xad
-	.byte	0x7
-	.long	0x82
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -100
-	.uleb128 0x1c
-	.long	.LASF144
-	.byte	0x2
-	.byte	0xaf
-	.byte	0x8
-	.long	0x91e
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -112
-	.uleb128 0x1c
-	.long	.LASF145
-	.byte	0x2
-	.byte	0xb1
-	.byte	0xd
-	.long	0x383
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -120
-	.uleb128 0x1e
-	.quad	.LBB10
-	.quad	.LBE10-.LBB10
-	.long	0x8d5
-	.uleb128 0x1d
-	.string	"i"
-	.byte	0x2
-	.byte	0x73
-	.byte	0xc
-	.long	0x82
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -44
-	.byte	0
-	.uleb128 0x1b
-	.quad	.LBB11
-	.quad	.LBE11-.LBB11
-	.uleb128 0x1d
-	.string	"i"
-	.byte	0x2
-	.byte	0x7c
-	.byte	0xc
-	.long	0x82
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x2
-	.long	.LASF146
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x4d8
-	.uleb128 0xc
-	.long	0xe5
-	.long	0x913
-	.uleb128 0xd
-	.long	0x39
-	.byte	0xc
-	.byte	0
-	.uleb128 0x5
-	.long	0x903
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x675
-	.uleb128 0xc
-	.long	0xde
-	.long	0x92e
-	.uleb128 0xd
-	.long	0x39
-	.byte	0xb
-	.byte	0
-	.uleb128 0x1f
-	.long	.LASF203
-	.byte	0x2
-	.byte	0x31
-	.byte	0x6
-	.quad	.LFB61
-	.quad	.LFE61-.LFB61
-	.uleb128 0x1
-	.byte	0x9c
-	.uleb128 0x20
-	.long	.LASF155
-	.byte	0x1
-	.value	0x417
-	.byte	0xb
-	.long	0x757
-	.quad	.LFB53
-	.quad	.LFE53-.LFB53
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xa0e
-	.uleb128 0x21
-	.string	"d"
-	.byte	0x1
-	.value	0x417
-	.byte	0x2b
-	.long	0x5f1
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.uleb128 0x22
-	.long	.LASF147
-	.byte	0x1
-	.value	0x417
-	.byte	0x38
-	.long	0x383
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -96
-	.uleb128 0x21
-	.string	"sym"
-	.byte	0x1
-	.value	0x417
-	.byte	0x4f
-	.long	0x324
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -104
-	.uleb128 0x23
-	.long	.LASF148
-	.byte	0x1
-	.value	0x419
-	.byte	0xd
-	.long	0xa0e
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x23
-	.long	.LASF149
-	.byte	0x1
-	.value	0x41a
-	.byte	0xd
-	.long	0xa0e
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x23
-	.long	.LASF150
-	.byte	0x1
-	.value	0x41b
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x23
-	.long	.LASF151
-	.byte	0x1
-	.value	0x41d
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x23
-	.long	.LASF152
-	.byte	0x1
-	.value	0x41e
-	.byte	0x11
-	.long	0xa14
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x23
-	.long	.LASF153
-	.byte	0x1
-	.value	0x41f
-	.byte	0x11
-	.long	0xa14
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -72
-	.uleb128 0x23
-	.long	.LASF154
-	.byte	0x1
-	.value	0x423
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x39d
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x49
-	.uleb128 0x20
-	.long	.LASF156
-	.byte	0x1
-	.value	0x3e4
-	.byte	0xb
-	.long	0x757
-	.quad	.LFB49
-	.quad	.LFE49-.LFB49
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xae5
-	.uleb128 0x22
-	.long	.LASF150
-	.byte	0x1
-	.value	0x3e4
-	.byte	0x2b
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x22
-	.long	.LASF151
-	.byte	0x1
-	.value	0x3e4
-	.byte	0x3e
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x22
-	.long	.LASF152
-	.byte	0x1
-	.value	0x3e5
-	.byte	0x17
-	.long	0xae5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -72
-	.uleb128 0x22
-	.long	.LASF153
-	.byte	0x1
-	.value	0x3e5
-	.byte	0x34
-	.long	0xae5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.uleb128 0x21
-	.string	"sym"
-	.byte	0x1
-	.value	0x3e5
-	.byte	0x4c
-	.long	0x324
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.uleb128 0x23
-	.long	.LASF157
-	.byte	0x1
-	.value	0x3e7
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x1b
-	.quad	.LBB7
-	.quad	.LBE7-.LBB7
-	.uleb128 0x23
-	.long	.LASF158
-	.byte	0x1
-	.value	0x3e8
-	.byte	0x11
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x1b
-	.quad	.LBB8
-	.quad	.LBE8-.LBB8
-	.uleb128 0x23
-	.long	.LASF159
-	.byte	0x1
-	.value	0x3ea
-	.byte	0xb
-	.long	0x2d2
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x50
-	.uleb128 0x20
-	.long	.LASF160
-	.byte	0x1
-	.value	0x337
-	.byte	0xb
-	.long	0x757
-	.quad	.LFB45
-	.quad	.LFE45-.LFB45
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xc6d
-	.uleb128 0x22
-	.long	.LASF149
-	.byte	0x1
-	.value	0x337
-	.byte	0x27
-	.long	0xa0e
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -120
-	.uleb128 0x22
-	.long	.LASF150
-	.byte	0x1
-	.value	0x337
-	.byte	0x3c
-	.long	0x757
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -128
-	.uleb128 0x22
-	.long	.LASF152
-	.byte	0x1
-	.value	0x337
-	.byte	0x59
-	.long	0xae5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -136
-	.uleb128 0x21
-	.string	"sym"
-	.byte	0x1
-	.value	0x337
-	.byte	0x6d
-	.long	0x324
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -144
-	.uleb128 0x23
-	.long	.LASF157
-	.byte	0x1
-	.value	0x339
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x23
-	.long	.LASF161
-	.byte	0x1
-	.value	0x33a
-	.byte	0xb
-	.long	0x35f
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x23
-	.long	.LASF162
-	.byte	0x1
-	.value	0x33c
-	.byte	0xc
-	.long	0xc6d
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x23
-	.long	.LASF163
-	.byte	0x1
-	.value	0x33d
-	.byte	0xb
-	.long	0x35f
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -44
-	.uleb128 0x23
-	.long	.LASF164
-	.byte	0x1
-	.value	0x33e
-	.byte	0xb
-	.long	0x35f
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x23
-	.long	.LASF165
-	.byte	0x1
-	.value	0x33f
-	.byte	0xb
-	.long	0x35f
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -52
-	.uleb128 0x23
-	.long	.LASF166
-	.byte	0x1
-	.value	0x340
-	.byte	0xb
-	.long	0x35f
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x23
-	.long	.LASF167
-	.byte	0x1
-	.value	0x342
-	.byte	0xc
-	.long	0xc73
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x23
-	.long	.LASF168
-	.byte	0x1
-	.value	0x343
-	.byte	0xc
-	.long	0xc6d
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -72
-	.uleb128 0x23
-	.long	.LASF169
-	.byte	0x1
-	.value	0x344
-	.byte	0xc
-	.long	0xc6d
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.uleb128 0x23
-	.long	.LASF170
-	.byte	0x1
-	.value	0x36e
-	.byte	0xb
-	.long	0x3d9
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.uleb128 0x23
-	.long	.LASF171
-	.byte	0x1
-	.value	0x372
-	.byte	0xf
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -92
-	.uleb128 0x23
-	.long	.LASF172
-	.byte	0x1
-	.value	0x373
-	.byte	0xf
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -96
-	.uleb128 0x1b
-	.quad	.LBB5
-	.quad	.LBE5-.LBB5
-	.uleb128 0x23
-	.long	.LASF173
-	.byte	0x1
-	.value	0x38e
-	.byte	0xc
-	.long	0x35f
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -100
-	.uleb128 0x1b
-	.quad	.LBB6
-	.quad	.LBE6-.LBB6
-	.uleb128 0x23
-	.long	.LASF174
-	.byte	0x1
-	.value	0x38f
-	.byte	0x11
-	.long	0x35f
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -28
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x35f
-	.uleb128 0x7
-	.byte	0x8
-	.long	0x3d9
-	.uleb128 0x24
-	.long	.LASF175
-	.byte	0x1
-	.value	0x32c
-	.byte	0x1
-	.long	0x377
-	.quad	.LFB44
-	.quad	.LFE44-.LFB44
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xcd9
-	.uleb128 0x21
-	.string	"s"
-	.byte	0x1
-	.value	0x32c
-	.byte	0x19
-	.long	0x324
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x25
-	.string	"h"
-	.byte	0x1
-	.value	0x32e
-	.byte	0x10
-	.long	0x377
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x1b
-	.quad	.LBB4
-	.quad	.LBE4-.LBB4
-	.uleb128 0x25
-	.string	"c"
-	.byte	0x1
-	.value	0x32f
-	.byte	0x15
-	.long	0x49
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -25
-	.byte	0
-	.byte	0
-	.uleb128 0x20
-	.long	.LASF176
-	.byte	0x1
-	.value	0x2fb
-	.byte	0xb
-	.long	0x757
-	.quad	.LFB42
-	.quad	.LFE42-.LFB42
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xde3
-	.uleb128 0x22
-	.long	.LASF148
-	.byte	0x1
-	.value	0x2fb
-	.byte	0x23
-	.long	0xa0e
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.uleb128 0x22
-	.long	.LASF150
-	.byte	0x1
-	.value	0x2fb
-	.byte	0x34
-	.long	0x757
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -96
-	.uleb128 0x22
-	.long	.LASF152
-	.byte	0x1
-	.value	0x2fb
-	.byte	0x51
-	.long	0xae5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -104
-	.uleb128 0x21
-	.string	"sym"
-	.byte	0x1
-	.value	0x2fb
-	.byte	0x65
-	.long	0x324
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -112
-	.uleb128 0x23
-	.long	.LASF157
-	.byte	0x1
-	.value	0x2fd
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x23
-	.long	.LASF177
-	.byte	0x1
-	.value	0x2fe
-	.byte	0xc
-	.long	0x39d
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x23
-	.long	.LASF178
-	.byte	0x1
-	.value	0x2ff
-	.byte	0xc
-	.long	0x39d
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -36
-	.uleb128 0x23
-	.long	.LASF168
-	.byte	0x1
-	.value	0x301
-	.byte	0xe
-	.long	0xdee
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x23
-	.long	.LASF179
-	.byte	0x1
-	.value	0x302
-	.byte	0xe
-	.long	0xdee
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x25
-	.string	"h"
-	.byte	0x1
-	.value	0x304
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x23
-	.long	.LASF180
-	.byte	0x1
-	.value	0x305
-	.byte	0xc
-	.long	0x39d
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -68
-	.uleb128 0x23
-	.long	.LASF181
-	.byte	0x1
-	.value	0x306
-	.byte	0xc
-	.long	0x39d
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -28
-	.uleb128 0x1b
-	.quad	.LBB3
-	.quad	.LBE3-.LBB3
-	.uleb128 0x23
-	.long	.LASF158
-	.byte	0x1
-	.value	0x309
-	.byte	0xd
-	.long	0x757
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.long	0x39d
-	.long	0xdee
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0x7
-	.byte	0x8
-	.long	0xde3
-	.uleb128 0x20
-	.long	.LASF182
-	.byte	0x1
-	.value	0x2ec
-	.byte	0xf
-	.long	0x39
-	.quad	.LFB40
-	.quad	.LFE40-.LFB40
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xe68
-	.uleb128 0x21
-	.string	"dyn"
-	.byte	0x1
-	.value	0x2ec
-	.byte	0x37
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x22
-	.long	.LASF147
-	.byte	0x1
-	.value	0x2ec
-	.byte	0x46
-	.long	0x383
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x23
-	.long	.LASF148
-	.byte	0x1
-	.value	0x2ee
-	.byte	0xd
-	.long	0xa0e
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x23
-	.long	.LASF183
-	.byte	0x1
-	.value	0x2f0
-	.byte	0xc
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x23
-	.long	.LASF184
-	.byte	0x1
-	.value	0x2f1
-	.byte	0x11
-	.long	0xa14
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.byte	0
-	.uleb128 0x20
-	.long	.LASF185
-	.byte	0x1
-	.value	0x2e1
-	.byte	0xf
-	.long	0x39
-	.quad	.LFB39
-	.quad	.LFE39-.LFB39
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xecf
-	.uleb128 0x22
-	.long	.LASF183
-	.byte	0x1
-	.value	0x2e1
-	.byte	0x33
-	.long	0x757
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x22
-	.long	.LASF184
-	.byte	0x1
-	.value	0x2e1
-	.byte	0x4a
-	.long	0xa14
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x22
-	.long	.LASF186
-	.byte	0x1
-	.value	0x2e1
-	.byte	0x5e
-	.long	0xa0e
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x1a
-	.long	.LASF187
-	.long	0xedf
-	.uleb128 0x9
-	.byte	0x3
-	.quad	__PRETTY_FUNCTION__.4547
-	.byte	0
-	.uleb128 0xc
-	.long	0xe5
-	.long	0xedf
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x19
-	.byte	0
-	.uleb128 0x5
-	.long	0xecf
-	.uleb128 0x20
-	.long	.LASF188
-	.byte	0x1
-	.value	0x2d5
-	.byte	0x10
-	.long	0xa14
-	.quad	.LFB37
-	.quad	.LFE37-.LFB37
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xf36
-	.uleb128 0x21
-	.string	"d"
-	.byte	0x1
-	.value	0x2d5
-	.byte	0x2e
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x22
-	.long	.LASF147
-	.byte	0x1
-	.value	0x2d5
-	.byte	0x3b
-	.long	0x383
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x23
-	.long	.LASF152
-	.byte	0x1
-	.value	0x2d7
-	.byte	0x11
-	.long	0xa14
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.uleb128 0x20
-	.long	.LASF189
-	.byte	0x1
-	.value	0x2c9
-	.byte	0xc
-	.long	0xa0e
-	.quad	.LFB35
-	.quad	.LFE35-.LFB35
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xf98
-	.uleb128 0x21
-	.string	"d"
-	.byte	0x1
-	.value	0x2c9
-	.byte	0x2e
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x22
-	.long	.LASF147
-	.byte	0x1
-	.value	0x2c9
-	.byte	0x3b
-	.long	0x383
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x23
-	.long	.LASF190
-	.byte	0x1
-	.value	0x2cb
-	.byte	0xc
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x23
-	.long	.LASF148
-	.byte	0x1
-	.value	0x2cc
-	.byte	0xd
-	.long	0xa0e
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.byte	0
-	.uleb128 0x20
-	.long	.LASF191
-	.byte	0x1
-	.value	0x2bd
-	.byte	0xc
-	.long	0xa0e
-	.quad	.LFB33
-	.quad	.LFE33-.LFB33
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xffa
-	.uleb128 0x21
-	.string	"d"
-	.byte	0x1
-	.value	0x2bd
-	.byte	0x2d
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x22
-	.long	.LASF147
-	.byte	0x1
-	.value	0x2bd
-	.byte	0x3a
-	.long	0x383
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x23
-	.long	.LASF192
-	.byte	0x1
-	.value	0x2bf
-	.byte	0xc
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x23
-	.long	.LASF149
-	.byte	0x1
-	.value	0x2c0
-	.byte	0xd
-	.long	0xa0e
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.byte	0
-	.uleb128 0x20
-	.long	.LASF193
-	.byte	0x1
-	.value	0x2b2
-	.byte	0xb
-	.long	0x757
-	.quad	.LFB31
-	.quad	.LFE31-.LFB31
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x104a
-	.uleb128 0x21
-	.string	"d"
-	.byte	0x1
-	.value	0x2b2
-	.byte	0x2a
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x22
-	.long	.LASF147
-	.byte	0x1
-	.value	0x2b2
-	.byte	0x37
-	.long	0x383
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x25
-	.string	"a"
-	.byte	0x1
-	.value	0x2b4
-	.byte	0xc
-	.long	0x3cd
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.uleb128 0x24
-	.long	.LASF194
-	.byte	0x1
-	.value	0x1e9
-	.byte	0x1
-	.long	0x39
-	.quad	.LFB20
-	.quad	.LFE20-.LFB20
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x109a
-	.uleb128 0x22
-	.long	.LASF195
-	.byte	0x1
-	.value	0x1e9
-	.byte	0x21
-	.long	0xae5
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x25
-	.string	"h"
-	.byte	0x1
-	.value	0x1eb
-	.byte	0xb
-	.long	0x36b
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x25
-	.string	"g"
-	.byte	0x1
-	.value	0x1eb
-	.byte	0x12
-	.long	0x36b
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.byte	0
-	.uleb128 0x20
-	.long	.LASF196
-	.byte	0x1
-	.value	0x1da
-	.byte	0xb
-	.long	0x5f1
-	.quad	.LFB18
-	.quad	.LFE18-.LFB18
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x1101
-	.uleb128 0x21
-	.string	"dyn"
-	.byte	0x1
-	.value	0x1da
-	.byte	0x26
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x21
-	.string	"tag"
-	.byte	0x1
-	.value	0x1da
-	.byte	0x37
-	.long	0x3a9
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -44
-	.uleb128 0x23
-	.long	.LASF154
-	.byte	0x1
-	.value	0x1dc
-	.byte	0xc
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x1a
-	.long	.LASF197
-	.long	0x1111
-	.uleb128 0x9
-	.byte	0x3
-	.quad	__func__.4434
-	.byte	0
-	.uleb128 0xc
-	.long	0xe5
-	.long	0x1111
-	.uleb128 0xd
-	.long	0x39
-	.byte	0xf
-	.byte	0
-	.uleb128 0x5
-	.long	0x1101
-	.uleb128 0x26
-	.long	.LASF204
-	.byte	0x1
-	.value	0x1cd
-	.byte	0xb
-	.long	0x5f1
-	.quad	.LFB17
-	.quad	.LFE17-.LFB17
-	.uleb128 0x1
-	.byte	0x9c
-	.uleb128 0x21
-	.string	"d"
-	.byte	0x1
-	.value	0x1cd
-	.byte	0x25
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x21
-	.string	"tag"
-	.byte	0x1
-	.value	0x1cd
-	.byte	0x34
-	.long	0x3a9
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -44
-	.uleb128 0x1b
-	.quad	.LBB2
-	.quad	.LBE2-.LBB2
-	.uleb128 0x25
-	.string	"dyn"
-	.byte	0x1
-	.value	0x1cf
-	.byte	0x11
-	.long	0x5f1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_abbrev,"",@progbits
-.Ldebug_abbrev0:
-	.uleb128 0x1
-	.uleb128 0x11
-	.byte	0x1
-	.uleb128 0x25
-	.uleb128 0xe
-	.uleb128 0x13
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1b
-	.uleb128 0xe
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x10
-	.uleb128 0x17
-	.byte	0
-	.byte	0
-	.uleb128 0x2
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.byte	0
-	.byte	0
-	.uleb128 0x4
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x5
-	.uleb128 0x26
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0x8
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x8
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x9
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xa
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0x13
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.uleb128 0x1
-	.byte	0x1
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xd
-	.uleb128 0x21
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2f
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xe
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xf
-	.uleb128 0x21
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x10
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x11
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x12
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x13
-	.uleb128 0x17
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x14
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x15
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x16
-	.uleb128 0x4
-	.byte	0x1
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x17
-	.uleb128 0x28
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1c
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x18
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x19
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1a
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x34
-	.uleb128 0x19
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1b
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.byte	0
-	.byte	0
-	.uleb128 0x1c
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1d
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1e
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x1f
-	.uleb128 0x2e
-	.byte	0
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2117
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x20
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x21
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x22
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x23
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x24
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2117
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x25
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x26
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2117
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_aranges,"",@progbits
-	.long	0x2c
-	.value	0x2
-	.long	.Ldebug_info0
-	.byte	0x8
-	.byte	0
-	.value	0
-	.value	0
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.quad	0
-	.quad	0
-	.section	.debug_line,"",@progbits
-.Ldebug_line0:
-	.section	.debug_str,"MS",@progbits,1
-.LASF5:
-	.string	"short int"
-.LASF18:
-	.string	"_IO_read_ptr"
-.LASF30:
-	.string	"_chain"
-.LASF156:
-	.string	"symbol_lookup_linear"
-.LASF82:
-	.string	"p_vaddr"
-.LASF75:
-	.string	"st_shndx"
-.LASF6:
-	.string	"size_t"
-.LASF62:
-	.string	"uintptr_t"
-.LASF150:
-	.string	"symtab"
-.LASF138:
-	.string	"inferior_dynamic_vaddr"
-.LASF114:
-	.string	"RT_ADD"
-.LASF36:
-	.string	"_shortbuf"
-.LASF135:
-	.string	"program_phdrs"
-.LASF70:
-	.string	"Elf64_Off"
-.LASF143:
-	.string	"page_addr"
-.LASF178:
-	.string	"nchain"
-.LASF50:
-	.string	"ssize_t"
-.LASF91:
-	.string	"d_un"
-.LASF20:
-	.string	"_IO_read_base"
-.LASF193:
-	.string	"get_dynsym_from_dyn"
-.LASF24:
-	.string	"_IO_buf_base"
-.LASF89:
-	.string	"d_ptr"
-.LASF164:
-	.string	"symbias"
-.LASF64:
-	.string	"long long unsigned int"
-.LASF86:
-	.string	"p_align"
-.LASF196:
-	.string	"dynamic_xlookup"
-.LASF190:
-	.string	"hash_ent"
-.LASF115:
-	.string	"RT_DELETE"
-.LASF162:
-	.string	"gnu_hash_words"
-.LASF61:
-	.string	"uint_fast32_t"
-.LASF39:
-	.string	"_codecvt"
-.LASF203:
-	.string	"_dl_debug_state"
-.LASF10:
-	.string	"__int64_t"
-.LASF125:
-	.string	"l_name"
-.LASF63:
-	.string	"long long int"
-.LASF4:
-	.string	"signed char"
-.LASF187:
-	.string	"__PRETTY_FUNCTION__"
-.LASF84:
-	.string	"p_filesz"
-.LASF31:
-	.string	"_fileno"
-.LASF19:
-	.string	"_IO_read_end"
-.LASF168:
-	.string	"buckets"
-.LASF11:
-	.string	"long int"
-.LASF17:
-	.string	"_flags"
-.LASF15:
-	.string	"__ssize_t"
-.LASF133:
-	.string	"_etext"
-.LASF25:
-	.string	"_IO_buf_end"
-.LASF34:
-	.string	"_cur_column"
-.LASF119:
-	.string	"r_map"
-.LASF48:
-	.string	"_IO_codecvt"
-.LASF105:
-	.string	"p_auxv"
-.LASF95:
-	.string	"a_un"
-.LASF110:
-	.string	"double"
-.LASF76:
-	.string	"st_value"
-.LASF33:
-	.string	"_old_offset"
-.LASF38:
-	.string	"_offset"
-.LASF71:
-	.string	"Elf64_Section"
-.LASF83:
-	.string	"p_paddr"
-.LASF65:
-	.string	"Elf64_Word"
-.LASF144:
-	.string	"bytes"
-.LASF81:
-	.string	"p_offset"
-.LASF191:
-	.string	"get_gnu_hash_from_dyn"
-.LASF9:
-	.string	"__uint32_t"
-.LASF179:
-	.string	"chains"
-.LASF194:
-	.string	"elf64_hash"
-.LASF85:
-	.string	"p_memsz"
-.LASF184:
-	.string	"dynstr"
-.LASF160:
-	.string	"gnu_hash_lookup"
-.LASF47:
-	.string	"_IO_marker"
-.LASF51:
-	.string	"stdin"
-.LASF1:
-	.string	"unsigned int"
-.LASF79:
-	.string	"p_type"
-.LASF111:
-	.string	"__int128"
-.LASF152:
-	.string	"strtab"
-.LASF0:
-	.string	"long unsigned int"
-.LASF182:
-	.string	"dynamic_symbol_count_from_dyn"
-.LASF22:
-	.string	"_IO_write_ptr"
-.LASF195:
-	.string	"name"
-.LASF54:
-	.string	"sys_nerr"
-.LASF163:
-	.string	"nbuckets"
-.LASF3:
-	.string	"short unsigned int"
-.LASF74:
-	.string	"st_other"
-.LASF26:
-	.string	"_IO_save_base"
-.LASF198:
-	.string	"GNU C99 8.3.0 -mtune=generic -march=x86-64 -g -std=gnu99 -fPIC -fno-stack-protector"
-.LASF103:
-	.string	"environ"
-.LASF58:
-	.string	"uint16_t"
-.LASF177:
-	.string	"nbucket"
-.LASF113:
-	.string	"RT_CONSISTENT"
-.LASF37:
-	.string	"_lock"
-.LASF120:
-	.string	"r_brk"
-.LASF104:
-	.string	"p_dyn"
-.LASF140:
-	.string	"interp_addr"
-.LASF202:
-	.string	"cover_tracks"
-.LASF8:
-	.string	"__int32_t"
-.LASF52:
-	.string	"stdout"
-.LASF174:
-	.string	"symidx"
-.LASF77:
-	.string	"st_size"
-.LASF170:
-	.string	"bloom_word"
-.LASF165:
-	.string	"maskwords"
-.LASF40:
-	.string	"_wide_data"
-.LASF155:
-	.string	"symbol_lookup_in_dyn"
-.LASF88:
-	.string	"d_val"
-.LASF87:
-	.string	"Elf64_Phdr"
-.LASF151:
-	.string	"symtab_end"
-.LASF98:
-	.string	"optarg"
-.LASF99:
-	.string	"optind"
-.LASF204:
-	.string	"dynamic_lookup"
-.LASF142:
-	.string	"program_base_addr"
-.LASF188:
-	.string	"get_dynstr_from_dyn"
-.LASF153:
-	.string	"strtab_end"
-.LASF60:
-	.string	"uint64_t"
-.LASF68:
-	.string	"Elf64_Sxword"
-.LASF108:
-	.string	"_DYNAMIC"
-.LASF201:
-	.string	"_IO_lock_t"
-.LASF116:
-	.string	"_IO_FILE"
-.LASF172:
-	.string	"hash2_bitoff"
-.LASF13:
-	.string	"__off_t"
-.LASF97:
-	.string	"__environ"
-.LASF145:
-	.string	"address_8bytes"
-.LASF12:
-	.string	"__uint64_t"
-.LASF44:
-	.string	"_mode"
-.LASF109:
-	.string	"float"
-.LASF93:
-	.string	"a_val"
-.LASF106:
-	.string	"page_size"
-.LASF55:
-	.string	"sys_errlist"
-.LASF29:
-	.string	"_markers"
-.LASF136:
-	.string	"program_phnum"
-.LASF130:
-	.string	"_fini"
-.LASF102:
-	.string	"_begin"
-.LASF146:
-	.string	"_Bool"
-.LASF56:
-	.string	"int32_t"
-.LASF2:
-	.string	"unsigned char"
-.LASF107:
-	.string	"sp_on_entry"
-.LASF32:
-	.string	"_flags2"
-.LASF45:
-	.string	"_unused2"
-.LASF80:
-	.string	"p_flags"
-.LASF197:
-	.string	"__func__"
-.LASF118:
-	.string	"r_version"
-.LASF121:
-	.string	"r_state"
-.LASF46:
-	.string	"FILE"
-.LASF149:
-	.string	"gnu_hash"
-.LASF129:
-	.string	"_r_debug"
-.LASF166:
-	.string	"shift2"
-.LASF101:
-	.string	"optopt"
-.LASF158:
-	.string	"p_sym"
-.LASF59:
-	.string	"uint32_t"
-.LASF181:
-	.string	"symind"
-.LASF72:
-	.string	"st_name"
-.LASF112:
-	.string	"long double"
-.LASF131:
-	.string	"_init"
-.LASF66:
-	.string	"Elf64_Sword"
-.LASF16:
-	.string	"char"
-.LASF7:
-	.string	"__uint16_t"
-.LASF200:
-	.string	"/usr/local/src/liballocs/allocsld"
-.LASF192:
-	.string	"gnu_hash_ent"
-.LASF159:
-	.string	"distance_to_strtab_end"
-.LASF100:
-	.string	"opterr"
-.LASF199:
-	.string	"chain.c"
-.LASF176:
-	.string	"hash_lookup"
-.LASF14:
-	.string	"__off64_t"
-.LASF126:
-	.string	"l_ld"
-.LASF185:
-	.string	"dynamic_symbol_count_fast"
-.LASF28:
-	.string	"_IO_save_end"
-.LASF148:
-	.string	"hash"
-.LASF128:
-	.string	"l_prev"
-.LASF161:
-	.string	"hashval"
-.LASF175:
-	.string	"dl_new_hash"
-.LASF90:
-	.string	"d_tag"
-.LASF78:
-	.string	"Elf64_Sym"
-.LASF157:
-	.string	"found_sym"
-.LASF43:
-	.string	"__pad5"
-.LASF23:
-	.string	"_IO_write_end"
-.LASF154:
-	.string	"found"
-.LASF69:
-	.string	"Elf64_Addr"
-.LASF53:
-	.string	"stderr"
-.LASF134:
-	.string	"we_are_the_program"
-.LASF171:
-	.string	"hash1_bitoff"
-.LASF124:
-	.string	"l_addr"
-.LASF117:
-	.string	"r_debug"
-.LASF173:
-	.string	"lowest_symidx"
-.LASF169:
-	.string	"hasharr"
-.LASF92:
-	.string	"Elf64_Dyn"
-.LASF137:
-	.string	"ldso_path"
-.LASF42:
-	.string	"_freeres_buf"
-.LASF127:
-	.string	"l_next"
-.LASF96:
-	.string	"Elf64_auxv_t"
-.LASF67:
-	.string	"Elf64_Xword"
-.LASF27:
-	.string	"_IO_backup_base"
-.LASF189:
-	.string	"get_sysv_hash_from_dyn"
-.LASF167:
-	.string	"bloom"
-.LASF122:
-	.string	"r_ldbase"
-.LASF73:
-	.string	"st_info"
-.LASF35:
-	.string	"_vtable_offset"
-.LASF186:
-	.string	"sysv_hash"
-.LASF139:
-	.string	"base_addr"
-.LASF41:
-	.string	"_freeres_list"
-.LASF123:
-	.string	"link_map"
-.LASF183:
-	.string	"dynsym"
-.LASF49:
-	.string	"_IO_wide_data"
-.LASF57:
-	.string	"int64_t"
-.LASF141:
-	.string	"interp_sz"
-.LASF180:
-	.string	"first_symind"
-.LASF21:
-	.string	"_IO_write_base"
-.LASF132:
-	.string	"__libc_stack_end"
-.LASF147:
-	.string	"load_addr"
-.LASF94:
-	.string	"a_type"
-	.hidden	page_size
-	.ident	"GCC: (Debian 8.3.0-6) 8.3.0"
-	.section	.note.GNU-stack,"",@progbits
diff --git a/allocsld/entry.s b/allocsld/entry.s
deleted file mode 100644
index 36281c6..0000000
--- a/allocsld/entry.s
+++ /dev/null
@@ -1,1180 +0,0 @@
-	.file	"entry.c"
-	.text
-.Ltext0:
-	.section	.rodata
-	.align 8
-.LC0:
-	.string	"allocsld: jumping to system ld.so entry point %p with rsp %p\n"
-	.text
-	.globl	enter
-	.hidden	enter
-	.type	enter, @function
-enter:
-.LFB0:
-	.file 1 "/usr/local/src/liballocs/contrib/donald/src/entry.c"
-	.loc 1 5 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$16, %rsp
-	movq	%rdi, -8(%rbp)
-	.loc 1 6 2
-	movq	sp_on_entry(%rip), %rcx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-8(%rbp), %rdx
-	leaq	.LC0(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 8 2
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	%rax, %rdi
-	call	fflush@PLT
-	.loc 1 9 2
-	movq	-8(%rbp), %rax
-#APP
-# 9 "/usr/local/src/liballocs/contrib/donald/src/entry.c" 1
-	movq sp_on_entry(%rip), %rsp
-xorq %rbp, %rbp
-jmp *%rax
-
-# 0 "" 2
-#NO_APP
-	.cfi_endproc
-.LFE0:
-	.size	enter, .-enter
-.Letext0:
-	.file 2 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
-	.file 3 "/usr/include/x86_64-linux-gnu/bits/types.h"
-	.file 4 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
-	.file 5 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
-	.file 6 "/usr/include/stdio.h"
-	.file 7 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
-	.file 8 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
-	.file 9 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
-	.file 10 "/usr/include/elf.h"
-	.file 11 "/usr/include/unistd.h"
-	.file 12 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
-	.file 13 "/usr/local/src/liballocs/contrib/donald/src/donald.h"
-	.section	.debug_info,"",@progbits
-.Ldebug_info0:
-	.long	0x4b0
-	.value	0x4
-	.long	.Ldebug_abbrev0
-	.byte	0x8
-	.uleb128 0x1
-	.long	.LASF77
-	.byte	0xc
-	.long	.LASF78
-	.long	.LASF79
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.long	.Ldebug_line0
-	.uleb128 0x2
-	.long	.LASF6
-	.byte	0x2
-	.byte	0xd8
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF0
-	.uleb128 0x3
-	.byte	0x4
-	.byte	0x7
-	.long	.LASF1
-	.uleb128 0x4
-	.byte	0x8
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x8
-	.long	.LASF2
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x7
-	.long	.LASF3
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF4
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x5
-	.long	.LASF5
-	.uleb128 0x5
-	.byte	0x4
-	.byte	0x5
-	.string	"int"
-	.uleb128 0x2
-	.long	.LASF7
-	.byte	0x3
-	.byte	0x2b
-	.byte	0x19
-	.long	0x78
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF8
-	.uleb128 0x2
-	.long	.LASF9
-	.byte	0x3
-	.byte	0x2c
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF10
-	.byte	0x3
-	.byte	0x96
-	.byte	0x12
-	.long	0x78
-	.uleb128 0x2
-	.long	.LASF11
-	.byte	0x3
-	.byte	0x97
-	.byte	0x12
-	.long	0x78
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xa9
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF12
-	.uleb128 0x7
-	.long	0xa9
-	.uleb128 0x8
-	.long	.LASF80
-	.byte	0xd8
-	.byte	0x4
-	.byte	0x31
-	.byte	0x8
-	.long	0x23c
-	.uleb128 0x9
-	.long	.LASF13
-	.byte	0x4
-	.byte	0x33
-	.byte	0x7
-	.long	0x65
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF14
-	.byte	0x4
-	.byte	0x36
-	.byte	0x9
-	.long	0xa3
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF15
-	.byte	0x4
-	.byte	0x37
-	.byte	0x9
-	.long	0xa3
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF16
-	.byte	0x4
-	.byte	0x38
-	.byte	0x9
-	.long	0xa3
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF17
-	.byte	0x4
-	.byte	0x39
-	.byte	0x9
-	.long	0xa3
-	.byte	0x20
-	.uleb128 0x9
-	.long	.LASF18
-	.byte	0x4
-	.byte	0x3a
-	.byte	0x9
-	.long	0xa3
-	.byte	0x28
-	.uleb128 0x9
-	.long	.LASF19
-	.byte	0x4
-	.byte	0x3b
-	.byte	0x9
-	.long	0xa3
-	.byte	0x30
-	.uleb128 0x9
-	.long	.LASF20
-	.byte	0x4
-	.byte	0x3c
-	.byte	0x9
-	.long	0xa3
-	.byte	0x38
-	.uleb128 0x9
-	.long	.LASF21
-	.byte	0x4
-	.byte	0x3d
-	.byte	0x9
-	.long	0xa3
-	.byte	0x40
-	.uleb128 0x9
-	.long	.LASF22
-	.byte	0x4
-	.byte	0x40
-	.byte	0x9
-	.long	0xa3
-	.byte	0x48
-	.uleb128 0x9
-	.long	.LASF23
-	.byte	0x4
-	.byte	0x41
-	.byte	0x9
-	.long	0xa3
-	.byte	0x50
-	.uleb128 0x9
-	.long	.LASF24
-	.byte	0x4
-	.byte	0x42
-	.byte	0x9
-	.long	0xa3
-	.byte	0x58
-	.uleb128 0x9
-	.long	.LASF25
-	.byte	0x4
-	.byte	0x44
-	.byte	0x16
-	.long	0x255
-	.byte	0x60
-	.uleb128 0x9
-	.long	.LASF26
-	.byte	0x4
-	.byte	0x46
-	.byte	0x14
-	.long	0x25b
-	.byte	0x68
-	.uleb128 0x9
-	.long	.LASF27
-	.byte	0x4
-	.byte	0x48
-	.byte	0x7
-	.long	0x65
-	.byte	0x70
-	.uleb128 0x9
-	.long	.LASF28
-	.byte	0x4
-	.byte	0x49
-	.byte	0x7
-	.long	0x65
-	.byte	0x74
-	.uleb128 0x9
-	.long	.LASF29
-	.byte	0x4
-	.byte	0x4a
-	.byte	0xb
-	.long	0x8b
-	.byte	0x78
-	.uleb128 0x9
-	.long	.LASF30
-	.byte	0x4
-	.byte	0x4d
-	.byte	0x12
-	.long	0x50
-	.byte	0x80
-	.uleb128 0x9
-	.long	.LASF31
-	.byte	0x4
-	.byte	0x4e
-	.byte	0xf
-	.long	0x57
-	.byte	0x82
-	.uleb128 0x9
-	.long	.LASF32
-	.byte	0x4
-	.byte	0x4f
-	.byte	0x8
-	.long	0x261
-	.byte	0x83
-	.uleb128 0x9
-	.long	.LASF33
-	.byte	0x4
-	.byte	0x51
-	.byte	0xf
-	.long	0x271
-	.byte	0x88
-	.uleb128 0x9
-	.long	.LASF34
-	.byte	0x4
-	.byte	0x59
-	.byte	0xd
-	.long	0x97
-	.byte	0x90
-	.uleb128 0x9
-	.long	.LASF35
-	.byte	0x4
-	.byte	0x5b
-	.byte	0x17
-	.long	0x27c
-	.byte	0x98
-	.uleb128 0x9
-	.long	.LASF36
-	.byte	0x4
-	.byte	0x5c
-	.byte	0x19
-	.long	0x287
-	.byte	0xa0
-	.uleb128 0x9
-	.long	.LASF37
-	.byte	0x4
-	.byte	0x5d
-	.byte	0x14
-	.long	0x25b
-	.byte	0xa8
-	.uleb128 0x9
-	.long	.LASF38
-	.byte	0x4
-	.byte	0x5e
-	.byte	0x9
-	.long	0x47
-	.byte	0xb0
-	.uleb128 0x9
-	.long	.LASF39
-	.byte	0x4
-	.byte	0x5f
-	.byte	0xa
-	.long	0x2d
-	.byte	0xb8
-	.uleb128 0x9
-	.long	.LASF40
-	.byte	0x4
-	.byte	0x60
-	.byte	0x7
-	.long	0x65
-	.byte	0xc0
-	.uleb128 0x9
-	.long	.LASF41
-	.byte	0x4
-	.byte	0x62
-	.byte	0x8
-	.long	0x28d
-	.byte	0xc4
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF42
-	.byte	0x5
-	.byte	0x7
-	.byte	0x19
-	.long	0xb5
-	.uleb128 0xa
-	.long	.LASF81
-	.byte	0x4
-	.byte	0x2b
-	.byte	0xe
-	.uleb128 0xb
-	.long	.LASF43
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x250
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xb5
-	.uleb128 0xc
-	.long	0xa9
-	.long	0x271
-	.uleb128 0xd
-	.long	0x39
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x248
-	.uleb128 0xb
-	.long	.LASF44
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x277
-	.uleb128 0xb
-	.long	.LASF45
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x282
-	.uleb128 0xc
-	.long	0xa9
-	.long	0x29d
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x13
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF46
-	.byte	0x6
-	.byte	0x89
-	.byte	0xe
-	.long	0x2a9
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x23c
-	.uleb128 0xe
-	.long	.LASF47
-	.byte	0x6
-	.byte	0x8a
-	.byte	0xe
-	.long	0x2a9
-	.uleb128 0xe
-	.long	.LASF48
-	.byte	0x6
-	.byte	0x8b
-	.byte	0xe
-	.long	0x2a9
-	.uleb128 0xe
-	.long	.LASF49
-	.byte	0x7
-	.byte	0x1a
-	.byte	0xc
-	.long	0x65
-	.uleb128 0xc
-	.long	0x2e9
-	.long	0x2de
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0x7
-	.long	0x2d3
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xb0
-	.uleb128 0x7
-	.long	0x2e3
-	.uleb128 0xe
-	.long	.LASF50
-	.byte	0x7
-	.byte	0x1b
-	.byte	0x1a
-	.long	0x2de
-	.uleb128 0x2
-	.long	.LASF51
-	.byte	0x8
-	.byte	0x1b
-	.byte	0x13
-	.long	0x6c
-	.uleb128 0x2
-	.long	.LASF52
-	.byte	0x9
-	.byte	0x1b
-	.byte	0x14
-	.long	0x7f
-	.uleb128 0x2
-	.long	.LASF53
-	.byte	0xa
-	.byte	0x2b
-	.byte	0x12
-	.long	0x306
-	.uleb128 0x2
-	.long	.LASF54
-	.byte	0xa
-	.byte	0x2c
-	.byte	0x11
-	.long	0x2fa
-	.uleb128 0x2
-	.long	.LASF55
-	.byte	0xa
-	.byte	0x30
-	.byte	0x12
-	.long	0x306
-	.uleb128 0x10
-	.byte	0x8
-	.byte	0xa
-	.value	0x340
-	.byte	0x3
-	.long	0x35b
-	.uleb128 0x11
-	.long	.LASF56
-	.byte	0xa
-	.value	0x342
-	.byte	0x13
-	.long	0x312
-	.uleb128 0x11
-	.long	.LASF57
-	.byte	0xa
-	.value	0x343
-	.byte	0x12
-	.long	0x32a
-	.byte	0
-	.uleb128 0x12
-	.byte	0x10
-	.byte	0xa
-	.value	0x33d
-	.byte	0x9
-	.long	0x382
-	.uleb128 0x13
-	.long	.LASF58
-	.byte	0xa
-	.value	0x33f
-	.byte	0x10
-	.long	0x31e
-	.byte	0
-	.uleb128 0x13
-	.long	.LASF59
-	.byte	0xa
-	.value	0x344
-	.byte	0x7
-	.long	0x336
-	.byte	0x8
-	.byte	0
-	.uleb128 0x14
-	.long	.LASF60
-	.byte	0xa
-	.value	0x345
-	.byte	0x3
-	.long	0x35b
-	.uleb128 0x10
-	.byte	0x8
-	.byte	0xa
-	.value	0x470
-	.byte	0x3
-	.long	0x3a7
-	.uleb128 0x11
-	.long	.LASF61
-	.byte	0xa
-	.value	0x472
-	.byte	0x10
-	.long	0x306
-	.byte	0
-	.uleb128 0x12
-	.byte	0x10
-	.byte	0xa
-	.value	0x46d
-	.byte	0x9
-	.long	0x3ce
-	.uleb128 0x13
-	.long	.LASF62
-	.byte	0xa
-	.value	0x46f
-	.byte	0xc
-	.long	0x306
-	.byte	0
-	.uleb128 0x13
-	.long	.LASF63
-	.byte	0xa
-	.value	0x476
-	.byte	0x7
-	.long	0x38f
-	.byte	0x8
-	.byte	0
-	.uleb128 0x14
-	.long	.LASF64
-	.byte	0xa
-	.value	0x477
-	.byte	0x3
-	.long	0x3a7
-	.uleb128 0x15
-	.long	.LASF65
-	.byte	0xb
-	.value	0x21f
-	.byte	0xf
-	.long	0x3e8
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xa3
-	.uleb128 0xe
-	.long	.LASF66
-	.byte	0xc
-	.byte	0x24
-	.byte	0xe
-	.long	0xa3
-	.uleb128 0xe
-	.long	.LASF67
-	.byte	0xc
-	.byte	0x32
-	.byte	0xc
-	.long	0x65
-	.uleb128 0xe
-	.long	.LASF68
-	.byte	0xc
-	.byte	0x37
-	.byte	0xc
-	.long	0x65
-	.uleb128 0xe
-	.long	.LASF69
-	.byte	0xc
-	.byte	0x3b
-	.byte	0xc
-	.long	0x65
-	.uleb128 0xe
-	.long	.LASF70
-	.byte	0xd
-	.byte	0x32
-	.byte	0xc
-	.long	0x65
-	.uleb128 0xe
-	.long	.LASF71
-	.byte	0xd
-	.byte	0x33
-	.byte	0xf
-	.long	0x3e8
-	.uleb128 0xe
-	.long	.LASF72
-	.byte	0xd
-	.byte	0x34
-	.byte	0x13
-	.long	0x442
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x382
-	.uleb128 0xe
-	.long	.LASF73
-	.byte	0xd
-	.byte	0x35
-	.byte	0x16
-	.long	0x454
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x3ce
-	.uleb128 0xe
-	.long	.LASF74
-	.byte	0xd
-	.byte	0x36
-	.byte	0x16
-	.long	0x39
-	.uleb128 0xe
-	.long	.LASF75
-	.byte	0xd
-	.byte	0x37
-	.byte	0xe
-	.long	0x47
-	.uleb128 0xc
-	.long	0x382
-	.long	0x47d
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF76
-	.byte	0xd
-	.byte	0x38
-	.byte	0x12
-	.long	0x472
-	.uleb128 0x16
-	.long	.LASF82
-	.byte	0x1
-	.byte	0x4
-	.byte	0x20
-	.quad	.LFB0
-	.quad	.LFE0-.LFB0
-	.uleb128 0x1
-	.byte	0x9c
-	.uleb128 0x17
-	.long	.LASF83
-	.byte	0x1
-	.byte	0x4
-	.byte	0x2c
-	.long	0x47
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.byte	0
-	.section	.debug_abbrev,"",@progbits
-.Ldebug_abbrev0:
-	.uleb128 0x1
-	.uleb128 0x11
-	.byte	0x1
-	.uleb128 0x25
-	.uleb128 0xe
-	.uleb128 0x13
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1b
-	.uleb128 0xe
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x10
-	.uleb128 0x17
-	.byte	0
-	.byte	0
-	.uleb128 0x2
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.byte	0
-	.byte	0
-	.uleb128 0x4
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x5
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0x8
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.uleb128 0x26
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x8
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x9
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xa
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0x13
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.uleb128 0x1
-	.byte	0x1
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xd
-	.uleb128 0x21
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2f
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xe
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xf
-	.uleb128 0x21
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x10
-	.uleb128 0x17
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x11
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x12
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x13
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x14
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x15
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x16
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x87
-	.uleb128 0x19
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x17
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_aranges,"",@progbits
-	.long	0x2c
-	.value	0x2
-	.long	.Ldebug_info0
-	.byte	0x8
-	.byte	0
-	.value	0
-	.value	0
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.quad	0
-	.quad	0
-	.section	.debug_line,"",@progbits
-.Ldebug_line0:
-	.section	.debug_str,"MS",@progbits,1
-.LASF67:
-	.string	"optind"
-.LASF66:
-	.string	"optarg"
-.LASF71:
-	.string	"environ"
-.LASF80:
-	.string	"_IO_FILE"
-.LASF74:
-	.string	"page_size"
-.LASF55:
-	.string	"Elf64_Addr"
-.LASF49:
-	.string	"sys_nerr"
-.LASF24:
-	.string	"_IO_save_end"
-.LASF5:
-	.string	"short int"
-.LASF6:
-	.string	"size_t"
-.LASF72:
-	.string	"p_dyn"
-.LASF34:
-	.string	"_offset"
-.LASF18:
-	.string	"_IO_write_ptr"
-.LASF13:
-	.string	"_flags"
-.LASF79:
-	.string	"/usr/local/src/liballocs/allocsld"
-.LASF64:
-	.string	"Elf64_auxv_t"
-.LASF33:
-	.string	"_lock"
-.LASF57:
-	.string	"d_ptr"
-.LASF65:
-	.string	"__environ"
-.LASF25:
-	.string	"_markers"
-.LASF15:
-	.string	"_IO_read_end"
-.LASF38:
-	.string	"_freeres_buf"
-.LASF59:
-	.string	"d_un"
-.LASF48:
-	.string	"stderr"
-.LASF62:
-	.string	"a_type"
-.LASF61:
-	.string	"a_val"
-.LASF60:
-	.string	"Elf64_Dyn"
-.LASF8:
-	.string	"long int"
-.LASF7:
-	.string	"__int64_t"
-.LASF54:
-	.string	"Elf64_Sxword"
-.LASF30:
-	.string	"_cur_column"
-.LASF56:
-	.string	"d_val"
-.LASF29:
-	.string	"_old_offset"
-.LASF63:
-	.string	"a_un"
-.LASF2:
-	.string	"unsigned char"
-.LASF78:
-	.string	"/usr/local/src/liballocs/contrib/donald/src/entry.c"
-.LASF4:
-	.string	"signed char"
-.LASF52:
-	.string	"uint64_t"
-.LASF75:
-	.string	"sp_on_entry"
-.LASF1:
-	.string	"unsigned int"
-.LASF43:
-	.string	"_IO_marker"
-.LASF32:
-	.string	"_shortbuf"
-.LASF17:
-	.string	"_IO_write_base"
-.LASF41:
-	.string	"_unused2"
-.LASF68:
-	.string	"opterr"
-.LASF21:
-	.string	"_IO_buf_end"
-.LASF58:
-	.string	"d_tag"
-.LASF83:
-	.string	"entry_point"
-.LASF12:
-	.string	"char"
-.LASF76:
-	.string	"_DYNAMIC"
-.LASF36:
-	.string	"_wide_data"
-.LASF37:
-	.string	"_freeres_list"
-.LASF39:
-	.string	"__pad5"
-.LASF9:
-	.string	"__uint64_t"
-.LASF3:
-	.string	"short unsigned int"
-.LASF0:
-	.string	"long unsigned int"
-.LASF70:
-	.string	"_begin"
-.LASF19:
-	.string	"_IO_write_end"
-.LASF11:
-	.string	"__off64_t"
-.LASF51:
-	.string	"int64_t"
-.LASF27:
-	.string	"_fileno"
-.LASF26:
-	.string	"_chain"
-.LASF77:
-	.string	"GNU C99 8.3.0 -mtune=generic -march=x86-64 -g -std=gnu99 -fPIC -fno-stack-protector"
-.LASF45:
-	.string	"_IO_wide_data"
-.LASF40:
-	.string	"_mode"
-.LASF53:
-	.string	"Elf64_Xword"
-.LASF23:
-	.string	"_IO_backup_base"
-.LASF46:
-	.string	"stdin"
-.LASF20:
-	.string	"_IO_buf_base"
-.LASF10:
-	.string	"__off_t"
-.LASF28:
-	.string	"_flags2"
-.LASF44:
-	.string	"_IO_codecvt"
-.LASF16:
-	.string	"_IO_read_base"
-.LASF31:
-	.string	"_vtable_offset"
-.LASF35:
-	.string	"_codecvt"
-.LASF22:
-	.string	"_IO_save_base"
-.LASF50:
-	.string	"sys_errlist"
-.LASF69:
-	.string	"optopt"
-.LASF42:
-	.string	"FILE"
-.LASF14:
-	.string	"_IO_read_ptr"
-.LASF82:
-	.string	"enter"
-.LASF73:
-	.string	"p_auxv"
-.LASF47:
-	.string	"stdout"
-.LASF81:
-	.string	"_IO_lock_t"
-	.hidden	sp_on_entry
-	.ident	"GCC: (Debian 8.3.0-6) 8.3.0"
-	.section	.note.GNU-stack,"",@progbits
diff --git a/allocsld/load.s b/allocsld/load.s
deleted file mode 100644
index 716fe49..0000000
--- a/allocsld/load.s
+++ /dev/null
@@ -1,1348 +0,0 @@
-	.file	"load.c"
-	.text
-.Ltext0:
-	.section	.rodata
-	.align 8
-.LC0:
-	.string	"/usr/local/src/liballocs/contrib/donald/src/load.c"
-	.align 8
-.LC1:
-	.string	"mapped_end_vaddr > mapped_up_to_vaddr"
-	.text
-	.globl	load_one_phdr
-	.hidden	load_one_phdr
-	.type	load_one_phdr, @function
-load_one_phdr:
-.LFB0:
-	.file 1 "/usr/local/src/liballocs/contrib/donald/src/load.c"
-	.loc 1 9 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$144, %rsp
-	movq	%rdi, -88(%rbp)
-	movl	%esi, -92(%rbp)
-	movq	%rdx, -104(%rbp)
-	movq	%rcx, -112(%rbp)
-	movq	%r8, -120(%rbp)
-	movq	%r9, -128(%rbp)
-	movl	16(%rbp), %ecx
-	movl	24(%rbp), %edx
-	movl	32(%rbp), %eax
-	movb	%cl, -96(%rbp)
-	movb	%dl, -132(%rbp)
-	movb	%al, -136(%rbp)
-	.loc 1 11 6
-	movl	$0, -4(%rbp)
-	.loc 1 12 5
-	cmpb	$0, -96(%rbp)
-	je	.L2
-	.loc 1 12 17 discriminator 1
-	orl	$1, -4(%rbp)
-.L2:
-	.loc 1 13 5
-	cmpb	$0, -132(%rbp)
-	je	.L3
-	.loc 1 13 18 discriminator 1
-	orl	$2, -4(%rbp)
-.L3:
-	.loc 1 14 5
-	cmpb	$0, -136(%rbp)
-	je	.L4
-	.loc 1 14 17 discriminator 1
-	orl	$4, -4(%rbp)
-.L4:
-	.loc 1 20 5
-	cmpq	$0, -128(%rbp)
-	jne	.L5
-.LBB2:
-	.loc 1 22 34
-	movq	-104(%rbp), %rdx
-	movq	-88(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 22 9
-	movq	%rax, -24(%rbp)
-	.loc 1 24 32
-	movq	-24(%rbp), %rax
-	.loc 1 24 51
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	.loc 1 24 28
-	movq	-120(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 24 65
-	movq	page_size(%rip), %rax
-	addq	%rdx, %rax
-	subq	$1, %rax
-	.loc 1 24 84
-	movq	page_size(%rip), %rdi
-	movl	$0, %edx
-	divq	%rdi
-	movq	%rax, %rdx
-	.loc 1 23 9
-	movq	page_size(%rip), %rax
-	movq	%rdx, %rsi
-	imulq	%rax, %rsi
-	.loc 1 23 23
-	movq	-24(%rbp), %rax
-	.loc 1 23 42
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	movq	%rdx, %rax
-	.loc 1 23 19
-	negq	%rax
-	movq	%rax, %rdx
-	movq	-24(%rbp), %rax
-	leaq	(%rdx,%rax), %rdi
-	.loc 1 23 9
-	movl	-4(%rbp), %eax
-	movl	$0, %r9d
-	movl	$-1, %r8d
-	movl	$50, %ecx
-	movl	%eax, %edx
-	call	mmap@PLT
-	movq	%rax, -16(%rbp)
-	.loc 1 26 15
-	cmpq	$-1, -16(%rbp)
-	sete	%al
-	movzbl	%al, %eax
-	jmp	.L6
-.L5:
-.LBE2:
-	.loc 1 28 10
-	movq	-120(%rbp), %rax
-	cmpq	-128(%rbp), %rax
-	jb	.L7
-.LBB3:
-	.loc 1 31 34
-	movq	-104(%rbp), %rdx
-	movq	-88(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 31 9
-	movq	%rax, -32(%rbp)
-	.loc 1 32 54
-	movq	-32(%rbp), %rax
-	.loc 1 32 73
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	.loc 1 32 50
-	movq	-128(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 32 87
-	movq	page_size(%rip), %rax
-	addq	%rdx, %rax
-	subq	$1, %rax
-	.loc 1 32 106
-	movq	page_size(%rip), %rdi
-	movl	$0, %edx
-	divq	%rdi
-	movq	%rax, %rdx
-	.loc 1 32 38
-	movq	page_size(%rip), %rax
-	.loc 1 32 10
-	imulq	%rdx, %rax
-	movq	%rax, -40(%rbp)
-	.loc 1 34 44
-	movq	-32(%rbp), %rax
-	.loc 1 34 63
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	.loc 1 34 40
-	movq	-40(%rbp), %rax
-	subq	%rdx, %rax
-	.loc 1 34 76
-	subq	-128(%rbp), %rax
-	.loc 1 34 11
-	movq	%rax, -48(%rbp)
-	.loc 1 35 52
-	cmpq	$0, -48(%rbp)
-	jle	.L8
-	.loc 1 35 74 discriminator 1
-	movl	-4(%rbp), %eax
-	andl	$-7, %eax
-	.loc 1 35 52 discriminator 1
-	orl	$2, %eax
-	jmp	.L9
-.L8:
-	.loc 1 35 52 is_stmt 0 discriminator 2
-	movl	-4(%rbp), %eax
-.L9:
-	.loc 1 35 7 is_stmt 1 discriminator 4
-	movl	%eax, -52(%rbp)
-	.loc 1 38 59 discriminator 4
-	movq	-32(%rbp), %rax
-	.loc 1 38 78 discriminator 4
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	.loc 1 38 55 discriminator 4
-	movq	-112(%rbp), %rax
-	subq	%rdx, %rax
-	.loc 1 36 9 discriminator 4
-	movq	%rax, %rsi
-	.loc 1 36 23 discriminator 4
-	movq	-32(%rbp), %rax
-	.loc 1 36 42 discriminator 4
-	movq	page_size(%rip), %rcx
-	movl	$0, %edx
-	divq	%rcx
-	movq	%rdx, %rax
-	.loc 1 36 19 discriminator 4
-	negq	%rax
-	movq	%rax, %rdx
-	movq	-32(%rbp), %rax
-	leaq	(%rdx,%rax), %rdi
-	.loc 1 36 9 discriminator 4
-	movl	-92(%rbp), %ecx
-	movl	-52(%rbp), %edx
-	movq	-40(%rbp), %rax
-	movq	%rsi, %r9
-	movl	%ecx, %r8d
-	movl	$18, %ecx
-	movq	%rax, %rsi
-	call	mmap@PLT
-	movq	%rax, -16(%rbp)
-	.loc 1 39 6 discriminator 4
-	cmpq	$-1, -16(%rbp)
-	je	.L10
-.LBB4:
-	.loc 1 41 7
-	cmpq	$0, -48(%rbp)
-	jle	.L11
-	.loc 1 43 5
-	movq	-48(%rbp), %rcx
-	.loc 1 43 28
-	movq	-32(%rbp), %rax
-	.loc 1 43 47
-	movq	page_size(%rip), %rsi
-	movl	$0, %edx
-	divq	%rsi
-	.loc 1 43 60
-	movq	-128(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 43 5
-	movq	-16(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rcx, %rdx
-	movl	$0, %esi
-	movq	%rax, %rdi
-	call	memset@PLT
-.L11:
-	.loc 1 45 7
-	movl	-52(%rbp), %eax
-	cmpl	-4(%rbp), %eax
-	je	.L12
-	.loc 1 47 5
-	movl	-4(%rbp), %edx
-	movq	-40(%rbp), %rcx
-	movq	-16(%rbp), %rax
-	movq	%rcx, %rsi
-	movq	%rax, %rdi
-	call	mprotect@PLT
-.L12:
-	.loc 1 49 65
-	movq	page_size(%rip), %rcx
-	movq	-104(%rbp), %rax
-	movl	$0, %edx
-	divq	%rcx
-	.loc 1 49 41
-	movq	-104(%rbp), %rax
-	subq	%rdx, %rax
-	movq	%rax, %rdx
-	.loc 1 49 14
-	movq	-40(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -64(%rbp)
-	.loc 1 50 35
-	movq	-104(%rbp), %rdx
-	movq	-120(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 50 7
-	cmpq	%rax, -64(%rbp)
-	jnb	.L10
-.LBB5:
-	.loc 1 52 58
-	movq	-104(%rbp), %rdx
-	movq	-120(%rbp), %rax
-	addq	%rax, %rdx
-	.loc 1 52 67
-	movq	page_size(%rip), %rax
-	addq	%rdx, %rax
-	subq	$1, %rax
-	.loc 1 52 86
-	movq	page_size(%rip), %rsi
-	movl	$0, %edx
-	divq	%rsi
-	movq	%rax, %rdx
-	.loc 1 52 47
-	movq	page_size(%rip), %rax
-	.loc 1 52 15
-	imulq	%rdx, %rax
-	movq	%rax, -72(%rbp)
-	.loc 1 53 36
-	movq	-72(%rbp), %rax
-	cmpq	-64(%rbp), %rax
-	ja	.L13
-	.loc 1 53 13 discriminator 1
-	leaq	__PRETTY_FUNCTION__.3409(%rip), %rcx
-	movl	$53, %edx
-	leaq	.LC0(%rip), %rsi
-	leaq	.LC1(%rip), %rdi
-	call	__assert_fail@PLT
-.L13:
-	.loc 1 54 11
-	movq	-72(%rbp), %rax
-	subq	-64(%rbp), %rax
-	.loc 1 54 34
-	movq	-64(%rbp), %rcx
-	movq	-88(%rbp), %rdx
-	addq	%rcx, %rdx
-	.loc 1 54 11
-	movq	%rdx, %rdi
-	movl	-4(%rbp), %edx
-	movl	$0, %r9d
-	movl	$-1, %r8d
-	movl	$50, %ecx
-	movq	%rax, %rsi
-	call	mmap@PLT
-	movq	%rax, -16(%rbp)
-.L10:
-.LBE5:
-.LBE4:
-	.loc 1 59 15
-	cmpq	$-1, -16(%rbp)
-	sete	%al
-	movzbl	%al, %eax
-	jmp	.L6
-.L7:
-.LBE3:
-	.loc 1 61 14
-	movl	$2, %eax
-.L6:
-	.loc 1 62 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE0:
-	.size	load_one_phdr, .-load_one_phdr
-	.section	.rodata
-	.align 8
-	.type	__PRETTY_FUNCTION__.3409, @object
-	.size	__PRETTY_FUNCTION__.3409, 14
-__PRETTY_FUNCTION__.3409:
-	.string	"load_one_phdr"
-	.text
-.Letext0:
-	.file 2 "/usr/include/x86_64-linux-gnu/bits/types.h"
-	.file 3 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
-	.file 4 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
-	.file 5 "/usr/include/stdint.h"
-	.file 6 "/usr/include/elf.h"
-	.file 7 "/usr/include/unistd.h"
-	.file 8 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
-	.file 9 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
-	.file 10 "/usr/local/src/liballocs/contrib/donald/src/donald.h"
-	.section	.debug_info,"",@progbits
-.Ldebug_info0:
-	.long	0x405
-	.value	0x4
-	.long	.Ldebug_abbrev0
-	.byte	0x8
-	.uleb128 0x1
-	.long	.LASF56
-	.byte	0xc
-	.long	.LASF57
-	.long	.LASF58
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.long	.Ldebug_line0
-	.uleb128 0x2
-	.byte	0x1
-	.byte	0x8
-	.long	.LASF0
-	.uleb128 0x2
-	.byte	0x2
-	.byte	0x7
-	.long	.LASF1
-	.uleb128 0x2
-	.byte	0x4
-	.byte	0x7
-	.long	.LASF2
-	.uleb128 0x2
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF3
-	.uleb128 0x2
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF4
-	.uleb128 0x2
-	.byte	0x2
-	.byte	0x5
-	.long	.LASF5
-	.uleb128 0x3
-	.byte	0x4
-	.byte	0x5
-	.string	"int"
-	.uleb128 0x4
-	.long	.LASF7
-	.byte	0x2
-	.byte	0x2b
-	.byte	0x19
-	.long	0x6a
-	.uleb128 0x2
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF6
-	.uleb128 0x4
-	.long	.LASF8
-	.byte	0x2
-	.byte	0x2c
-	.byte	0x1b
-	.long	0x42
-	.uleb128 0x5
-	.byte	0x8
-	.uleb128 0x4
-	.long	.LASF9
-	.byte	0x2
-	.byte	0xbf
-	.byte	0x12
-	.long	0x6a
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x91
-	.uleb128 0x2
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF10
-	.uleb128 0x7
-	.long	0x91
-	.uleb128 0x4
-	.long	.LASF11
-	.byte	0x3
-	.byte	0x1b
-	.byte	0x13
-	.long	0x5e
-	.uleb128 0x4
-	.long	.LASF12
-	.byte	0x4
-	.byte	0x1b
-	.byte	0x14
-	.long	0x71
-	.uleb128 0x4
-	.long	.LASF13
-	.byte	0x5
-	.byte	0x5a
-	.byte	0x1b
-	.long	0x42
-	.uleb128 0x4
-	.long	.LASF14
-	.byte	0x6
-	.byte	0x2b
-	.byte	0x12
-	.long	0xa9
-	.uleb128 0x4
-	.long	.LASF15
-	.byte	0x6
-	.byte	0x2c
-	.byte	0x11
-	.long	0x9d
-	.uleb128 0x4
-	.long	.LASF16
-	.byte	0x6
-	.byte	0x30
-	.byte	0x12
-	.long	0xa9
-	.uleb128 0x8
-	.byte	0x8
-	.byte	0x6
-	.value	0x340
-	.byte	0x3
-	.long	0x10a
-	.uleb128 0x9
-	.long	.LASF17
-	.byte	0x6
-	.value	0x342
-	.byte	0x13
-	.long	0xc1
-	.uleb128 0x9
-	.long	.LASF18
-	.byte	0x6
-	.value	0x343
-	.byte	0x12
-	.long	0xd9
-	.byte	0
-	.uleb128 0xa
-	.byte	0x10
-	.byte	0x6
-	.value	0x33d
-	.byte	0x9
-	.long	0x131
-	.uleb128 0xb
-	.long	.LASF19
-	.byte	0x6
-	.value	0x33f
-	.byte	0x10
-	.long	0xcd
-	.byte	0
-	.uleb128 0xb
-	.long	.LASF20
-	.byte	0x6
-	.value	0x344
-	.byte	0x7
-	.long	0xe5
-	.byte	0x8
-	.byte	0
-	.uleb128 0xc
-	.long	.LASF21
-	.byte	0x6
-	.value	0x345
-	.byte	0x3
-	.long	0x10a
-	.uleb128 0x8
-	.byte	0x8
-	.byte	0x6
-	.value	0x470
-	.byte	0x3
-	.long	0x156
-	.uleb128 0x9
-	.long	.LASF22
-	.byte	0x6
-	.value	0x472
-	.byte	0x10
-	.long	0xa9
-	.byte	0
-	.uleb128 0xa
-	.byte	0x10
-	.byte	0x6
-	.value	0x46d
-	.byte	0x9
-	.long	0x17d
-	.uleb128 0xb
-	.long	.LASF23
-	.byte	0x6
-	.value	0x46f
-	.byte	0xc
-	.long	0xa9
-	.byte	0
-	.uleb128 0xb
-	.long	.LASF24
-	.byte	0x6
-	.value	0x476
-	.byte	0x7
-	.long	0x13e
-	.byte	0x8
-	.byte	0
-	.uleb128 0xc
-	.long	.LASF25
-	.byte	0x6
-	.value	0x477
-	.byte	0x3
-	.long	0x156
-	.uleb128 0x4
-	.long	.LASF26
-	.byte	0x7
-	.byte	0xdc
-	.byte	0x13
-	.long	0x7f
-	.uleb128 0x4
-	.long	.LASF27
-	.byte	0x8
-	.byte	0xd8
-	.byte	0x1b
-	.long	0x42
-	.uleb128 0xd
-	.long	.LASF28
-	.byte	0x7
-	.value	0x21f
-	.byte	0xf
-	.long	0x1af
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x8b
-	.uleb128 0xd
-	.long	.LASF29
-	.byte	0x7
-	.value	0x221
-	.byte	0xf
-	.long	0x1af
-	.uleb128 0xe
-	.long	.LASF30
-	.byte	0x9
-	.byte	0x24
-	.byte	0xe
-	.long	0x8b
-	.uleb128 0xe
-	.long	.LASF31
-	.byte	0x9
-	.byte	0x32
-	.byte	0xc
-	.long	0x57
-	.uleb128 0xe
-	.long	.LASF32
-	.byte	0x9
-	.byte	0x37
-	.byte	0xc
-	.long	0x57
-	.uleb128 0xe
-	.long	.LASF33
-	.byte	0x9
-	.byte	0x3b
-	.byte	0xc
-	.long	0x57
-	.uleb128 0xe
-	.long	.LASF34
-	.byte	0xa
-	.byte	0x32
-	.byte	0xc
-	.long	0x57
-	.uleb128 0xe
-	.long	.LASF35
-	.byte	0xa
-	.byte	0x34
-	.byte	0x13
-	.long	0x20a
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x131
-	.uleb128 0xe
-	.long	.LASF36
-	.byte	0xa
-	.byte	0x35
-	.byte	0x16
-	.long	0x21c
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x17d
-	.uleb128 0xe
-	.long	.LASF37
-	.byte	0xa
-	.byte	0x36
-	.byte	0x16
-	.long	0x42
-	.uleb128 0xe
-	.long	.LASF38
-	.byte	0xa
-	.byte	0x37
-	.byte	0xe
-	.long	0x7d
-	.uleb128 0xf
-	.long	0x131
-	.long	0x245
-	.uleb128 0x10
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF39
-	.byte	0xa
-	.byte	0x38
-	.byte	0x12
-	.long	0x23a
-	.uleb128 0x11
-	.long	.LASF59
-	.byte	0x1
-	.byte	0x7
-	.byte	0x5
-	.long	0x57
-	.quad	.LFB0
-	.quad	.LFE0-.LFB0
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x3ec
-	.uleb128 0x12
-	.long	.LASF40
-	.byte	0x1
-	.byte	0x7
-	.byte	0x21
-	.long	0x42
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -104
-	.uleb128 0x13
-	.string	"fd"
-	.byte	0x1
-	.byte	0x7
-	.byte	0x30
-	.long	0x57
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -108
-	.uleb128 0x12
-	.long	.LASF41
-	.byte	0x1
-	.byte	0x7
-	.byte	0x42
-	.long	0x42
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -120
-	.uleb128 0x12
-	.long	.LASF42
-	.byte	0x1
-	.byte	0x7
-	.byte	0x57
-	.long	0x42
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -128
-	.uleb128 0x12
-	.long	.LASF43
-	.byte	0x1
-	.byte	0x8
-	.byte	0x10
-	.long	0x42
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -136
-	.uleb128 0x12
-	.long	.LASF44
-	.byte	0x1
-	.byte	0x8
-	.byte	0x25
-	.long	0x42
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -144
-	.uleb128 0x12
-	.long	.LASF45
-	.byte	0x1
-	.byte	0x8
-	.byte	0x33
-	.long	0x3ec
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -112
-	.uleb128 0x12
-	.long	.LASF46
-	.byte	0x1
-	.byte	0x8
-	.byte	0x3f
-	.long	0x3ec
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -148
-	.uleb128 0x12
-	.long	.LASF47
-	.byte	0x1
-	.byte	0x8
-	.byte	0x4c
-	.long	0x3ec
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -152
-	.uleb128 0x14
-	.long	.LASF48
-	.byte	0x1
-	.byte	0xb
-	.byte	0x6
-	.long	0x57
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -20
-	.uleb128 0x15
-	.string	"ret"
-	.byte	0x1
-	.byte	0x13
-	.byte	0x8
-	.long	0x7d
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x16
-	.long	.LASF60
-	.long	0x403
-	.uleb128 0x9
-	.byte	0x3
-	.quad	__PRETTY_FUNCTION__.3409
-	.uleb128 0x17
-	.quad	.LBB2
-	.quad	.LBE2-.LBB2
-	.long	0x358
-	.uleb128 0x14
-	.long	.LASF49
-	.byte	0x1
-	.byte	0x16
-	.byte	0x9
-	.long	0x8b
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.byte	0
-	.uleb128 0x18
-	.quad	.LBB3
-	.quad	.LBE3-.LBB3
-	.uleb128 0x14
-	.long	.LASF49
-	.byte	0x1
-	.byte	0x1f
-	.byte	0x9
-	.long	0x8b
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x14
-	.long	.LASF50
-	.byte	0x1
-	.byte	0x20
-	.byte	0xa
-	.long	0x196
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x14
-	.long	.LASF51
-	.byte	0x1
-	.byte	0x22
-	.byte	0xb
-	.long	0x18a
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x14
-	.long	.LASF52
-	.byte	0x1
-	.byte	0x23
-	.byte	0x7
-	.long	0x57
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -68
-	.uleb128 0x18
-	.quad	.LBB4
-	.quad	.LBE4-.LBB4
-	.uleb128 0x14
-	.long	.LASF53
-	.byte	0x1
-	.byte	0x31
-	.byte	0xe
-	.long	0xb5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.uleb128 0x18
-	.quad	.LBB5
-	.quad	.LBE5-.LBB5
-	.uleb128 0x14
-	.long	.LASF54
-	.byte	0x1
-	.byte	0x34
-	.byte	0xf
-	.long	0xb5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.byte	0
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x2
-	.byte	0x1
-	.byte	0x2
-	.long	.LASF55
-	.uleb128 0xf
-	.long	0x98
-	.long	0x403
-	.uleb128 0x19
-	.long	0x42
-	.byte	0xd
-	.byte	0
-	.uleb128 0x7
-	.long	0x3f3
-	.byte	0
-	.section	.debug_abbrev,"",@progbits
-.Ldebug_abbrev0:
-	.uleb128 0x1
-	.uleb128 0x11
-	.byte	0x1
-	.uleb128 0x25
-	.uleb128 0xe
-	.uleb128 0x13
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1b
-	.uleb128 0xe
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x10
-	.uleb128 0x17
-	.byte	0
-	.byte	0
-	.uleb128 0x2
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0x8
-	.byte	0
-	.byte	0
-	.uleb128 0x4
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x5
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.uleb128 0x26
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x8
-	.uleb128 0x17
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x9
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xa
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xd
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xe
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xf
-	.uleb128 0x1
-	.byte	0x1
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x10
-	.uleb128 0x21
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x11
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x12
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x13
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x14
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x15
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x16
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x34
-	.uleb128 0x19
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x17
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x18
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.byte	0
-	.byte	0
-	.uleb128 0x19
-	.uleb128 0x21
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2f
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_aranges,"",@progbits
-	.long	0x2c
-	.value	0x2
-	.long	.Ldebug_info0
-	.byte	0x8
-	.byte	0
-	.value	0
-	.value	0
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.quad	0
-	.quad	0
-	.section	.debug_line,"",@progbits
-.Ldebug_line0:
-	.section	.debug_str,"MS",@progbits,1
-.LASF31:
-	.string	"optind"
-.LASF43:
-	.string	"memsz"
-.LASF40:
-	.string	"base_addr"
-.LASF29:
-	.string	"environ"
-.LASF46:
-	.string	"write"
-.LASF59:
-	.string	"load_one_phdr"
-.LASF37:
-	.string	"page_size"
-.LASF16:
-	.string	"Elf64_Addr"
-.LASF12:
-	.string	"uint64_t"
-.LASF5:
-	.string	"short int"
-.LASF27:
-	.string	"size_t"
-.LASF35:
-	.string	"p_dyn"
-.LASF60:
-	.string	"__PRETTY_FUNCTION__"
-.LASF25:
-	.string	"Elf64_auxv_t"
-.LASF26:
-	.string	"ssize_t"
-.LASF18:
-	.string	"d_ptr"
-.LASF28:
-	.string	"__environ"
-.LASF11:
-	.string	"int64_t"
-.LASF13:
-	.string	"uintptr_t"
-.LASF20:
-	.string	"d_un"
-.LASF54:
-	.string	"mapped_end_vaddr"
-.LASF47:
-	.string	"exec"
-.LASF45:
-	.string	"read"
-.LASF23:
-	.string	"a_type"
-.LASF52:
-	.string	"temporary_prot"
-.LASF51:
-	.string	"uninited_size"
-.LASF22:
-	.string	"a_val"
-.LASF21:
-	.string	"Elf64_Dyn"
-.LASF6:
-	.string	"long int"
-.LASF7:
-	.string	"__int64_t"
-.LASF15:
-	.string	"Elf64_Sxword"
-.LASF42:
-	.string	"offset"
-.LASF17:
-	.string	"d_val"
-.LASF44:
-	.string	"filesz"
-.LASF24:
-	.string	"a_un"
-.LASF0:
-	.string	"unsigned char"
-.LASF30:
-	.string	"optarg"
-.LASF4:
-	.string	"signed char"
-.LASF38:
-	.string	"sp_on_entry"
-.LASF2:
-	.string	"unsigned int"
-.LASF57:
-	.string	"/usr/local/src/liballocs/contrib/donald/src/load.c"
-.LASF32:
-	.string	"opterr"
-.LASF53:
-	.string	"mapped_up_to_vaddr"
-.LASF1:
-	.string	"short unsigned int"
-.LASF19:
-	.string	"d_tag"
-.LASF10:
-	.string	"char"
-.LASF50:
-	.string	"mapping_size"
-.LASF41:
-	.string	"vaddr"
-.LASF39:
-	.string	"_DYNAMIC"
-.LASF9:
-	.string	"__ssize_t"
-.LASF49:
-	.string	"addr"
-.LASF55:
-	.string	"_Bool"
-.LASF8:
-	.string	"__uint64_t"
-.LASF3:
-	.string	"long unsigned int"
-.LASF34:
-	.string	"_begin"
-.LASF56:
-	.string	"GNU C99 8.3.0 -mtune=generic -march=x86-64 -g -std=gnu99 -fPIC -fno-stack-protector"
-.LASF14:
-	.string	"Elf64_Xword"
-.LASF48:
-	.string	"prot"
-.LASF33:
-	.string	"optopt"
-.LASF58:
-	.string	"/usr/local/src/liballocs/allocsld"
-.LASF36:
-	.string	"p_auxv"
-	.hidden	page_size
-	.ident	"GCC: (Debian 8.3.0-6) 8.3.0"
-	.section	.note.GNU-stack,"",@progbits
diff --git a/allocsld/main.s b/allocsld/main.s
deleted file mode 100644
index 7fa731e..0000000
--- a/allocsld/main.s
+++ /dev/null
@@ -1,3863 +0,0 @@
-	.file	"main.c"
-	.text
-.Ltext0:
-	.section	.rodata
-.LC0:
-	.string	" "
-.LC1:
-	.string	" not "
-.LC2:
-	.string	"We think we are%sthe program\n"
-	.align 8
-.LC3:
-	.string	"allocsld: no program specified\n"
-.LC4:
-	.string	"/lib64/ld-linux-x86-64.so.2"
-.LC5:
-	.string	"allocsld: could not open %s\n"
-	.align 8
-.LC6:
-	.string	"allocsld: could not read ELF header of %s\n"
-.LC7:
-	.string	"not an ELF file"
-.LC8:
-	.string	"not of expected ELF class"
-.LC9:
-	.string	"not ELFDATA2LSB"
-.LC10:
-	.string	"not EV_CURRENT"
-.LC11:
-	.string	"not System V or GNU ABI"
-.LC12:
-	.string	"not an executable"
-.LC13:
-	.string	"unexpected machine"
-	.align 8
-.LC14:
-	.string	"allocsld: unsupported file (%s): %s\n"
-	.align 8
-.LC15:
-	.string	"allocsld: could not seek to program header %d in %s\n"
-	.align 8
-.LC16:
-	.string	"allocsld: could not read program header %d in %s\n"
-	.align 8
-.LC17:
-	.string	"allocsld: could not seek to section header %d in %s\n"
-	.align 8
-.LC18:
-	.string	"allocsld: could not read section header %d in %s\n"
-	.align 8
-.LC19:
-	.string	"allocsld: could not map %s with PROT_NONE\n"
-	.align 8
-.LC20:
-	.string	"allocsld: file %s has bad PT_LOAD filesz/memsz (phdr index %d)\n"
-	.align 8
-.LC21:
-	.string	"allocsld: could not create mapping for PT_LOAD phdr index %d\n"
-	.align 8
-.LC22:
-	.string	"allocsld: BUG: mysterious error in load_one_phdr() for PT_LOAD phdr index %d\n"
-.LC23:
-	.string	"AT_ENTRY is %p\n"
-.LC24:
-	.string	"AT_PHDR is %p\n"
-.LC25:
-	.string	"AT_PHENT is %p\n"
-.LC26:
-	.string	"AT_PHNUM is %p\n"
-.LC27:
-	.string	"AT_BASE is %p\n"
-.LC28:
-	.string	"AT_EXECFN is %p (%s)\n"
-	.text
-	.globl	main
-	.hidden	main
-	.type	main, @function
-main:
-.LFB6:
-	.file 1 "/usr/local/src/liballocs/contrib/donald/src/main.c"
-	.loc 1 28 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	pushq	%r15
-	pushq	%r14
-	pushq	%r13
-	pushq	%r12
-	pushq	%rbx
-	subq	$520, %rsp
-	.cfi_offset 15, -24
-	.cfi_offset 14, -32
-	.cfi_offset 13, -40
-	.cfi_offset 12, -48
-	.cfi_offset 3, -56
-	movl	%edi, -516(%rbp)
-	movq	%rsi, -528(%rbp)
-	.loc 1 33 12
-	movq	_start@GOTPCREL(%rip), %rax
-	movq	%rax, -80(%rbp)
-	.loc 1 34 8
-	movb	$1, -65(%rbp)
-.LBB2:
-	.loc 1 35 21
-	movq	p_auxv(%rip), %rax
-	movq	%rax, -64(%rbp)
-	.loc 1 35 2
-	jmp	.L2
-.L6:
-	.loc 1 37 12
-	movq	-64(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 37 3
-	cmpq	$9, %rax
-	jne	.L79
-	.loc 1 40 16
-	movq	-64(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 40 23
-	movq	_start@GOTPCREL(%rip), %rdx
-	.loc 1 40 8
-	cmpq	%rdx, %rax
-	je	.L4
-	.loc 1 40 66 discriminator 1
-	movb	$0, -65(%rbp)
-.L4:
-	.loc 1 41 11
-	movq	-64(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -80(%rbp)
-	.loc 1 42 5
-	jmp	.L5
-.L79:
-	.loc 1 44 5
-	nop
-.L5:
-	.loc 1 35 44 discriminator 2
-	addq	$16, -64(%rbp)
-.L2:
-	.loc 1 35 34 discriminator 1
-	movq	-64(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 35 2 discriminator 1
-	testq	%rax, %rax
-	jne	.L6
-.LBE2:
-	.loc 1 47 2
-	cmpb	$0, -65(%rbp)
-	je	.L7
-	.loc 1 47 2 is_stmt 0 discriminator 1
-	leaq	.LC0(%rip), %rax
-	jmp	.L8
-.L7:
-	.loc 1 47 2 discriminator 2
-	leaq	.LC1(%rip), %rax
-.L8:
-	.loc 1 47 2 discriminator 4
-	movq	stderr@GOTPCREL(%rip), %rdx
-	movq	(%rdx), %rcx
-	movq	%rax, %rdx
-	leaq	.LC2(%rip), %rsi
-	movq	%rcx, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 48 12 is_stmt 1 discriminator 4
-	movq	_start@GOTPCREL(%rip), %rax
-	.loc 1 48 5 discriminator 4
-	cmpq	%rax, -80(%rbp)
-	jne	.L9
-	.loc 1 51 20
-	movl	$1, -84(%rbp)
-	jmp	.L10
-.L9:
-	.loc 1 52 26
-	movl	$0, -84(%rbp)
-.L10:
-	.loc 1 54 5
-	movl	-516(%rbp), %eax
-	cmpl	-84(%rbp), %eax
-	jg	.L11
-	.loc 1 54 39 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	%rax, %rcx
-	movl	$31, %edx
-	movl	$1, %esi
-	leaq	.LC3(%rip), %rdi
-	call	fwrite@PLT
-	.loc 1 54 85 discriminator 1
-	movl	$-1, %eax
-	jmp	.L77
-.L11:
-	.loc 1 61 16
-	leaq	.LC4(%rip), %rax
-	movq	%rax, -168(%rbp)
-	.loc 1 66 16
-	movq	-168(%rbp), %rax
-	movl	$0, %esi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	open@PLT
-	movl	%eax, -172(%rbp)
-	.loc 1 67 5
-	cmpl	$-1, -172(%rbp)
-	jne	.L13
-	.loc 1 67 32 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rdx
-	leaq	.LC5(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 67 91 discriminator 1
-	movl	$-1, %eax
-	jmp	.L77
-.L13:
-	.loc 1 68 12
-	leaq	-448(%rbp), %rdx
-	movl	-172(%rbp), %eax
-	movq	%rdx, %rsi
-	movl	%eax, %edi
-	call	fstat@PLT
-	movl	%eax, -176(%rbp)
-	.loc 1 69 5
-	cmpl	$0, -176(%rbp)
-	je	.L14
-	.loc 1 69 23 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rdx
-	leaq	.LC5(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 69 82 discriminator 1
-	movl	$-1, %eax
-	jmp	.L77
-.L14:
-	.loc 1 73 27
-	leaq	-512(%rbp), %rcx
-	movl	-172(%rbp), %eax
-	movl	$64, %edx
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	read@PLT
-	movq	%rax, -184(%rbp)
-	.loc 1 74 5
-	cmpq	$64, -184(%rbp)
-	je	.L15
-	.loc 1 74 41 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rdx
-	leaq	.LC6(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 74 114 discriminator 1
-	movl	$-1, %eax
-	jmp	.L77
-.L15:
-	.loc 1 76 8
-	movb	$0, -51(%rbp)
-	.loc 1 76 20
-	movb	$0, -50(%rbp)
-	.loc 1 76 39
-	movb	$0, -49(%rbp)
-	.loc 1 76 51
-	movb	$0, -85(%rbp)
-	.loc 1 76 67
-	movb	$0, -86(%rbp)
-	.loc 1 77 3
-	movb	$0, -87(%rbp)
-	.loc 1 79 18
-	movzbl	-512(%rbp), %eax
-	.loc 1 79 5
-	cmpb	$127, %al
-	jne	.L16
-	.loc 1 80 19
-	movzbl	-511(%rbp), %eax
-	.loc 1 80 4
-	cmpb	$69, %al
-	jne	.L16
-	.loc 1 81 19
-	movzbl	-510(%rbp), %eax
-	.loc 1 81 4
-	cmpb	$76, %al
-	jne	.L16
-	.loc 1 82 19
-	movzbl	-509(%rbp), %eax
-	.loc 1 82 4
-	cmpb	$70, %al
-	jne	.L16
-	.loc 1 83 15
-	movb	$1, -51(%rbp)
-	.loc 1 83 32
-	movzbl	-508(%rbp), %eax
-	.loc 1 83 4
-	cmpb	$2, %al
-	jne	.L16
-	.loc 1 84 22
-	movb	$1, -50(%rbp)
-	.loc 1 84 39
-	movzbl	-507(%rbp), %eax
-	.loc 1 84 4
-	cmpb	$1, %al
-	jne	.L16
-	.loc 1 85 15
-	movb	$1, -49(%rbp)
-	.loc 1 85 32
-	movzbl	-506(%rbp), %eax
-	.loc 1 85 4
-	cmpb	$1, %al
-	jne	.L16
-	.loc 1 86 19
-	movb	$1, -85(%rbp)
-	.loc 1 86 36
-	movzbl	-505(%rbp), %eax
-	.loc 1 86 63
-	testb	%al, %al
-	je	.L17
-	.loc 1 86 78 discriminator 1
-	movzbl	-505(%rbp), %eax
-	.loc 1 86 63 discriminator 1
-	cmpb	$3, %al
-	je	.L17
-	.loc 1 86 63 is_stmt 0 discriminator 3
-	movl	$1, %eax
-	jmp	.L18
-.L17:
-	.loc 1 86 63 discriminator 4
-	movl	$0, %eax
-.L18:
-	.loc 1 86 4 is_stmt 1 discriminator 6
-	testl	%eax, %eax
-	jne	.L16
-	.loc 1 88 23
-	movb	$1, -86(%rbp)
-	.loc 1 88 32
-	movzwl	-496(%rbp), %eax
-	.loc 1 88 50
-	cmpw	$2, %ax
-	je	.L19
-	.loc 1 88 57 discriminator 1
-	movzwl	-496(%rbp), %eax
-	.loc 1 88 50 discriminator 1
-	cmpw	$3, %ax
-	je	.L19
-	.loc 1 88 50 is_stmt 0 discriminator 3
-	movl	$1, %eax
-	jmp	.L20
-.L19:
-	.loc 1 88 50 discriminator 4
-	movl	$0, %eax
-.L20:
-	.loc 1 88 4 is_stmt 1 discriminator 6
-	testl	%eax, %eax
-	jne	.L16
-	.loc 1 89 25
-	movb	$1, -87(%rbp)
-	.loc 1 89 34
-	movzwl	-494(%rbp), %eax
-	.loc 1 89 4
-	cmpw	$62, %ax
-	je	.L21
-.L16:
-	.loc 1 92 306
-	movl	-84(%rbp), %eax
-	cltq
-	leaq	0(,%rax,8), %rdx
-	movq	-528(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 1 92 8
-	movq	(%rax), %rdx
-	.loc 1 92 52
-	movzbl	-51(%rbp), %eax
-	xorl	$1, %eax
-	.loc 1 92 8
-	testb	%al, %al
-	je	.L22
-	.loc 1 92 8 is_stmt 0 discriminator 1
-	leaq	.LC7(%rip), %rax
-	jmp	.L23
-.L22:
-	.loc 1 92 82 is_stmt 1 discriminator 2
-	movzbl	-50(%rbp), %eax
-	xorl	$1, %eax
-	.loc 1 92 127 discriminator 2
-	testb	%al, %al
-	je	.L24
-	.loc 1 92 127 is_stmt 0 discriminator 4
-	leaq	.LC8(%rip), %rax
-	jmp	.L23
-.L24:
-	.loc 1 92 129 is_stmt 1 discriminator 5
-	movzbl	-49(%rbp), %eax
-	xorl	$1, %eax
-	.loc 1 92 157 discriminator 5
-	testb	%al, %al
-	je	.L26
-	.loc 1 92 157 is_stmt 0 discriminator 7
-	leaq	.LC9(%rip), %rax
-	jmp	.L23
-.L26:
-	.loc 1 92 159 is_stmt 1 discriminator 8
-	movzbl	-85(%rbp), %eax
-	xorl	$1, %eax
-	.loc 1 92 190 discriminator 8
-	testb	%al, %al
-	je	.L28
-	.loc 1 92 190 is_stmt 0 discriminator 10
-	leaq	.LC10(%rip), %rax
-	jmp	.L23
-.L28:
-	.loc 1 92 192 is_stmt 1 discriminator 11
-	movzbl	-86(%rbp), %eax
-	xorl	$1, %eax
-	.loc 1 92 236 discriminator 11
-	testb	%al, %al
-	je	.L30
-	.loc 1 92 236 is_stmt 0 discriminator 13
-	leaq	.LC11(%rip), %rax
-	jmp	.L23
-.L30:
-	.loc 1 92 238 is_stmt 1 discriminator 14
-	movzbl	-87(%rbp), %eax
-	xorl	$1, %eax
-	.loc 1 92 278 discriminator 14
-	testb	%al, %al
-	je	.L32
-	.loc 1 92 278 is_stmt 0 discriminator 16
-	leaq	.LC12(%rip), %rax
-	jmp	.L23
-.L32:
-	.loc 1 92 278 discriminator 17
-	leaq	.LC13(%rip), %rax
-.L23:
-	.loc 1 92 8 is_stmt 1 discriminator 24
-	movq	stderr@GOTPCREL(%rip), %rcx
-	movq	(%rcx), %rdi
-	movq	%rdx, %rcx
-	movq	%rax, %rdx
-	leaq	.LC14(%rip), %rsi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 92 334 discriminator 24
-	movl	$-1, %eax
-	jmp	.L77
-.L21:
-	.loc 1 104 40
-	movq	-480(%rbp), %rax
-	.loc 1 104 17
-	movq	%rax, %rcx
-	movl	-172(%rbp), %eax
-	movl	$0, %edx
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	lseek@PLT
-	movq	%rax, -192(%rbp)
-	.loc 1 105 23
-	movzwl	-456(%rbp), %ecx
-	.loc 1 105 2
-	movq	%rsp, %rax
-	movq	%rax, %rbx
-	.loc 1 105 23
-	movzwl	%cx, %eax
-	.loc 1 105 13
-	subq	$1, %rax
-	movq	%rax, -200(%rbp)
-	movzwl	%cx, %eax
-	movq	%rax, %r14
-	movl	$0, %r15d
-	imulq	$448, %r15, %rdx
-	imulq	$0, %r14, %rax
-	leaq	(%rdx,%rax), %rsi
-	movl	$448, %eax
-	mulq	%r14
-	addq	%rdx, %rsi
-	movq	%rsi, %rdx
-	movzwl	%cx, %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movzwl	%cx, %eax
-	movq	%rax, %r12
-	movl	$0, %r13d
-	imulq	$448, %r13, %rdx
-	imulq	$0, %r12, %rax
-	leaq	(%rdx,%rax), %rsi
-	movl	$448, %eax
-	mulq	%r12
-	addq	%rdx, %rsi
-	movq	%rsi, %rdx
-	movzwl	%cx, %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movl	$16, %eax
-	subq	$1, %rax
-	addq	%rdx, %rax
-	movl	$16, %edi
-	movl	$0, %edx
-	divq	%rdi
-	imulq	$16, %rax, %rax
-	subq	%rax, %rsp
-	movq	%rsp, %rax
-	addq	$7, %rax
-	shrq	$3, %rax
-	salq	$3, %rax
-	movq	%rax, -208(%rbp)
-.LBB3:
-	.loc 1 106 16
-	movl	$0, -92(%rbp)
-	.loc 1 106 2
-	jmp	.L34
-.L38:
-.LBB4:
-	.loc 1 108 19
-	movq	-480(%rbp), %rdx
-	.loc 1 108 38
-	movzwl	-458(%rbp), %eax
-	movzwl	%ax, %eax
-	.loc 1 108 32
-	imull	-92(%rbp), %eax
-	movl	%eax, %eax
-	.loc 1 108 28
-	addq	%rdx, %rax
-	.loc 1 108 9
-	movq	%rax, -216(%rbp)
-	.loc 1 109 12
-	movq	-216(%rbp), %rcx
-	movl	-172(%rbp), %eax
-	movl	$0, %edx
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	lseek@PLT
-	movq	%rax, -192(%rbp)
-	.loc 1 110 6
-	movq	-192(%rbp), %rax
-	cmpq	-216(%rbp), %rax
-	je	.L35
-	.loc 1 110 27 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rcx
-	movl	-92(%rbp), %edx
-	leaq	.LC15(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 110 113 discriminator 1
-	movl	$-1, %eax
-	jmp	.L36
-.L35:
-	.loc 1 111 44
-	movzwl	-458(%rbp), %eax
-	.loc 1 111 75
-	movl	$56, %edx
-	cmpw	$56, %ax
-	cmova	%edx, %eax
-	.loc 1 111 10
-	movzwl	%ax, %eax
-	movq	%rax, -224(%rbp)
-	.loc 1 112 29
-	movl	-92(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	movq	-208(%rbp), %rdx
-	leaq	(%rax,%rdx), %rcx
-	.loc 1 112 11
-	movq	-224(%rbp), %rdx
-	movl	-172(%rbp), %eax
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	read@PLT
-	movq	%rax, -184(%rbp)
-	.loc 1 113 13
-	movq	-224(%rbp), %rax
-	.loc 1 113 6
-	cmpq	%rax, -184(%rbp)
-	je	.L37
-	.loc 1 113 30 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rcx
-	movl	-92(%rbp), %edx
-	leaq	.LC16(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 113 113 discriminator 1
-	movl	$-1, %eax
-	jmp	.L36
-.L37:
-.LBE4:
-	.loc 1 106 41 discriminator 2
-	addl	$1, -92(%rbp)
-.L34:
-	.loc 1 106 31 discriminator 1
-	movzwl	-456(%rbp), %eax
-	movzwl	%ax, %eax
-	.loc 1 106 2 discriminator 1
-	cmpl	%eax, -92(%rbp)
-	jb	.L38
-.LBE3:
-	.loc 1 116 34
-	movq	-472(%rbp), %rax
-	.loc 1 116 11
-	movq	%rax, %rcx
-	movl	-172(%rbp), %eax
-	movl	$0, %edx
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	lseek@PLT
-	movq	%rax, -192(%rbp)
-	.loc 1 117 23
-	movzwl	-452(%rbp), %eax
-	.loc 1 117 2
-	movq	%rsp, %rdx
-	movq	%rdx, %r12
-	.loc 1 117 23
-	movzwl	%ax, %edx
-	.loc 1 117 13
-	subq	$1, %rdx
-	movq	%rdx, -232(%rbp)
-	movzwl	%ax, %edx
-	movq	%rdx, -544(%rbp)
-	movq	$0, -536(%rbp)
-	movzwl	%ax, %edx
-	movq	%rdx, -560(%rbp)
-	movq	$0, -552(%rbp)
-	movzwl	%ax, %eax
-	salq	$6, %rax
-	movq	%rax, %rdx
-	movl	$16, %eax
-	subq	$1, %rax
-	addq	%rdx, %rax
-	movl	$16, %edi
-	movl	$0, %edx
-	divq	%rdi
-	imulq	$16, %rax, %rax
-	subq	%rax, %rsp
-	movq	%rsp, %rax
-	addq	$7, %rax
-	shrq	$3, %rax
-	salq	$3, %rax
-	movq	%rax, -240(%rbp)
-.LBB5:
-	.loc 1 118 16
-	movl	$0, -96(%rbp)
-	.loc 1 118 2
-	jmp	.L39
-.L43:
-.LBB6:
-	.loc 1 120 19
-	movq	-472(%rbp), %rdx
-	.loc 1 120 38
-	movzwl	-454(%rbp), %eax
-	movzwl	%ax, %eax
-	.loc 1 120 32
-	imull	-96(%rbp), %eax
-	movl	%eax, %eax
-	.loc 1 120 28
-	addq	%rdx, %rax
-	.loc 1 120 9
-	movq	%rax, -248(%rbp)
-	.loc 1 121 12
-	movq	-248(%rbp), %rcx
-	movl	-172(%rbp), %eax
-	movl	$0, %edx
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	lseek@PLT
-	movq	%rax, -192(%rbp)
-	.loc 1 122 6
-	movq	-192(%rbp), %rax
-	cmpq	-248(%rbp), %rax
-	je	.L40
-	.loc 1 122 27 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rcx
-	movl	-96(%rbp), %edx
-	leaq	.LC17(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 122 113 discriminator 1
-	movl	$-1, %eax
-	jmp	.L41
-.L40:
-	.loc 1 123 44
-	movzwl	-454(%rbp), %eax
-	.loc 1 123 75
-	movl	$64, %edx
-	cmpw	$64, %ax
-	cmova	%edx, %eax
-	.loc 1 123 10
-	movzwl	%ax, %eax
-	movq	%rax, -256(%rbp)
-	.loc 1 124 29
-	movl	-96(%rbp), %eax
-	salq	$6, %rax
-	movq	%rax, %rdx
-	movq	-240(%rbp), %rax
-	leaq	(%rdx,%rax), %rcx
-	.loc 1 124 11
-	movq	-256(%rbp), %rdx
-	movl	-172(%rbp), %eax
-	movq	%rcx, %rsi
-	movl	%eax, %edi
-	call	read@PLT
-	movq	%rax, -184(%rbp)
-	.loc 1 125 13
-	movq	-256(%rbp), %rax
-	.loc 1 125 6
-	cmpq	%rax, -184(%rbp)
-	je	.L42
-	.loc 1 125 30 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rcx
-	movl	-96(%rbp), %edx
-	leaq	.LC18(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 125 113 discriminator 1
-	movl	$-1, %eax
-	jmp	.L41
-.L42:
-.LBE6:
-	.loc 1 118 41 discriminator 2
-	addl	$1, -96(%rbp)
-.L39:
-	.loc 1 118 31 discriminator 1
-	movzwl	-452(%rbp), %eax
-	movzwl	%ax, %eax
-	.loc 1 118 2 discriminator 1
-	cmpl	%eax, -96(%rbp)
-	jb	.L43
-.LBE5:
-	.loc 1 132 13
-	movq	$0, -104(%rbp)
-	.loc 1 133 12
-	movq	$-1, -112(%rbp)
-.LBB7:
-	.loc 1 134 16
-	movl	$0, -116(%rbp)
-	.loc 1 134 2
-	jmp	.L44
-.L47:
-.LBB8:
-	.loc 1 136 15
-	movq	-208(%rbp), %rcx
-	movl	-116(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	movl	(%rax), %eax
-	.loc 1 136 6
-	cmpl	$2, %eax
-	jne	.L45
-	.loc 1 136 60 discriminator 1
-	movq	-208(%rbp), %rcx
-	movl	-116(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$16, %rax
-	movq	(%rax), %rax
-	movq	%rax, -112(%rbp)
-.L45:
-	.loc 1 137 43
-	movq	-208(%rbp), %rcx
-	movl	-116(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$16, %rax
-	movq	(%rax), %rcx
-	.loc 1 137 62
-	movq	-208(%rbp), %rsi
-	movl	-116(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rsi, %rax
-	addq	$40, %rax
-	movq	(%rax), %rax
-	.loc 1 137 14
-	addq	%rcx, %rax
-	movq	%rax, -264(%rbp)
-	.loc 1 138 6
-	movq	-264(%rbp), %rax
-	cmpq	-104(%rbp), %rax
-	jbe	.L46
-	.loc 1 138 49 discriminator 1
-	movq	-264(%rbp), %rax
-	movq	%rax, -104(%rbp)
-.L46:
-.LBE8:
-	.loc 1 134 41 discriminator 2
-	addl	$1, -116(%rbp)
-.L44:
-	.loc 1 134 31 discriminator 1
-	movzwl	-456(%rbp), %eax
-	movzwl	%ax, %eax
-	.loc 1 134 2 discriminator 1
-	cmpl	%eax, -116(%rbp)
-	jb	.L47
-.LBE7:
-	.loc 1 141 12
-	movabsq	$93824992239616, %rax
-	movq	%rax, -272(%rbp)
-	.loc 1 147 15
-	movq	-272(%rbp), %rax
-	movl	-172(%rbp), %edx
-	movq	-104(%rbp), %rsi
-	movl	$0, %r9d
-	movl	%edx, %r8d
-	movl	$2, %ecx
-	movl	$0, %edx
-	movq	%rax, %rdi
-	call	mmap@PLT
-	movq	%rax, -280(%rbp)
-	.loc 1 149 5
-	cmpq	$-1, -280(%rbp)
-	jne	.L48
-	.loc 1 149 30 discriminator 1
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movq	-168(%rbp), %rdx
-	leaq	.LC19(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 149 104 discriminator 1
-	movl	$-1, %eax
-	jmp	.L41
-.L48:
-	.loc 1 150 12
-	movq	-280(%rbp), %rax
-	movq	%rax, -288(%rbp)
-	.loc 1 151 12
-	movq	$0, -128(%rbp)
-.LBB9:
-	.loc 1 152 16
-	movl	$0, -132(%rbp)
-	.loc 1 152 2
-	jmp	.L49
-.L56:
-	.loc 1 154 15
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	movl	(%rax), %eax
-	.loc 1 154 6
-	cmpl	$1, %eax
-	jne	.L80
-.LBB10:
-	.loc 1 156 26
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$4, %rax
-	movl	(%rax), %eax
-	.loc 1 156 35
-	andl	$4, %eax
-	.loc 1 156 10
-	testl	%eax, %eax
-	setne	%al
-	movb	%al, -289(%rbp)
-	.loc 1 157 27
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$4, %rax
-	movl	(%rax), %eax
-	.loc 1 157 36
-	andl	$2, %eax
-	.loc 1 157 10
-	testl	%eax, %eax
-	setne	%al
-	movb	%al, -290(%rbp)
-	.loc 1 158 26
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$4, %rax
-	movl	(%rax), %eax
-	.loc 1 158 35
-	andl	$1, %eax
-	.loc 1 158 10
-	testl	%eax, %eax
-	setne	%al
-	movb	%al, -291(%rbp)
-	.loc 1 160 16
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$8, %rax
-	movq	(%rax), %rdx
-	.loc 1 160 32
-	movq	-480(%rbp), %rax
-	.loc 1 160 7
-	cmpq	%rax, %rdx
-	jnb	.L51
-	.loc 1 161 17
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$32, %rax
-	movq	(%rax), %rax
-	.loc 1 161 34
-	movq	-480(%rbp), %rcx
-	.loc 1 161 50
-	movzwl	-456(%rbp), %edx
-	movzwl	%dx, %esi
-	.loc 1 161 65
-	movzwl	-458(%rbp), %edx
-	movzwl	%dx, %edx
-	.loc 1 161 59
-	addl	%esi, %edx
-	movslq	%edx, %rdx
-	.loc 1 161 43
-	addq	%rcx, %rdx
-	.loc 1 161 6
-	cmpq	%rdx, %rax
-	jb	.L51
-	.loc 1 163 38
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$16, %rax
-	movq	(%rax), %rdx
-	.loc 1 163 28
-	movq	-288(%rbp), %rax
-	leaq	(%rdx,%rax), %rdi
-	.loc 1 163 54
-	movq	-480(%rbp), %rcx
-	.loc 1 163 73
-	movq	-208(%rbp), %rsi
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rsi, %rax
-	addq	$8, %rax
-	movq	(%rax), %rax
-	.loc 1 163 63
-	subq	%rax, %rcx
-	movq	%rcx, %rax
-	.loc 1 163 16
-	addq	%rdi, %rax
-	movq	%rax, -128(%rbp)
-.L51:
-	.loc 1 165 10
-	movzbl	-291(%rbp), %r9d
-	movzbl	-290(%rbp), %r8d
-	movzbl	-289(%rbp), %edi
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$32, %rax
-	movq	(%rax), %r11
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$40, %rax
-	movq	(%rax), %r10
-	movq	-208(%rbp), %rcx
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rcx, %rax
-	addq	$8, %rax
-	movq	(%rax), %rcx
-	movq	-208(%rbp), %rsi
-	movl	-132(%rbp), %edx
-	movq	%rdx, %rax
-	salq	$3, %rax
-	subq	%rdx, %rax
-	salq	$3, %rax
-	addq	%rsi, %rax
-	addq	$16, %rax
-	movq	(%rax), %rdx
-	movl	-172(%rbp), %esi
-	movq	-288(%rbp), %rax
-	subq	$8, %rsp
-	pushq	%r9
-	pushq	%r8
-	pushq	%rdi
-	movq	%r11, %r9
-	movq	%r10, %r8
-	movq	%rax, %rdi
-	call	load_one_phdr
-	addq	$32, %rsp
-	movl	%eax, -176(%rbp)
-	.loc 1 167 4
-	cmpl	$1, -176(%rbp)
-	je	.L52
-	cmpl	$2, -176(%rbp)
-	je	.L53
-	cmpl	$0, -176(%rbp)
-	je	.L81
-	jmp	.L78
-.L53:
-	.loc 1 169 18
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movl	-132(%rbp), %ecx
-	movq	-168(%rbp), %rdx
-	leaq	.LC20(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 169 115
-	movl	$-1, %eax
-	jmp	.L41
-.L52:
-	.loc 1 171 18
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movl	-132(%rbp), %edx
-	leaq	.LC21(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 171 98
-	movl	$-1, %eax
-	jmp	.L41
-.L78:
-	.loc 1 174 11
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	movl	-132(%rbp), %edx
-	leaq	.LC22(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 174 107
-	movl	$-1, %eax
-	jmp	.L41
-.L80:
-	.loc 1 177 3
-	nop
-	jmp	.L50
-.L81:
-	.loc 1 172 5
-	nop
-.L50:
-.LBE10:
-	.loc 1 152 41 discriminator 2
-	addl	$1, -132(%rbp)
-.L49:
-	.loc 1 152 31 discriminator 1
-	movzwl	-456(%rbp), %eax
-	movzwl	%ax, %eax
-	.loc 1 152 2 discriminator 1
-	cmpl	%eax, -132(%rbp)
-	jb	.L56
-.LBE9:
-	.loc 1 183 55
-	movq	-488(%rbp), %rdx
-	.loc 1 183 25
-	movq	-288(%rbp), %rax
-	leaq	(%rdx,%rax), %rbx
-	.loc 1 187 14
-	movq	$0, -144(%rbp)
-	.loc 1 188 11
-	movl	$0, -296(%rbp)
-	.loc 1 189 11
-	movl	$0, -148(%rbp)
-.LBB11:
-	.loc 1 190 21
-	movq	p_auxv(%rip), %rax
-	movq	%rax, -160(%rbp)
-	.loc 1 190 2
-	jmp	.L57
-.L76:
-	.loc 1 192 12
-	movq	-160(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 192 3
-	subq	$3, %rax
-	cmpq	$28, %rax
-	ja	.L58
-	leaq	0(,%rax,4), %rdx
-	leaq	.L60(%rip), %rax
-	movl	(%rdx,%rax), %eax
-	cltq
-	leaq	.L60(%rip), %rdx
-	addq	%rdx, %rax
-	jmp	*%rax
-	.section	.rodata
-	.align 4
-	.align 4
-.L60:
-	.long	.L65-.L60
-	.long	.L64-.L60
-	.long	.L63-.L60
-	.long	.L58-.L60
-	.long	.L62-.L60
-	.long	.L58-.L60
-	.long	.L61-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L58-.L60
-	.long	.L59-.L60
-	.text
-.L61:
-	.loc 1 195 8
-	cmpb	$0, -65(%rbp)
-	je	.L66
-	.loc 1 195 43 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	%rbx, 8(%rax)
-.L66:
-	.loc 1 196 55
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 196 5
-	movq	%rax, %rdx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	leaq	.LC23(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 197 5
-	jmp	.L58
-.L65:
-	.loc 1 199 8
-	cmpb	$0, -65(%rbp)
-	je	.L67
-	.loc 1 199 43 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	-128(%rbp), %rdx
-	movq	%rdx, 8(%rax)
-	jmp	.L68
-.L67:
-	.loc 1 200 41
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 200 24
-	movq	%rax, -144(%rbp)
-.L68:
-	.loc 1 201 54
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 201 5
-	movq	%rax, %rdx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	leaq	.LC24(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 202 5
-	jmp	.L58
-.L64:
-	.loc 1 204 8
-	cmpb	$0, -65(%rbp)
-	je	.L69
-	.loc 1 204 49 discriminator 1
-	movzwl	-458(%rbp), %eax
-	movzwl	%ax, %edx
-	.loc 1 204 43 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	%rdx, 8(%rax)
-	jmp	.L70
-.L69:
-	.loc 1 205 37
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 205 28
-	movl	%eax, -296(%rbp)
-.L70:
-	.loc 1 206 55
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 206 5
-	movq	%rax, %rdx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	leaq	.LC25(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 207 5
-	jmp	.L58
-.L63:
-	.loc 1 209 8
-	cmpb	$0, -65(%rbp)
-	je	.L71
-	.loc 1 209 49 discriminator 1
-	movzwl	-456(%rbp), %eax
-	movzwl	%ax, %edx
-	.loc 1 209 43 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	%rdx, 8(%rax)
-	jmp	.L72
-.L71:
-	.loc 1 210 33
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 210 24
-	movl	%eax, -148(%rbp)
-.L72:
-	.loc 1 211 55
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 211 5
-	movq	%rax, %rdx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	leaq	.LC26(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 212 5
-	jmp	.L58
-.L62:
-	.loc 1 214 8
-	cmpb	$0, -65(%rbp)
-	je	.L73
-	.loc 1 214 43 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	$0, 8(%rax)
-	jmp	.L74
-.L73:
-	.loc 1 215 24
-	movq	-160(%rbp), %rax
-	movq	-288(%rbp), %rdx
-	movq	%rdx, 8(%rax)
-.L74:
-	.loc 1 216 54
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 216 5
-	movq	%rax, %rdx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	leaq	.LC27(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 217 5
-	jmp	.L58
-.L59:
-	.loc 1 219 8
-	cmpb	$0, -65(%rbp)
-	je	.L75
-	.loc 1 219 61 discriminator 1
-	movq	-528(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 219 45 discriminator 1
-	movq	%rax, %rdx
-	.loc 1 219 43 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	%rdx, 8(%rax)
-.L75:
-	.loc 1 220 84
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 220 5
-	movq	%rax, %rcx
-	.loc 1 220 61
-	movq	-160(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 1 220 5
-	movq	%rax, %rdx
-	movq	stderr@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	leaq	.LC28(%rip), %rsi
-	movq	%rax, %rdi
-	movl	$0, %eax
-	call	fprintf@PLT
-	.loc 1 221 5
-	nop
-.L58:
-	.loc 1 190 44 discriminator 2
-	addq	$16, -160(%rbp)
-.L57:
-	.loc 1 190 34 discriminator 1
-	movq	-160(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 190 2 discriminator 1
-	testq	%rax, %rax
-	jne	.L76
-.LBE11:
-	.loc 1 225 2
-	movzbl	-65(%rbp), %eax
-	movq	-288(%rbp), %rdi
-	movq	-112(%rbp), %rcx
-	movl	-148(%rbp), %edx
-	movq	-144(%rbp), %rsi
-	movq	%rdi, %r9
-	movq	%rcx, %r8
-	leaq	.LC4(%rip), %rcx
-	movl	%eax, %edi
-	call	cover_tracks@PLT
-	.loc 1 230 2
-	movl	-172(%rbp), %eax
-	movl	%eax, %edi
-	call	close@PLT
-	.loc 1 233 2
-	movq	%rbx, %rax
-	movq	%rax, %rdi
-	call	enter
-.L41:
-	movq	%r12, %rsp
-.L36:
-	movq	%rbx, %rsp
-.L77:
-	.loc 1 234 1 discriminator 3
-	leaq	-40(%rbp), %rsp
-	popq	%rbx
-	popq	%r12
-	popq	%r13
-	popq	%r14
-	popq	%r15
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE6:
-	.size	main, .-main
-.Letext0:
-	.file 2 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
-	.file 3 "/usr/include/x86_64-linux-gnu/bits/types.h"
-	.file 4 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
-	.file 5 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
-	.file 6 "/usr/include/stdio.h"
-	.file 7 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
-	.file 8 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
-	.file 9 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
-	.file 10 "/usr/include/stdint.h"
-	.file 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
-	.file 12 "/usr/include/x86_64-linux-gnu/bits/stat.h"
-	.file 13 "/usr/include/elf.h"
-	.file 14 "/usr/include/unistd.h"
-	.file 15 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
-	.file 16 "/usr/local/src/liballocs/contrib/donald/src/donald.h"
-	.section	.debug_info,"",@progbits
-.Ldebug_info0:
-	.long	0xc8e
-	.value	0x4
-	.long	.Ldebug_abbrev0
-	.byte	0x8
-	.uleb128 0x1
-	.long	.LASF192
-	.byte	0xc
-	.long	.LASF193
-	.long	.LASF194
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.long	.Ldebug_line0
-	.uleb128 0x2
-	.long	.LASF6
-	.byte	0x2
-	.byte	0xd8
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF0
-	.uleb128 0x3
-	.byte	0x4
-	.byte	0x7
-	.long	.LASF1
-	.uleb128 0x4
-	.byte	0x8
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x8
-	.long	.LASF2
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x7
-	.long	.LASF3
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF4
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x5
-	.long	.LASF5
-	.uleb128 0x2
-	.long	.LASF7
-	.byte	0x3
-	.byte	0x27
-	.byte	0x1c
-	.long	0x50
-	.uleb128 0x5
-	.byte	0x4
-	.byte	0x5
-	.string	"int"
-	.uleb128 0x2
-	.long	.LASF8
-	.byte	0x3
-	.byte	0x29
-	.byte	0x16
-	.long	0x40
-	.uleb128 0x2
-	.long	.LASF9
-	.byte	0x3
-	.byte	0x2b
-	.byte	0x19
-	.long	0x90
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF10
-	.uleb128 0x2
-	.long	.LASF11
-	.byte	0x3
-	.byte	0x2c
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF12
-	.byte	0x3
-	.byte	0x8f
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF13
-	.byte	0x3
-	.byte	0x90
-	.byte	0x16
-	.long	0x40
-	.uleb128 0x2
-	.long	.LASF14
-	.byte	0x3
-	.byte	0x91
-	.byte	0x16
-	.long	0x40
-	.uleb128 0x2
-	.long	.LASF15
-	.byte	0x3
-	.byte	0x92
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF16
-	.byte	0x3
-	.byte	0x94
-	.byte	0x16
-	.long	0x40
-	.uleb128 0x2
-	.long	.LASF17
-	.byte	0x3
-	.byte	0x95
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF18
-	.byte	0x3
-	.byte	0x96
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF19
-	.byte	0x3
-	.byte	0x97
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF20
-	.byte	0x3
-	.byte	0x9e
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF21
-	.byte	0x3
-	.byte	0xac
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF22
-	.byte	0x3
-	.byte	0xb1
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF23
-	.byte	0x3
-	.byte	0xbf
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF24
-	.byte	0x3
-	.byte	0xc2
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x145
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF25
-	.uleb128 0x7
-	.long	0x145
-	.uleb128 0x8
-	.long	.LASF73
-	.byte	0xd8
-	.byte	0x4
-	.byte	0x31
-	.byte	0x8
-	.long	0x2d8
-	.uleb128 0x9
-	.long	.LASF26
-	.byte	0x4
-	.byte	0x33
-	.byte	0x7
-	.long	0x71
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF27
-	.byte	0x4
-	.byte	0x36
-	.byte	0x9
-	.long	0x13f
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF28
-	.byte	0x4
-	.byte	0x37
-	.byte	0x9
-	.long	0x13f
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF29
-	.byte	0x4
-	.byte	0x38
-	.byte	0x9
-	.long	0x13f
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF30
-	.byte	0x4
-	.byte	0x39
-	.byte	0x9
-	.long	0x13f
-	.byte	0x20
-	.uleb128 0x9
-	.long	.LASF31
-	.byte	0x4
-	.byte	0x3a
-	.byte	0x9
-	.long	0x13f
-	.byte	0x28
-	.uleb128 0x9
-	.long	.LASF32
-	.byte	0x4
-	.byte	0x3b
-	.byte	0x9
-	.long	0x13f
-	.byte	0x30
-	.uleb128 0x9
-	.long	.LASF33
-	.byte	0x4
-	.byte	0x3c
-	.byte	0x9
-	.long	0x13f
-	.byte	0x38
-	.uleb128 0x9
-	.long	.LASF34
-	.byte	0x4
-	.byte	0x3d
-	.byte	0x9
-	.long	0x13f
-	.byte	0x40
-	.uleb128 0x9
-	.long	.LASF35
-	.byte	0x4
-	.byte	0x40
-	.byte	0x9
-	.long	0x13f
-	.byte	0x48
-	.uleb128 0x9
-	.long	.LASF36
-	.byte	0x4
-	.byte	0x41
-	.byte	0x9
-	.long	0x13f
-	.byte	0x50
-	.uleb128 0x9
-	.long	.LASF37
-	.byte	0x4
-	.byte	0x42
-	.byte	0x9
-	.long	0x13f
-	.byte	0x58
-	.uleb128 0x9
-	.long	.LASF38
-	.byte	0x4
-	.byte	0x44
-	.byte	0x16
-	.long	0x2f1
-	.byte	0x60
-	.uleb128 0x9
-	.long	.LASF39
-	.byte	0x4
-	.byte	0x46
-	.byte	0x14
-	.long	0x2f7
-	.byte	0x68
-	.uleb128 0x9
-	.long	.LASF40
-	.byte	0x4
-	.byte	0x48
-	.byte	0x7
-	.long	0x71
-	.byte	0x70
-	.uleb128 0x9
-	.long	.LASF41
-	.byte	0x4
-	.byte	0x49
-	.byte	0x7
-	.long	0x71
-	.byte	0x74
-	.uleb128 0x9
-	.long	.LASF42
-	.byte	0x4
-	.byte	0x4a
-	.byte	0xb
-	.long	0xeb
-	.byte	0x78
-	.uleb128 0x9
-	.long	.LASF43
-	.byte	0x4
-	.byte	0x4d
-	.byte	0x12
-	.long	0x50
-	.byte	0x80
-	.uleb128 0x9
-	.long	.LASF44
-	.byte	0x4
-	.byte	0x4e
-	.byte	0xf
-	.long	0x57
-	.byte	0x82
-	.uleb128 0x9
-	.long	.LASF45
-	.byte	0x4
-	.byte	0x4f
-	.byte	0x8
-	.long	0x2fd
-	.byte	0x83
-	.uleb128 0x9
-	.long	.LASF46
-	.byte	0x4
-	.byte	0x51
-	.byte	0xf
-	.long	0x30d
-	.byte	0x88
-	.uleb128 0x9
-	.long	.LASF47
-	.byte	0x4
-	.byte	0x59
-	.byte	0xd
-	.long	0xf7
-	.byte	0x90
-	.uleb128 0x9
-	.long	.LASF48
-	.byte	0x4
-	.byte	0x5b
-	.byte	0x17
-	.long	0x318
-	.byte	0x98
-	.uleb128 0x9
-	.long	.LASF49
-	.byte	0x4
-	.byte	0x5c
-	.byte	0x19
-	.long	0x323
-	.byte	0xa0
-	.uleb128 0x9
-	.long	.LASF50
-	.byte	0x4
-	.byte	0x5d
-	.byte	0x14
-	.long	0x2f7
-	.byte	0xa8
-	.uleb128 0x9
-	.long	.LASF51
-	.byte	0x4
-	.byte	0x5e
-	.byte	0x9
-	.long	0x47
-	.byte	0xb0
-	.uleb128 0x9
-	.long	.LASF52
-	.byte	0x4
-	.byte	0x5f
-	.byte	0xa
-	.long	0x2d
-	.byte	0xb8
-	.uleb128 0x9
-	.long	.LASF53
-	.byte	0x4
-	.byte	0x60
-	.byte	0x7
-	.long	0x71
-	.byte	0xc0
-	.uleb128 0x9
-	.long	.LASF54
-	.byte	0x4
-	.byte	0x62
-	.byte	0x8
-	.long	0x329
-	.byte	0xc4
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF55
-	.byte	0x5
-	.byte	0x7
-	.byte	0x19
-	.long	0x151
-	.uleb128 0xa
-	.long	.LASF195
-	.byte	0x4
-	.byte	0x2b
-	.byte	0xe
-	.uleb128 0xb
-	.long	.LASF56
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x2ec
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x151
-	.uleb128 0xc
-	.long	0x145
-	.long	0x30d
-	.uleb128 0xd
-	.long	0x39
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x2e4
-	.uleb128 0xb
-	.long	.LASF57
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x313
-	.uleb128 0xb
-	.long	.LASF58
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x31e
-	.uleb128 0xc
-	.long	0x145
-	.long	0x339
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x13
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x14c
-	.uleb128 0x7
-	.long	0x339
-	.uleb128 0x2
-	.long	.LASF59
-	.byte	0x6
-	.byte	0x3f
-	.byte	0x11
-	.long	0xeb
-	.uleb128 0x2
-	.long	.LASF60
-	.byte	0x6
-	.byte	0x4d
-	.byte	0x13
-	.long	0x127
-	.uleb128 0xe
-	.long	.LASF61
-	.byte	0x6
-	.byte	0x89
-	.byte	0xe
-	.long	0x368
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x2d8
-	.uleb128 0xe
-	.long	.LASF62
-	.byte	0x6
-	.byte	0x8a
-	.byte	0xe
-	.long	0x368
-	.uleb128 0xe
-	.long	.LASF63
-	.byte	0x6
-	.byte	0x8b
-	.byte	0xe
-	.long	0x368
-	.uleb128 0xe
-	.long	.LASF64
-	.byte	0x7
-	.byte	0x1a
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xc
-	.long	0x33f
-	.long	0x39d
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0x7
-	.long	0x392
-	.uleb128 0xe
-	.long	.LASF65
-	.byte	0x7
-	.byte	0x1b
-	.byte	0x1a
-	.long	0x39d
-	.uleb128 0xe
-	.long	.LASF66
-	.byte	0x7
-	.byte	0x1e
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF67
-	.byte	0x7
-	.byte	0x1f
-	.byte	0x1a
-	.long	0x39d
-	.uleb128 0x2
-	.long	.LASF68
-	.byte	0x8
-	.byte	0x1b
-	.byte	0x13
-	.long	0x84
-	.uleb128 0x2
-	.long	.LASF69
-	.byte	0x9
-	.byte	0x19
-	.byte	0x14
-	.long	0x65
-	.uleb128 0x2
-	.long	.LASF70
-	.byte	0x9
-	.byte	0x1a
-	.byte	0x14
-	.long	0x78
-	.uleb128 0x2
-	.long	.LASF71
-	.byte	0x9
-	.byte	0x1b
-	.byte	0x14
-	.long	0x97
-	.uleb128 0x2
-	.long	.LASF72
-	.byte	0xa
-	.byte	0x5a
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x8
-	.long	.LASF74
-	.byte	0x10
-	.byte	0xb
-	.byte	0x9
-	.byte	0x8
-	.long	0x42a
-	.uleb128 0x9
-	.long	.LASF75
-	.byte	0xb
-	.byte	0xb
-	.byte	0xc
-	.long	0x103
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF76
-	.byte	0xb
-	.byte	0xc
-	.byte	0x15
-	.long	0x133
-	.byte	0x8
-	.byte	0
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF77
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF78
-	.uleb128 0x8
-	.long	.LASF79
-	.byte	0x90
-	.byte	0xc
-	.byte	0x2e
-	.byte	0x8
-	.long	0x509
-	.uleb128 0x9
-	.long	.LASF80
-	.byte	0xc
-	.byte	0x30
-	.byte	0xd
-	.long	0xa3
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF81
-	.byte	0xc
-	.byte	0x35
-	.byte	0xd
-	.long	0xc7
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF82
-	.byte	0xc
-	.byte	0x3d
-	.byte	0xf
-	.long	0xdf
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF83
-	.byte	0xc
-	.byte	0x3e
-	.byte	0xe
-	.long	0xd3
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF84
-	.byte	0xc
-	.byte	0x40
-	.byte	0xd
-	.long	0xaf
-	.byte	0x1c
-	.uleb128 0x9
-	.long	.LASF85
-	.byte	0xc
-	.byte	0x41
-	.byte	0xd
-	.long	0xbb
-	.byte	0x20
-	.uleb128 0x9
-	.long	.LASF86
-	.byte	0xc
-	.byte	0x43
-	.byte	0x9
-	.long	0x71
-	.byte	0x24
-	.uleb128 0x9
-	.long	.LASF87
-	.byte	0xc
-	.byte	0x45
-	.byte	0xd
-	.long	0xa3
-	.byte	0x28
-	.uleb128 0x9
-	.long	.LASF88
-	.byte	0xc
-	.byte	0x4a
-	.byte	0xd
-	.long	0xeb
-	.byte	0x30
-	.uleb128 0x9
-	.long	.LASF89
-	.byte	0xc
-	.byte	0x4e
-	.byte	0x11
-	.long	0x10f
-	.byte	0x38
-	.uleb128 0x9
-	.long	.LASF90
-	.byte	0xc
-	.byte	0x50
-	.byte	0x10
-	.long	0x11b
-	.byte	0x40
-	.uleb128 0x9
-	.long	.LASF91
-	.byte	0xc
-	.byte	0x5b
-	.byte	0x15
-	.long	0x402
-	.byte	0x48
-	.uleb128 0x9
-	.long	.LASF92
-	.byte	0xc
-	.byte	0x5c
-	.byte	0x15
-	.long	0x402
-	.byte	0x58
-	.uleb128 0x9
-	.long	.LASF93
-	.byte	0xc
-	.byte	0x5d
-	.byte	0x15
-	.long	0x402
-	.byte	0x68
-	.uleb128 0x9
-	.long	.LASF94
-	.byte	0xc
-	.byte	0x6a
-	.byte	0x17
-	.long	0x509
-	.byte	0x78
-	.byte	0
-	.uleb128 0xc
-	.long	0x133
-	.long	0x519
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x2
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF95
-	.byte	0xd
-	.byte	0x20
-	.byte	0x12
-	.long	0x3d2
-	.uleb128 0x2
-	.long	.LASF96
-	.byte	0xd
-	.byte	0x25
-	.byte	0x12
-	.long	0x3de
-	.uleb128 0x2
-	.long	.LASF97
-	.byte	0xd
-	.byte	0x2b
-	.byte	0x12
-	.long	0x3ea
-	.uleb128 0x2
-	.long	.LASF98
-	.byte	0xd
-	.byte	0x2c
-	.byte	0x11
-	.long	0x3c6
-	.uleb128 0x2
-	.long	.LASF99
-	.byte	0xd
-	.byte	0x30
-	.byte	0x12
-	.long	0x3ea
-	.uleb128 0x2
-	.long	.LASF100
-	.byte	0xd
-	.byte	0x34
-	.byte	0x12
-	.long	0x3ea
-	.uleb128 0xc
-	.long	0x49
-	.long	0x571
-	.uleb128 0xd
-	.long	0x39
-	.byte	0xf
-	.byte	0
-	.uleb128 0x10
-	.byte	0x40
-	.byte	0xd
-	.byte	0x55
-	.byte	0x9
-	.long	0x631
-	.uleb128 0x9
-	.long	.LASF101
-	.byte	0xd
-	.byte	0x57
-	.byte	0x11
-	.long	0x561
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF102
-	.byte	0xd
-	.byte	0x58
-	.byte	0xe
-	.long	0x519
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF103
-	.byte	0xd
-	.byte	0x59
-	.byte	0xe
-	.long	0x519
-	.byte	0x12
-	.uleb128 0x9
-	.long	.LASF104
-	.byte	0xd
-	.byte	0x5a
-	.byte	0xe
-	.long	0x525
-	.byte	0x14
-	.uleb128 0x9
-	.long	.LASF105
-	.byte	0xd
-	.byte	0x5b
-	.byte	0xe
-	.long	0x549
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF106
-	.byte	0xd
-	.byte	0x5c
-	.byte	0xd
-	.long	0x555
-	.byte	0x20
-	.uleb128 0x9
-	.long	.LASF107
-	.byte	0xd
-	.byte	0x5d
-	.byte	0xd
-	.long	0x555
-	.byte	0x28
-	.uleb128 0x9
-	.long	.LASF108
-	.byte	0xd
-	.byte	0x5e
-	.byte	0xe
-	.long	0x525
-	.byte	0x30
-	.uleb128 0x9
-	.long	.LASF109
-	.byte	0xd
-	.byte	0x5f
-	.byte	0xe
-	.long	0x519
-	.byte	0x34
-	.uleb128 0x9
-	.long	.LASF110
-	.byte	0xd
-	.byte	0x60
-	.byte	0xe
-	.long	0x519
-	.byte	0x36
-	.uleb128 0x9
-	.long	.LASF111
-	.byte	0xd
-	.byte	0x61
-	.byte	0xe
-	.long	0x519
-	.byte	0x38
-	.uleb128 0x9
-	.long	.LASF112
-	.byte	0xd
-	.byte	0x62
-	.byte	0xe
-	.long	0x519
-	.byte	0x3a
-	.uleb128 0x9
-	.long	.LASF113
-	.byte	0xd
-	.byte	0x63
-	.byte	0xe
-	.long	0x519
-	.byte	0x3c
-	.uleb128 0x9
-	.long	.LASF114
-	.byte	0xd
-	.byte	0x64
-	.byte	0xe
-	.long	0x519
-	.byte	0x3e
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF115
-	.byte	0xd
-	.byte	0x65
-	.byte	0x3
-	.long	0x571
-	.uleb128 0x11
-	.byte	0x40
-	.byte	0xd
-	.value	0x18e
-	.byte	0x9
-	.long	0x6d4
-	.uleb128 0x12
-	.long	.LASF116
-	.byte	0xd
-	.value	0x190
-	.byte	0xe
-	.long	0x525
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF117
-	.byte	0xd
-	.value	0x191
-	.byte	0xe
-	.long	0x525
-	.byte	0x4
-	.uleb128 0x12
-	.long	.LASF118
-	.byte	0xd
-	.value	0x192
-	.byte	0xf
-	.long	0x531
-	.byte	0x8
-	.uleb128 0x12
-	.long	.LASF119
-	.byte	0xd
-	.value	0x193
-	.byte	0xe
-	.long	0x549
-	.byte	0x10
-	.uleb128 0x12
-	.long	.LASF120
-	.byte	0xd
-	.value	0x194
-	.byte	0xd
-	.long	0x555
-	.byte	0x18
-	.uleb128 0x12
-	.long	.LASF121
-	.byte	0xd
-	.value	0x195
-	.byte	0xf
-	.long	0x531
-	.byte	0x20
-	.uleb128 0x12
-	.long	.LASF122
-	.byte	0xd
-	.value	0x196
-	.byte	0xe
-	.long	0x525
-	.byte	0x28
-	.uleb128 0x12
-	.long	.LASF123
-	.byte	0xd
-	.value	0x197
-	.byte	0xe
-	.long	0x525
-	.byte	0x2c
-	.uleb128 0x12
-	.long	.LASF124
-	.byte	0xd
-	.value	0x198
-	.byte	0xf
-	.long	0x531
-	.byte	0x30
-	.uleb128 0x12
-	.long	.LASF125
-	.byte	0xd
-	.value	0x199
-	.byte	0xf
-	.long	0x531
-	.byte	0x38
-	.byte	0
-	.uleb128 0x13
-	.long	.LASF126
-	.byte	0xd
-	.value	0x19a
-	.byte	0x3
-	.long	0x63d
-	.uleb128 0x11
-	.byte	0x38
-	.byte	0xd
-	.value	0x2b2
-	.byte	0x9
-	.long	0x75c
-	.uleb128 0x12
-	.long	.LASF127
-	.byte	0xd
-	.value	0x2b4
-	.byte	0xe
-	.long	0x525
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF128
-	.byte	0xd
-	.value	0x2b5
-	.byte	0xe
-	.long	0x525
-	.byte	0x4
-	.uleb128 0x12
-	.long	.LASF129
-	.byte	0xd
-	.value	0x2b6
-	.byte	0xd
-	.long	0x555
-	.byte	0x8
-	.uleb128 0x12
-	.long	.LASF130
-	.byte	0xd
-	.value	0x2b7
-	.byte	0xe
-	.long	0x549
-	.byte	0x10
-	.uleb128 0x12
-	.long	.LASF131
-	.byte	0xd
-	.value	0x2b8
-	.byte	0xe
-	.long	0x549
-	.byte	0x18
-	.uleb128 0x12
-	.long	.LASF132
-	.byte	0xd
-	.value	0x2b9
-	.byte	0xf
-	.long	0x531
-	.byte	0x20
-	.uleb128 0x12
-	.long	.LASF133
-	.byte	0xd
-	.value	0x2ba
-	.byte	0xf
-	.long	0x531
-	.byte	0x28
-	.uleb128 0x12
-	.long	.LASF134
-	.byte	0xd
-	.value	0x2bb
-	.byte	0xf
-	.long	0x531
-	.byte	0x30
-	.byte	0
-	.uleb128 0x13
-	.long	.LASF135
-	.byte	0xd
-	.value	0x2bc
-	.byte	0x3
-	.long	0x6e1
-	.uleb128 0x14
-	.byte	0x8
-	.byte	0xd
-	.value	0x340
-	.byte	0x3
-	.long	0x78e
-	.uleb128 0x15
-	.long	.LASF136
-	.byte	0xd
-	.value	0x342
-	.byte	0x13
-	.long	0x531
-	.uleb128 0x15
-	.long	.LASF137
-	.byte	0xd
-	.value	0x343
-	.byte	0x12
-	.long	0x549
-	.byte	0
-	.uleb128 0x11
-	.byte	0x10
-	.byte	0xd
-	.value	0x33d
-	.byte	0x9
-	.long	0x7b5
-	.uleb128 0x12
-	.long	.LASF138
-	.byte	0xd
-	.value	0x33f
-	.byte	0x10
-	.long	0x53d
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF139
-	.byte	0xd
-	.value	0x344
-	.byte	0x7
-	.long	0x769
-	.byte	0x8
-	.byte	0
-	.uleb128 0x13
-	.long	.LASF140
-	.byte	0xd
-	.value	0x345
-	.byte	0x3
-	.long	0x78e
-	.uleb128 0x14
-	.byte	0x8
-	.byte	0xd
-	.value	0x470
-	.byte	0x3
-	.long	0x7da
-	.uleb128 0x15
-	.long	.LASF141
-	.byte	0xd
-	.value	0x472
-	.byte	0x10
-	.long	0x3ea
-	.byte	0
-	.uleb128 0x11
-	.byte	0x10
-	.byte	0xd
-	.value	0x46d
-	.byte	0x9
-	.long	0x801
-	.uleb128 0x12
-	.long	.LASF142
-	.byte	0xd
-	.value	0x46f
-	.byte	0xc
-	.long	0x3ea
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF143
-	.byte	0xd
-	.value	0x476
-	.byte	0x7
-	.long	0x7c2
-	.byte	0x8
-	.byte	0
-	.uleb128 0x13
-	.long	.LASF144
-	.byte	0xd
-	.value	0x477
-	.byte	0x3
-	.long	0x7da
-	.uleb128 0x16
-	.long	.LASF145
-	.byte	0xe
-	.value	0x21f
-	.byte	0xf
-	.long	0x81b
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x13f
-	.uleb128 0x16
-	.long	.LASF146
-	.byte	0xe
-	.value	0x221
-	.byte	0xf
-	.long	0x81b
-	.uleb128 0xe
-	.long	.LASF147
-	.byte	0xf
-	.byte	0x24
-	.byte	0xe
-	.long	0x13f
-	.uleb128 0xe
-	.long	.LASF148
-	.byte	0xf
-	.byte	0x32
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF149
-	.byte	0xf
-	.byte	0x37
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF150
-	.byte	0xf
-	.byte	0x3b
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF151
-	.byte	0x10
-	.byte	0x32
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF152
-	.byte	0x10
-	.byte	0x34
-	.byte	0x13
-	.long	0x876
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x7b5
-	.uleb128 0xe
-	.long	.LASF153
-	.byte	0x10
-	.byte	0x35
-	.byte	0x16
-	.long	0x888
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x801
-	.uleb128 0xe
-	.long	.LASF154
-	.byte	0x10
-	.byte	0x36
-	.byte	0x16
-	.long	0x39
-	.uleb128 0xe
-	.long	.LASF155
-	.byte	0x10
-	.byte	0x37
-	.byte	0xe
-	.long	0x47
-	.uleb128 0xc
-	.long	0x7b5
-	.long	0x8b1
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF156
-	.byte	0x10
-	.byte	0x38
-	.byte	0x12
-	.long	0x8a6
-	.uleb128 0x17
-	.long	.LASF196
-	.byte	0x1
-	.byte	0x1b
-	.byte	0x5
-	.long	0x71
-	.quad	.LFB6
-	.quad	.LFE6-.LFB6
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xc5c
-	.uleb128 0x18
-	.long	.LASF157
-	.byte	0x1
-	.byte	0x1b
-	.byte	0xe
-	.long	0x71
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -532
-	.uleb128 0x18
-	.long	.LASF158
-	.byte	0x1
-	.byte	0x1b
-	.byte	0x1b
-	.long	0x81b
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -544
-	.uleb128 0x19
-	.long	.LASF159
-	.byte	0x1
-	.byte	0x20
-	.byte	0x6
-	.long	0x71
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -100
-	.uleb128 0x19
-	.long	.LASF160
-	.byte	0x1
-	.byte	0x21
-	.byte	0xc
-	.long	0x3f6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -96
-	.uleb128 0x19
-	.long	.LASF161
-	.byte	0x1
-	.byte	0x22
-	.byte	0x8
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -81
-	.uleb128 0x19
-	.long	.LASF162
-	.byte	0x1
-	.byte	0x38
-	.byte	0x6
-	.long	0x71
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -188
-	.uleb128 0x19
-	.long	.LASF163
-	.byte	0x1
-	.byte	0x39
-	.byte	0xe
-	.long	0x438
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -464
-	.uleb128 0x19
-	.long	.LASF164
-	.byte	0x1
-	.byte	0x3a
-	.byte	0xe
-	.long	0x339
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -184
-	.uleb128 0x1a
-	.string	"ret"
-	.byte	0x1
-	.byte	0x44
-	.byte	0x6
-	.long	0x71
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -192
-	.uleb128 0x19
-	.long	.LASF165
-	.byte	0x1
-	.byte	0x48
-	.byte	0xa
-	.long	0x350
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -200
-	.uleb128 0x19
-	.long	.LASF166
-	.byte	0x1
-	.byte	0x49
-	.byte	0xd
-	.long	0x631
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -528
-	.uleb128 0x19
-	.long	.LASF167
-	.byte	0x1
-	.byte	0x4c
-	.byte	0x8
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -67
-	.uleb128 0x19
-	.long	.LASF168
-	.byte	0x1
-	.byte	0x4c
-	.byte	0x14
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -66
-	.uleb128 0x19
-	.long	.LASF169
-	.byte	0x1
-	.byte	0x4c
-	.byte	0x27
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -65
-	.uleb128 0x19
-	.long	.LASF170
-	.byte	0x1
-	.byte	0x4c
-	.byte	0x33
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -101
-	.uleb128 0x19
-	.long	.LASF171
-	.byte	0x1
-	.byte	0x4c
-	.byte	0x43
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -102
-	.uleb128 0x19
-	.long	.LASF172
-	.byte	0x1
-	.byte	0x4d
-	.byte	0x3
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -103
-	.uleb128 0x19
-	.long	.LASF173
-	.byte	0x1
-	.byte	0x68
-	.byte	0x8
-	.long	0x344
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -208
-	.uleb128 0x19
-	.long	.LASF174
-	.byte	0x1
-	.byte	0x69
-	.byte	0xd
-	.long	0xc63
-	.uleb128 0x4
-	.byte	0x91
-	.sleb128 -224
-	.byte	0x6
-	.uleb128 0x19
-	.long	.LASF175
-	.byte	0x1
-	.byte	0x75
-	.byte	0xd
-	.long	0xc77
-	.uleb128 0x4
-	.byte	0x91
-	.sleb128 -256
-	.byte	0x6
-	.uleb128 0x19
-	.long	.LASF176
-	.byte	0x1
-	.byte	0x84
-	.byte	0xd
-	.long	0x549
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -120
-	.uleb128 0x19
-	.long	.LASF177
-	.byte	0x1
-	.byte	0x85
-	.byte	0xc
-	.long	0x3f6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -128
-	.uleb128 0x19
-	.long	.LASF178
-	.byte	0x1
-	.byte	0x8d
-	.byte	0xc
-	.long	0x3f6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -288
-	.uleb128 0x19
-	.long	.LASF179
-	.byte	0x1
-	.byte	0x93
-	.byte	0x8
-	.long	0x47
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -296
-	.uleb128 0x19
-	.long	.LASF180
-	.byte	0x1
-	.byte	0x96
-	.byte	0xc
-	.long	0x3f6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -304
-	.uleb128 0x19
-	.long	.LASF181
-	.byte	0x1
-	.byte	0x97
-	.byte	0xc
-	.long	0x3f6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -144
-	.uleb128 0x19
-	.long	.LASF182
-	.byte	0x1
-	.byte	0xb7
-	.byte	0x19
-	.long	0x39
-	.uleb128 0x1
-	.byte	0x53
-	.uleb128 0x19
-	.long	.LASF183
-	.byte	0x1
-	.byte	0xbb
-	.byte	0xe
-	.long	0xc8b
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -160
-	.uleb128 0x19
-	.long	.LASF184
-	.byte	0x1
-	.byte	0xbc
-	.byte	0xb
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -312
-	.uleb128 0x19
-	.long	.LASF185
-	.byte	0x1
-	.byte	0xbd
-	.byte	0xb
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -164
-	.uleb128 0x1b
-	.quad	.LBB2
-	.quad	.LBE2-.LBB2
-	.long	0xae3
-	.uleb128 0x1a
-	.string	"p"
-	.byte	0x1
-	.byte	0x23
-	.byte	0x15
-	.long	0x888
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.byte	0
-	.uleb128 0x1b
-	.quad	.LBB3
-	.quad	.LBE3-.LBB3
-	.long	0xb39
-	.uleb128 0x1a
-	.string	"i"
-	.byte	0x1
-	.byte	0x6a
-	.byte	0x10
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -108
-	.uleb128 0x1c
-	.quad	.LBB4
-	.quad	.LBE4-.LBB4
-	.uleb128 0x1a
-	.string	"off"
-	.byte	0x1
-	.byte	0x6c
-	.byte	0x9
-	.long	0x344
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -232
-	.uleb128 0x19
-	.long	.LASF186
-	.byte	0x1
-	.byte	0x6f
-	.byte	0xa
-	.long	0x2d
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -240
-	.byte	0
-	.byte	0
-	.uleb128 0x1b
-	.quad	.LBB5
-	.quad	.LBE5-.LBB5
-	.long	0xb8f
-	.uleb128 0x1a
-	.string	"i"
-	.byte	0x1
-	.byte	0x76
-	.byte	0x10
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -112
-	.uleb128 0x1c
-	.quad	.LBB6
-	.quad	.LBE6-.LBB6
-	.uleb128 0x1a
-	.string	"off"
-	.byte	0x1
-	.byte	0x78
-	.byte	0x9
-	.long	0x344
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -264
-	.uleb128 0x19
-	.long	.LASF186
-	.byte	0x1
-	.byte	0x7b
-	.byte	0xa
-	.long	0x2d
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -272
-	.byte	0
-	.byte	0
-	.uleb128 0x1b
-	.quad	.LBB7
-	.quad	.LBE7-.LBB7
-	.long	0xbd5
-	.uleb128 0x1a
-	.string	"i"
-	.byte	0x1
-	.byte	0x86
-	.byte	0x10
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -132
-	.uleb128 0x1c
-	.quad	.LBB8
-	.quad	.LBE8-.LBB8
-	.uleb128 0x19
-	.long	.LASF187
-	.byte	0x1
-	.byte	0x89
-	.byte	0xe
-	.long	0x549
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -280
-	.byte	0
-	.byte	0
-	.uleb128 0x1b
-	.quad	.LBB9
-	.quad	.LBE9-.LBB9
-	.long	0xc3b
-	.uleb128 0x1a
-	.string	"i"
-	.byte	0x1
-	.byte	0x98
-	.byte	0x10
-	.long	0x40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -148
-	.uleb128 0x1c
-	.quad	.LBB10
-	.quad	.LBE10-.LBB10
-	.uleb128 0x19
-	.long	.LASF188
-	.byte	0x1
-	.byte	0x9c
-	.byte	0xa
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -305
-	.uleb128 0x19
-	.long	.LASF189
-	.byte	0x1
-	.byte	0x9d
-	.byte	0xa
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -306
-	.uleb128 0x19
-	.long	.LASF190
-	.byte	0x1
-	.byte	0x9e
-	.byte	0xa
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -307
-	.byte	0
-	.byte	0
-	.uleb128 0x1c
-	.quad	.LBB11
-	.quad	.LBE11-.LBB11
-	.uleb128 0x1a
-	.string	"p"
-	.byte	0x1
-	.byte	0xbe
-	.byte	0x15
-	.long	0x888
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -176
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x2
-	.long	.LASF191
-	.uleb128 0xc
-	.long	0x75c
-	.long	0xc77
-	.uleb128 0x1d
-	.long	0x39
-	.uleb128 0x4
-	.byte	0x91
-	.sleb128 -216
-	.byte	0x6
-	.byte	0
-	.uleb128 0xc
-	.long	0x6d4
-	.long	0xc8b
-	.uleb128 0x1d
-	.long	0x39
-	.uleb128 0x4
-	.byte	0x91
-	.sleb128 -248
-	.byte	0x6
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x75c
-	.byte	0
-	.section	.debug_abbrev,"",@progbits
-.Ldebug_abbrev0:
-	.uleb128 0x1
-	.uleb128 0x11
-	.byte	0x1
-	.uleb128 0x25
-	.uleb128 0xe
-	.uleb128 0x13
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1b
-	.uleb128 0xe
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x10
-	.uleb128 0x17
-	.byte	0
-	.byte	0
-	.uleb128 0x2
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.byte	0
-	.byte	0
-	.uleb128 0x4
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x5
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0x8
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.uleb128 0x26
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x8
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x9
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xa
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0x13
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.uleb128 0x1
-	.byte	0x1
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xd
-	.uleb128 0x21
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2f
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xe
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xf
-	.uleb128 0x21
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x10
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x11
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x12
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x13
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x14
-	.uleb128 0x17
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x15
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x16
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x17
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x18
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x19
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1a
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1b
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x1c
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.byte	0
-	.byte	0
-	.uleb128 0x1d
-	.uleb128 0x21
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2f
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_aranges,"",@progbits
-	.long	0x2c
-	.value	0x2
-	.long	.Ldebug_info0
-	.byte	0x8
-	.byte	0
-	.value	0
-	.value	0
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.quad	0
-	.quad	0
-	.section	.debug_line,"",@progbits
-.Ldebug_line0:
-	.section	.debug_str,"MS",@progbits,1
-.LASF18:
-	.string	"__off_t"
-.LASF14:
-	.string	"__gid_t"
-.LASF5:
-	.string	"short int"
-.LASF124:
-	.string	"sh_addralign"
-.LASF27:
-	.string	"_IO_read_ptr"
-.LASF39:
-	.string	"_chain"
-.LASF93:
-	.string	"st_ctim"
-.LASF130:
-	.string	"p_vaddr"
-.LASF6:
-	.string	"size_t"
-.LASF72:
-	.string	"uintptr_t"
-.LASF144:
-	.string	"Elf64_auxv_t"
-.LASF177:
-	.string	"inferior_dynamic_vaddr"
-.LASF45:
-	.string	"_shortbuf"
-.LASF183:
-	.string	"program_phdrs"
-.LASF100:
-	.string	"Elf64_Off"
-.LASF125:
-	.string	"sh_entsize"
-.LASF60:
-	.string	"ssize_t"
-.LASF139:
-	.string	"d_un"
-.LASF33:
-	.string	"_IO_buf_base"
-.LASF102:
-	.string	"e_type"
-.LASF137:
-	.string	"d_ptr"
-.LASF160:
-	.string	"entry"
-.LASF77:
-	.string	"long long unsigned int"
-.LASF134:
-	.string	"p_align"
-.LASF121:
-	.string	"sh_size"
-.LASF36:
-	.string	"_IO_backup_base"
-.LASF171:
-	.string	"is_sysv_or_gnu"
-.LASF119:
-	.string	"sh_addr"
-.LASF193:
-	.string	"/usr/local/src/liballocs/contrib/donald/src/main.c"
-.LASF181:
-	.string	"phdrs_addr"
-.LASF48:
-	.string	"_codecvt"
-.LASF9:
-	.string	"__int64_t"
-.LASF113:
-	.string	"e_shnum"
-.LASF79:
-	.string	"stat"
-.LASF78:
-	.string	"long long int"
-.LASF4:
-	.string	"signed char"
-.LASF132:
-	.string	"p_filesz"
-.LASF126:
-	.string	"Elf64_Shdr"
-.LASF16:
-	.string	"__mode_t"
-.LASF40:
-	.string	"_fileno"
-.LASF28:
-	.string	"_IO_read_end"
-.LASF22:
-	.string	"__blkcnt_t"
-.LASF10:
-	.string	"long int"
-.LASF26:
-	.string	"_flags"
-.LASF23:
-	.string	"__ssize_t"
-.LASF34:
-	.string	"_IO_buf_end"
-.LASF43:
-	.string	"_cur_column"
-.LASF57:
-	.string	"_IO_codecvt"
-.LASF162:
-	.string	"inferior_fd"
-.LASF143:
-	.string	"a_un"
-.LASF67:
-	.string	"_sys_errlist"
-.LASF42:
-	.string	"_old_offset"
-.LASF47:
-	.string	"_offset"
-.LASF131:
-	.string	"p_paddr"
-.LASF96:
-	.string	"Elf64_Word"
-.LASF129:
-	.string	"p_offset"
-.LASF59:
-	.string	"off_t"
-.LASF8:
-	.string	"__uint32_t"
-.LASF133:
-	.string	"p_memsz"
-.LASF122:
-	.string	"sh_link"
-.LASF90:
-	.string	"st_blocks"
-.LASF84:
-	.string	"st_uid"
-.LASF56:
-	.string	"_IO_marker"
-.LASF61:
-	.string	"stdin"
-.LASF1:
-	.string	"unsigned int"
-.LASF127:
-	.string	"p_type"
-.LASF69:
-	.string	"uint16_t"
-.LASF110:
-	.string	"e_phentsize"
-.LASF74:
-	.string	"timespec"
-.LASF0:
-	.string	"long unsigned int"
-.LASF31:
-	.string	"_IO_write_ptr"
-.LASF159:
-	.string	"argv_program_ind"
-.LASF64:
-	.string	"sys_nerr"
-.LASF116:
-	.string	"sh_name"
-.LASF3:
-	.string	"short unsigned int"
-.LASF97:
-	.string	"Elf64_Xword"
-.LASF35:
-	.string	"_IO_save_base"
-.LASF192:
-	.string	"GNU C99 8.3.0 -mtune=generic -march=x86-64 -g -std=gnu99 -fPIC -fno-stack-protector"
-.LASF146:
-	.string	"environ"
-.LASF46:
-	.string	"_lock"
-.LASF172:
-	.string	"is_exec_or_solib"
-.LASF103:
-	.string	"e_machine"
-.LASF152:
-	.string	"p_dyn"
-.LASF53:
-	.string	"_mode"
-.LASF62:
-	.string	"stdout"
-.LASF88:
-	.string	"st_size"
-.LASF49:
-	.string	"_wide_data"
-.LASF189:
-	.string	"write"
-.LASF136:
-	.string	"d_val"
-.LASF135:
-	.string	"Elf64_Phdr"
-.LASF186:
-	.string	"ntoread"
-.LASF169:
-	.string	"is_lsb"
-.LASF147:
-	.string	"optarg"
-.LASF76:
-	.string	"tv_nsec"
-.LASF153:
-	.string	"p_auxv"
-.LASF109:
-	.string	"e_ehsize"
-.LASF12:
-	.string	"__dev_t"
-.LASF148:
-	.string	"optind"
-.LASF24:
-	.string	"__syscall_slong_t"
-.LASF32:
-	.string	"_IO_write_end"
-.LASF104:
-	.string	"e_version"
-.LASF71:
-	.string	"uint64_t"
-.LASF17:
-	.string	"__nlink_t"
-.LASF174:
-	.string	"phdrs"
-.LASF98:
-	.string	"Elf64_Sxword"
-.LASF156:
-	.string	"_DYNAMIC"
-.LASF195:
-	.string	"_IO_lock_t"
-.LASF73:
-	.string	"_IO_FILE"
-.LASF21:
-	.string	"__blksize_t"
-.LASF145:
-	.string	"__environ"
-.LASF11:
-	.string	"__uint64_t"
-.LASF151:
-	.string	"_begin"
-.LASF141:
-	.string	"a_val"
-.LASF154:
-	.string	"page_size"
-.LASF65:
-	.string	"sys_errlist"
-.LASF182:
-	.string	"entry_point"
-.LASF38:
-	.string	"_markers"
-.LASF163:
-	.string	"inferior_stat"
-.LASF168:
-	.string	"class_matches"
-.LASF185:
-	.string	"program_phnum"
-.LASF94:
-	.string	"__glibc_reserved"
-.LASF179:
-	.string	"base"
-.LASF82:
-	.string	"st_nlink"
-.LASF191:
-	.string	"_Bool"
-.LASF2:
-	.string	"unsigned char"
-.LASF155:
-	.string	"sp_on_entry"
-.LASF107:
-	.string	"e_shoff"
-.LASF81:
-	.string	"st_ino"
-.LASF95:
-	.string	"Elf64_Half"
-.LASF118:
-	.string	"sh_flags"
-.LASF187:
-	.string	"max_vaddr_this_obj"
-.LASF89:
-	.string	"st_blksize"
-.LASF54:
-	.string	"_unused2"
-.LASF123:
-	.string	"sh_info"
-.LASF75:
-	.string	"tv_sec"
-.LASF66:
-	.string	"_sys_nerr"
-.LASF128:
-	.string	"p_flags"
-.LASF101:
-	.string	"e_ident"
-.LASF115:
-	.string	"Elf64_Ehdr"
-.LASF55:
-	.string	"FILE"
-.LASF86:
-	.string	"__pad0"
-.LASF15:
-	.string	"__ino_t"
-.LASF108:
-	.string	"e_flags"
-.LASF150:
-	.string	"optopt"
-.LASF175:
-	.string	"shdrs"
-.LASF70:
-	.string	"uint32_t"
-.LASF165:
-	.string	"nread"
-.LASF173:
-	.string	"newloc"
-.LASF87:
-	.string	"st_rdev"
-.LASF91:
-	.string	"st_atim"
-.LASF25:
-	.string	"char"
-.LASF176:
-	.string	"max_vaddr"
-.LASF106:
-	.string	"e_phoff"
-.LASF166:
-	.string	"ehdr"
-.LASF7:
-	.string	"__uint16_t"
-.LASF117:
-	.string	"sh_type"
-.LASF184:
-	.string	"program_phentsize"
-.LASF112:
-	.string	"e_shentsize"
-.LASF149:
-	.string	"opterr"
-.LASF13:
-	.string	"__uid_t"
-.LASF19:
-	.string	"__off64_t"
-.LASF83:
-	.string	"st_mode"
-.LASF29:
-	.string	"_IO_read_base"
-.LASF37:
-	.string	"_IO_save_end"
-.LASF138:
-	.string	"d_tag"
-.LASF85:
-	.string	"st_gid"
-.LASF167:
-	.string	"is_elf"
-.LASF52:
-	.string	"__pad5"
-.LASF20:
-	.string	"__time_t"
-.LASF164:
-	.string	"inferior_path"
-.LASF99:
-	.string	"Elf64_Addr"
-.LASF63:
-	.string	"stderr"
-.LASF161:
-	.string	"we_are_the_program"
-.LASF158:
-	.string	"argv"
-.LASF140:
-	.string	"Elf64_Dyn"
-.LASF80:
-	.string	"st_dev"
-.LASF51:
-	.string	"_freeres_buf"
-.LASF41:
-	.string	"_flags2"
-.LASF105:
-	.string	"e_entry"
-.LASF178:
-	.string	"base_addr_hint"
-.LASF92:
-	.string	"st_mtim"
-.LASF114:
-	.string	"e_shstrndx"
-.LASF188:
-	.string	"read"
-.LASF44:
-	.string	"_vtable_offset"
-.LASF157:
-	.string	"argc"
-.LASF111:
-	.string	"e_phnum"
-.LASF180:
-	.string	"base_addr"
-.LASF50:
-	.string	"_freeres_list"
-.LASF58:
-	.string	"_IO_wide_data"
-.LASF68:
-	.string	"int64_t"
-.LASF190:
-	.string	"exec"
-.LASF120:
-	.string	"sh_offset"
-.LASF196:
-	.string	"main"
-.LASF30:
-	.string	"_IO_write_base"
-.LASF170:
-	.string	"is_current"
-.LASF142:
-	.string	"a_type"
-.LASF194:
-	.string	"/usr/local/src/liballocs/allocsld"
-	.hidden	enter
-	.hidden	load_one_phdr
-	.hidden	p_auxv
-	.ident	"GCC: (Debian 8.3.0-6) 8.3.0"
-	.section	.note.GNU-stack,"",@progbits
diff --git a/allocsld/premain.s b/allocsld/premain.s
deleted file mode 100644
index 2476c07..0000000
--- a/allocsld/premain.s
+++ /dev/null
@@ -1,3795 +0,0 @@
-	.file	"premain.c"
-	.text
-.Ltext0:
-	.type	auxv_lookup, @function
-auxv_lookup:
-.LFB7:
-	.file 1 "/usr/local/src/liballocs/contrib/libsystrap/contrib/librunt/include/relf.h"
-	.loc 1 279 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	movq	%rdi, -24(%rbp)
-	movq	%rsi, -32(%rbp)
-.LBB38:
-	.loc 1 280 21
-	movq	-24(%rbp), %rax
-	movq	%rax, -8(%rbp)
-	.loc 1 280 2
-	jmp	.L2
-.L5:
-	.loc 1 282 10
-	movq	-8(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 282 6
-	cmpq	%rax, -32(%rbp)
-	jne	.L3
-	.loc 1 284 11
-	movq	-8(%rbp), %rax
-	jmp	.L4
-.L3:
-	.loc 1 280 53 discriminator 2
-	addq	$16, -8(%rbp)
-.L2:
-	.loc 1 280 33 discriminator 1
-	movq	-8(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 1 280 2 discriminator 1
-	testq	%rax, %rax
-	jne	.L5
-.LBE38:
-	.loc 1 287 8
-	movl	$0, %eax
-.L4:
-	.loc 1 288 1
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE7:
-	.size	auxv_lookup, .-auxv_lookup
-	.hidden	environ
-	.comm	environ,8,8
-	.hidden	p_dyn
-	.comm	p_dyn,8,8
-	.hidden	p_auxv
-	.comm	p_auxv,8,8
-	.hidden	page_size
-	.comm	page_size,8,8
-	.globl	__wrap___init_tp
-	.type	__wrap___init_tp, @function
-__wrap___init_tp:
-.LFB65:
-	.file 2 "/usr/local/src/liballocs/contrib/donald/src/premain.c"
-	.loc 2 232 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$16, %rsp
-	movq	%rdi, -8(%rbp)
-	.loc 2 235 2
-	movq	-8(%rbp), %rax
-	movq	%rax, %rdi
-	call	__set_thread_area@PLT
-	.loc 2 241 9
-	movl	$0, %eax
-	.loc 2 242 1
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE65:
-	.size	__wrap___init_tp, .-__wrap___init_tp
-	.globl	__get_from_tls_reg_offset
-	.hidden	__get_from_tls_reg_offset
-	.type	__get_from_tls_reg_offset, @function
-__get_from_tls_reg_offset:
-.LFB66:
-	.loc 2 254 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	movl	%edi, -20(%rbp)
-	.loc 2 257 2
-	movl	-20(%rbp), %eax
-#APP
-# 257 "/usr/local/src/liballocs/contrib/donald/src/premain.c" 1
-	movq %fs:(%eax), %rax
-# 0 "" 2
-#NO_APP
-	movq	%rax, -8(%rbp)
-	.loc 2 263 9
-	movq	-8(%rbp), %rax
-	.loc 2 264 1
-	popq	%rbp
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE66:
-	.size	__get_from_tls_reg_offset, .-__get_from_tls_reg_offset
-	.section	.rodata
-	.align 8
-.LC0:
-	.string	"/usr/local/src/liballocs/contrib/donald/src/premain.c"
-	.align 8
-.LC1:
-	.string	"tp_as_read == tp_as_read_from_itself"
-	.align 8
-.LC2:
-	.string	"sysinfo_as_read == sysinfo_ent->a_un.a_val"
-	.text
-	.type	tls_sanity_check, @function
-tls_sanity_check:
-.LFB67:
-	.loc 2 267 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$32, %rsp
-	.loc 2 270 25
-	movl	$0, %edi
-	call	__get_from_tls_reg_offset
-	movq	%rax, -8(%rbp)
-	.loc 2 271 38
-	movq	-8(%rbp), %rax
-	.loc 2 271 12
-	movq	(%rax), %rax
-	movq	%rax, -16(%rbp)
-	.loc 2 272 33
-	movq	-8(%rbp), %rax
-	cmpq	-16(%rbp), %rax
-	je	.L11
-	.loc 2 272 10 discriminator 1
-	leaq	__PRETTY_FUNCTION__.5026(%rip), %rcx
-	movl	$272, %edx
-	leaq	.LC0(%rip), %rsi
-	leaq	.LC1(%rip), %rdi
-	call	__assert_fail@PLT
-.L11:
-	.loc 2 275 30
-	movq	p_auxv(%rip), %rax
-	movl	$32, %esi
-	movq	%rax, %rdi
-	call	auxv_lookup
-	movq	%rax, -24(%rbp)
-	.loc 2 276 5
-	cmpq	$0, -24(%rbp)
-	je	.L13
-.LBB39:
-	.loc 2 278 31
-	movl	$16, %edi
-	call	__get_from_tls_reg_offset
-	movq	%rax, -32(%rbp)
-	.loc 2 279 38
-	movq	-24(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 279 34
-	cmpq	%rax, -32(%rbp)
-	je	.L13
-	.loc 2 279 11 discriminator 1
-	leaq	__PRETTY_FUNCTION__.5026(%rip), %rcx
-	movl	$279, %edx
-	leaq	.LC0(%rip), %rsi
-	leaq	.LC2(%rip), %rdi
-	call	__assert_fail@PLT
-.L13:
-.LBE39:
-	.loc 2 281 1
-	nop
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE67:
-	.size	tls_sanity_check, .-tls_sanity_check
-	.hidden	sp_on_entry
-	.comm	sp_on_entry,8,8
-	.section	.rodata
-.LC3:
-	.string	"Hello from allocsld!"
-	.text
-	.globl	_start
-	.type	_start, @function
-_start:
-.LFB68:
-	.loc 2 292 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	pushq	%rbx
-	subq	$360, %rsp
-	.cfi_offset 3, -24
-	.loc 2 297 2
-#APP
-# 297 "/usr/local/src/liballocs/contrib/donald/src/premain.c" 1
-	movq %rbp, %rax
-
-# 0 "" 2
-#NO_APP
-	movq	%rax, %rbx
-	.loc 2 306 39
-	leaq	8(%rbx), %rax
-	.loc 2 306 14
-	movq	%rax, sp_on_entry(%rip)
-	.loc 2 307 2
-	movq	sp_on_entry(%rip), %rax
-	movq	%rax, -32(%rbp)
-	leaq	-356(%rbp), %rax
-	movq	%rax, -40(%rbp)
-	leaq	-368(%rbp), %rax
-	movq	%rax, -48(%rbp)
-.LBB40:
-.LBB41:
-	.loc 2 52 13
-	movq	-32(%rbp), %rax
-	movq	%rax, -56(%rbp)
-	.loc 2 53 13
-	movq	-56(%rbp), %rax
-	leaq	8(%rax), %rdx
-	movq	%rdx, -56(%rbp)
-	.loc 2 53 12
-	movl	(%rax), %edx
-	.loc 2 53 10
-	movq	-40(%rbp), %rax
-	movl	%edx, (%rax)
-	.loc 2 54 37
-	movq	-56(%rbp), %rax
-	leaq	8(%rax), %rdx
-	movq	%rdx, -56(%rbp)
-	.loc 2 54 9
-	movq	%rax, -64(%rbp)
-	.loc 2 55 10
-	movq	-48(%rbp), %rax
-	movq	-64(%rbp), %rdx
-	movq	%rdx, (%rax)
-.L15:
-	.loc 2 56 11
-	movq	-56(%rbp), %rax
-	leaq	8(%rax), %rdx
-	movq	%rdx, -56(%rbp)
-	.loc 2 56 9
-	movq	(%rax), %rax
-	.loc 2 56 8
-	testq	%rax, %rax
-	jne	.L15
-	.loc 2 57 37
-	movq	-56(%rbp), %rax
-	leaq	8(%rax), %rdx
-	movq	%rdx, -56(%rbp)
-	.loc 2 57 9
-	movq	%rax, -72(%rbp)
-	.loc 2 58 10
-	movq	-72(%rbp), %rax
-	movq	%rax, environ(%rip)
-.L16:
-	.loc 2 59 11
-	movq	-56(%rbp), %rax
-	leaq	8(%rax), %rdx
-	movq	%rdx, -56(%rbp)
-	.loc 2 59 9
-	movq	(%rax), %rax
-	.loc 2 59 8
-	testq	%rax, %rax
-	jne	.L16
-	.loc 2 60 9
-	movq	-56(%rbp), %rax
-	movq	%rax, -80(%rbp)
-	.loc 2 61 9
-	movq	-80(%rbp), %rax
-	movq	%rax, p_auxv(%rip)
-	.loc 2 63 16
-	movq	p_auxv(%rip), %rax
-	movq	%rax, -88(%rbp)
-	jmp	.L17
-.L19:
-	.loc 2 65 4
-	addq	$16, -88(%rbp)
-.L17:
-	.loc 2 64 19
-	movq	-88(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 64 8
-	testq	%rax, %rax
-	je	.L18
-	.loc 2 64 51
-	movq	-88(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 64 38
-	cmpq	$6, %rax
-	jne	.L19
-.L18:
-	.loc 2 66 16
-	movq	-88(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 66 5
-	cmpq	$6, %rax
-	jne	.L20
-	.loc 2 66 66
-	movq	-88(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 66 48
-	movq	%rax, page_size(%rip)
-.L20:
-	.loc 2 68 17
-	leaq	_begin(%rip), %rax
-	movq	%rax, -96(%rbp)
-	movq	-96(%rbp), %rax
-	movq	%rax, -104(%rbp)
-.LBB42:
-.LBB43:
-	.loc 2 159 46
-	movq	-104(%rbp), %rax
-	.loc 2 159 22
-	movq	_DYNAMIC@GOTPCREL(%rip), %rdx
-	.loc 2 160 6
-	cmpq	%rdx, %rax
-	jbe	.L21
-	.loc 2 159 77
-	movq	-104(%rbp), %rax
-	.loc 2 159 99
-	movq	_DYNAMIC@GOTPCREL(%rip), %rdx
-	.loc 2 159 97
-	addq	%rdx, %rax
-	jmp	.L22
-.L21:
-	.loc 2 160 6
-	movq	_DYNAMIC@GOTPCREL(%rip), %rax
-.L22:
-	.loc 2 159 13
-	movq	%rax, -112(%rbp)
-	.loc 2 161 13
-	movq	$0, -120(%rbp)
-	.loc 2 162 16
-	movq	$0, -128(%rbp)
-	.loc 2 164 8
-	movq	$0, -136(%rbp)
-	.loc 2 165 16
-	movq	$0, -144(%rbp)
-	.loc 2 167 14
-	movq	$0, -152(%rbp)
-	.loc 2 168 16
-	movq	$0, -160(%rbp)
-	.loc 2 169 16
-	movq	$0, -168(%rbp)
-	.loc 2 170 16
-	movq	$0, -176(%rbp)
-	.loc 2 172 13
-	movq	$0, -184(%rbp)
-	.loc 2 173 16
-	movq	$0, -192(%rbp)
-	.loc 2 174 16
-	movq	$0, -200(%rbp)
-	.loc 2 175 16
-	movq	$0, -208(%rbp)
-	.loc 2 177 16
-	movq	$0, -216(%rbp)
-	jmp	.L23
-.L35:
-	.loc 2 180 12
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 180 6
-	cmpq	$6, %rax
-	jne	.L24
-	.loc 2 180 77
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 2 180 46
-	movq	-104(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -120(%rbp)
-	jmp	.L25
-.L24:
-	.loc 2 181 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 181 11
-	cmpq	$11, %rax
-	jne	.L26
-	.loc 2 181 51
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -128(%rbp)
-	jmp	.L25
-.L26:
-	.loc 2 182 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 182 11
-	cmpq	$7, %rax
-	jne	.L27
-	.loc 2 182 83
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 2 182 51
-	movq	-104(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -152(%rbp)
-	jmp	.L25
-.L27:
-	.loc 2 183 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 183 11
-	cmpq	$8, %rax
-	jne	.L28
-	.loc 2 183 50
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -160(%rbp)
-	jmp	.L25
-.L28:
-	.loc 2 184 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 184 11
-	cmpq	$9, %rax
-	jne	.L29
-	.loc 2 184 54
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -168(%rbp)
-	jmp	.L25
-.L29:
-	.loc 2 185 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 185 11
-	cmpq	$17, %rax
-	jne	.L30
-	.loc 2 185 81
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 2 185 49
-	movq	-104(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -184(%rbp)
-	jmp	.L25
-.L30:
-	.loc 2 186 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 186 11
-	cmpq	$18, %rax
-	jne	.L31
-	.loc 2 186 48
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -192(%rbp)
-	jmp	.L25
-.L31:
-	.loc 2 187 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 187 11
-	cmpq	$19, %rax
-	jne	.L32
-	.loc 2 187 52
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -200(%rbp)
-	jmp	.L25
-.L32:
-	.loc 2 188 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 188 11
-	cmpq	$23, %rax
-	jne	.L33
-	.loc 2 188 85
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rdx
-	.loc 2 188 53
-	movq	-104(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -136(%rbp)
-	jmp	.L25
-.L33:
-	.loc 2 189 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 189 11
-	cmpq	$2, %rax
-	jne	.L34
-	.loc 2 189 52
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -144(%rbp)
-	jmp	.L25
-.L34:
-	.loc 2 190 17
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 190 11
-	cmpq	$20, %rax
-	jne	.L25
-	.loc 2 190 45
-	movq	-112(%rbp), %rax
-	movq	8(%rax), %rax
-	movq	%rax, -216(%rbp)
-.L25:
-	.loc 2 191 3
-	addq	$16, -112(%rbp)
-.L23:
-	.loc 2 178 14
-	movq	-112(%rbp), %rax
-	movq	(%rax), %rax
-	.loc 2 178 8
-	testq	%rax, %rax
-	jne	.L35
-	.loc 2 193 5
-	cmpq	$0, -168(%rbp)
-	je	.L36
-	.loc 2 193 41
-	movq	-160(%rbp), %rax
-	movl	$0, %edx
-	divq	-168(%rbp)
-	movq	%rax, -176(%rbp)
-.L36:
-	.loc 2 194 5
-	cmpq	$0, -200(%rbp)
-	je	.L37
-	.loc 2 194 39
-	movq	-192(%rbp), %rax
-	movl	$0, %edx
-	divq	-200(%rbp)
-	movq	%rax, -208(%rbp)
-.L37:
-	.loc 2 195 5
-	cmpq	$0, -168(%rbp)
-	je	.L38
-	.loc 2 195 25
-	cmpq	$0, -200(%rbp)
-	je	.L38
-	.loc 2 195 47
-	call	abort@PLT
-.L38:
-	.loc 2 197 5
-	cmpq	$0, -168(%rbp)
-	je	.L39
-	.loc 2 197 33
-	movq	$7, -224(%rbp)
-	jmp	.L40
-.L39:
-	.loc 2 197 55
-	movq	$17, -224(%rbp)
-.L40:
-.LBB44:
-	.loc 2 207 11
-	movl	$0, -228(%rbp)
-	jmp	.L41
-.L52:
-	.loc 2 209 6
-	cmpq	$17, -224(%rbp)
-	jne	.L42
-	.loc 2 210 34
-	movl	-228(%rbp), %eax
-	cltq
-	salq	$4, %rax
-	movq	%rax, %rdx
-	.loc 2 210 8
-	movq	-184(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -240(%rbp)
-	movq	-104(%rbp), %rax
-	movq	%rax, -248(%rbp)
-	movq	-120(%rbp), %rax
-	movq	%rax, -256(%rbp)
-	jmp	.L43
-.L42:
-	.loc 2 211 35
-	movl	-228(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	.loc 2 211 8
-	movq	-152(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -264(%rbp)
-	movq	-104(%rbp), %rax
-	movq	%rax, -272(%rbp)
-	movq	-120(%rbp), %rax
-	movq	%rax, -280(%rbp)
-.LBB45:
-.LBB46:
-	.loc 2 77 58
-	movq	-264(%rbp), %rax
-	movq	(%rax), %rdx
-	.loc 2 77 14
-	movq	-272(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -288(%rbp)
-	.loc 2 78 15
-	movq	-264(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 78 11
-	movl	%eax, %eax
-	.loc 2 78 2
-	cmpq	$7, %rax
-	ja	.L44
-	cmpq	$6, %rax
-	jnb	.L45
-	cmpq	$1, %rax
-	je	.L46
-	jmp	.L43
-.L44:
-	cmpq	$8, %rax
-	jne	.L43
-	.loc 2 81 47
-	movq	-264(%rbp), %rax
-	movq	16(%rax), %rax
-	movq	%rax, %rdx
-	.loc 2 81 39
-	movq	-272(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 81 18
-	movq	%rax, %rdx
-	.loc 2 81 16
-	movq	-288(%rbp), %rax
-	movq	%rdx, (%rax)
-	jmp	.L43
-.L46:
-	.loc 2 84 47
-	movq	-264(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 84 42
-	shrq	$32, %rax
-	movq	%rax, %rdx
-	.loc 2 84 50
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-280(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 84 41
-	movq	8(%rax), %rdx
-	.loc 2 84 60
-	movq	-264(%rbp), %rax
-	movq	16(%rax), %rax
-	.loc 2 84 52
-	addq	%rax, %rdx
-	movq	-272(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 84 18
-	movq	%rax, %rdx
-	.loc 2 84 16
-	movq	-288(%rbp), %rax
-	movq	%rdx, (%rax)
-	jmp	.L43
-.L45:
-	.loc 2 89 48
-	movq	-264(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 89 43
-	shrq	$32, %rax
-	movq	%rax, %rdx
-	.loc 2 89 51
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-280(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 89 42
-	movq	8(%rax), %rax
-	.loc 2 89 54
-	testq	%rax, %rax
-	jne	.L49
-	.loc 2 89 57
-	movq	-272(%rbp), %rax
-	.loc 2 89 54
-	negq	%rax
-.L49:
-	.loc 2 89 39
-	movq	-272(%rbp), %rdx
-	addq	%rdx, %rax
-	.loc 2 89 18
-	movq	%rax, %rdx
-	.loc 2 89 16
-	movq	-288(%rbp), %rax
-	movq	%rdx, (%rax)
-.L43:
-.LBE46:
-.LBE45:
-	.loc 2 207 76
-	addl	$1, -228(%rbp)
-.L41:
-	.loc 2 207 20
-	movl	-228(%rbp), %eax
-	movslq	%eax, %rdx
-	.loc 2 207 57
-	cmpq	$17, -224(%rbp)
-	jne	.L50
-	movq	-208(%rbp), %rax
-	jmp	.L51
-.L50:
-	movq	-176(%rbp), %rax
-.L51:
-	.loc 2 207 2
-	cmpq	%rax, %rdx
-	jb	.L52
-.LBE44:
-.LBB47:
-	.loc 2 215 11
-	movl	$0, -292(%rbp)
-	jmp	.L53
-.L64:
-	.loc 2 220 6
-	cmpq	$17, -216(%rbp)
-	jne	.L54
-	.loc 2 221 49
-	movl	-292(%rbp), %eax
-	cltq
-	salq	$4, %rax
-	movq	%rax, %rdx
-	.loc 2 221 7
-	movq	-136(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -304(%rbp)
-	movq	-104(%rbp), %rax
-	movq	%rax, -312(%rbp)
-	movq	-120(%rbp), %rax
-	movq	%rax, -320(%rbp)
-	jmp	.L55
-.L54:
-	.loc 2 222 52
-	movl	-292(%rbp), %eax
-	movslq	%eax, %rdx
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	.loc 2 222 8
-	movq	-136(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -328(%rbp)
-	movq	-104(%rbp), %rax
-	movq	%rax, -336(%rbp)
-	movq	-120(%rbp), %rax
-	movq	%rax, -344(%rbp)
-.LBB48:
-.LBB49:
-	.loc 2 77 58
-	movq	-328(%rbp), %rax
-	movq	(%rax), %rdx
-	.loc 2 77 14
-	movq	-336(%rbp), %rax
-	addq	%rdx, %rax
-	movq	%rax, -352(%rbp)
-	.loc 2 78 15
-	movq	-328(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 78 11
-	movl	%eax, %eax
-	.loc 2 78 2
-	cmpq	$7, %rax
-	ja	.L56
-	cmpq	$6, %rax
-	jnb	.L57
-	cmpq	$1, %rax
-	je	.L58
-	jmp	.L55
-.L56:
-	cmpq	$8, %rax
-	jne	.L55
-	.loc 2 81 47
-	movq	-328(%rbp), %rax
-	movq	16(%rax), %rax
-	movq	%rax, %rdx
-	.loc 2 81 39
-	movq	-336(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 81 18
-	movq	%rax, %rdx
-	.loc 2 81 16
-	movq	-352(%rbp), %rax
-	movq	%rdx, (%rax)
-	jmp	.L55
-.L58:
-	.loc 2 84 47
-	movq	-328(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 84 42
-	shrq	$32, %rax
-	movq	%rax, %rdx
-	.loc 2 84 50
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-344(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 84 41
-	movq	8(%rax), %rdx
-	.loc 2 84 60
-	movq	-328(%rbp), %rax
-	movq	16(%rax), %rax
-	.loc 2 84 52
-	addq	%rax, %rdx
-	movq	-336(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 84 18
-	movq	%rax, %rdx
-	.loc 2 84 16
-	movq	-352(%rbp), %rax
-	movq	%rdx, (%rax)
-	jmp	.L55
-.L57:
-	.loc 2 89 48
-	movq	-328(%rbp), %rax
-	movq	8(%rax), %rax
-	.loc 2 89 43
-	shrq	$32, %rax
-	movq	%rax, %rdx
-	.loc 2 89 51
-	movq	%rdx, %rax
-	addq	%rax, %rax
-	addq	%rdx, %rax
-	salq	$3, %rax
-	movq	%rax, %rdx
-	movq	-344(%rbp), %rax
-	addq	%rdx, %rax
-	.loc 2 89 42
-	movq	8(%rax), %rax
-	.loc 2 89 54
-	testq	%rax, %rax
-	jne	.L61
-	.loc 2 89 57
-	movq	-336(%rbp), %rax
-	.loc 2 89 54
-	negq	%rax
-.L61:
-	.loc 2 89 39
-	movq	-336(%rbp), %rdx
-	addq	%rdx, %rax
-	.loc 2 89 18
-	movq	%rax, %rdx
-	.loc 2 89 16
-	movq	-352(%rbp), %rax
-	movq	%rdx, (%rax)
-.L55:
-.LBE49:
-.LBE48:
-	.loc 2 218 4
-	addl	$1, -292(%rbp)
-.L53:
-	.loc 2 216 6
-	movl	-292(%rbp), %eax
-	movslq	%eax, %rcx
-	.loc 2 217 28
-	cmpq	$17, -216(%rbp)
-	jne	.L62
-	movq	-144(%rbp), %rax
-	shrq	$4, %rax
-	jmp	.L63
-.L62:
-	movq	-144(%rbp), %rax
-	movabsq	$-6148914691236517205, %rdx
-	mulq	%rdx
-	movq	%rdx, %rax
-	shrq	$4, %rax
-.L63:
-	.loc 2 215 2
-	cmpq	%rax, %rcx
-	jb	.L64
-.LBE47:
-.LBE43:
-.LBE42:
-.LBE41:
-.LBE40:
-	.loc 2 312 2
-	movq	-368(%rbp), %rax
-	movq	(%rax), %rdx
-	movq	environ(%rip), %rax
-	movq	%rdx, %rsi
-	movq	%rax, %rdi
-	call	__init_libc@PLT
-	.loc 2 313 2
-	call	tls_sanity_check
-	.loc 2 315 2
-	leaq	.LC3(%rip), %rdi
-	call	puts@PLT
-	.loc 2 317 12
-	movq	-368(%rbp), %rdx
-	movl	-356(%rbp), %eax
-	movq	%rdx, %rsi
-	movl	%eax, %edi
-	call	main
-	movl	%eax, -20(%rbp)
-	.loc 2 322 2
-	movl	-20(%rbp), %eax
-	movl	%eax, %esi
-	movl	$60, %edi
-	movl	$0, %eax
-	call	syscall@PLT
-	.cfi_endproc
-.LFE68:
-	.size	_start, .-_start
-	.globl	__GI_exit
-	.type	__GI_exit, @function
-__GI_exit:
-.LFB69:
-	.loc 2 328 1
-	.cfi_startproc
-	pushq	%rbp
-	.cfi_def_cfa_offset 16
-	.cfi_offset 6, -16
-	movq	%rsp, %rbp
-	.cfi_def_cfa_register 6
-	subq	$16, %rsp
-	movl	%edi, -4(%rbp)
-	.loc 2 331 2
-	movl	-4(%rbp), %eax
-	movl	%eax, %esi
-	movl	$60, %edi
-	movl	$0, %eax
-	call	syscall@PLT
-	.loc 2 332 1
-	nop
-	leave
-	.cfi_def_cfa 7, 8
-	ret
-	.cfi_endproc
-.LFE69:
-	.size	__GI_exit, .-__GI_exit
-	.section	.rodata
-	.align 16
-	.type	__PRETTY_FUNCTION__.5026, @object
-	.size	__PRETTY_FUNCTION__.5026, 17
-__PRETTY_FUNCTION__.5026:
-	.string	"tls_sanity_check"
-	.weak	_DYNAMIC
-	.text
-.Letext0:
-	.file 3 "/usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h"
-	.file 4 "/usr/include/x86_64-linux-gnu/bits/types.h"
-	.file 5 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h"
-	.file 6 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
-	.file 7 "/usr/include/stdio.h"
-	.file 8 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h"
-	.file 9 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
-	.file 10 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
-	.file 11 "/usr/include/stdint.h"
-	.file 12 "/usr/include/elf.h"
-	.file 13 "/usr/include/unistd.h"
-	.file 14 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
-	.file 15 "/usr/local/src/liballocs/contrib/donald/src/donald.h"
-	.section	.debug_info,"",@progbits
-.Ldebug_info0:
-	.long	0xd5c
-	.value	0x4
-	.long	.Ldebug_abbrev0
-	.byte	0x8
-	.uleb128 0x1
-	.long	.LASF165
-	.byte	0xc
-	.long	.LASF166
-	.long	.LASF167
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.long	.Ldebug_line0
-	.uleb128 0x2
-	.long	.LASF6
-	.byte	0x3
-	.byte	0xd8
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF0
-	.uleb128 0x3
-	.byte	0x4
-	.byte	0x7
-	.long	.LASF1
-	.uleb128 0x4
-	.byte	0x8
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x8
-	.long	.LASF2
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x7
-	.long	.LASF3
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF4
-	.uleb128 0x3
-	.byte	0x2
-	.byte	0x5
-	.long	.LASF5
-	.uleb128 0x2
-	.long	.LASF7
-	.byte	0x4
-	.byte	0x27
-	.byte	0x1c
-	.long	0x50
-	.uleb128 0x5
-	.byte	0x4
-	.byte	0x5
-	.string	"int"
-	.uleb128 0x2
-	.long	.LASF8
-	.byte	0x4
-	.byte	0x29
-	.byte	0x16
-	.long	0x40
-	.uleb128 0x2
-	.long	.LASF9
-	.byte	0x4
-	.byte	0x2b
-	.byte	0x19
-	.long	0x90
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF10
-	.uleb128 0x2
-	.long	.LASF11
-	.byte	0x4
-	.byte	0x2c
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x2
-	.long	.LASF12
-	.byte	0x4
-	.byte	0x96
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x2
-	.long	.LASF13
-	.byte	0x4
-	.byte	0x97
-	.byte	0x12
-	.long	0x90
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xc1
-	.uleb128 0x3
-	.byte	0x1
-	.byte	0x6
-	.long	.LASF14
-	.uleb128 0x7
-	.long	0xc1
-	.uleb128 0x8
-	.long	.LASF100
-	.byte	0xd8
-	.byte	0x5
-	.byte	0x31
-	.byte	0x8
-	.long	0x254
-	.uleb128 0x9
-	.long	.LASF15
-	.byte	0x5
-	.byte	0x33
-	.byte	0x7
-	.long	0x71
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF16
-	.byte	0x5
-	.byte	0x36
-	.byte	0x9
-	.long	0xbb
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF17
-	.byte	0x5
-	.byte	0x37
-	.byte	0x9
-	.long	0xbb
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF18
-	.byte	0x5
-	.byte	0x38
-	.byte	0x9
-	.long	0xbb
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF19
-	.byte	0x5
-	.byte	0x39
-	.byte	0x9
-	.long	0xbb
-	.byte	0x20
-	.uleb128 0x9
-	.long	.LASF20
-	.byte	0x5
-	.byte	0x3a
-	.byte	0x9
-	.long	0xbb
-	.byte	0x28
-	.uleb128 0x9
-	.long	.LASF21
-	.byte	0x5
-	.byte	0x3b
-	.byte	0x9
-	.long	0xbb
-	.byte	0x30
-	.uleb128 0x9
-	.long	.LASF22
-	.byte	0x5
-	.byte	0x3c
-	.byte	0x9
-	.long	0xbb
-	.byte	0x38
-	.uleb128 0x9
-	.long	.LASF23
-	.byte	0x5
-	.byte	0x3d
-	.byte	0x9
-	.long	0xbb
-	.byte	0x40
-	.uleb128 0x9
-	.long	.LASF24
-	.byte	0x5
-	.byte	0x40
-	.byte	0x9
-	.long	0xbb
-	.byte	0x48
-	.uleb128 0x9
-	.long	.LASF25
-	.byte	0x5
-	.byte	0x41
-	.byte	0x9
-	.long	0xbb
-	.byte	0x50
-	.uleb128 0x9
-	.long	.LASF26
-	.byte	0x5
-	.byte	0x42
-	.byte	0x9
-	.long	0xbb
-	.byte	0x58
-	.uleb128 0x9
-	.long	.LASF27
-	.byte	0x5
-	.byte	0x44
-	.byte	0x16
-	.long	0x26d
-	.byte	0x60
-	.uleb128 0x9
-	.long	.LASF28
-	.byte	0x5
-	.byte	0x46
-	.byte	0x14
-	.long	0x273
-	.byte	0x68
-	.uleb128 0x9
-	.long	.LASF29
-	.byte	0x5
-	.byte	0x48
-	.byte	0x7
-	.long	0x71
-	.byte	0x70
-	.uleb128 0x9
-	.long	.LASF30
-	.byte	0x5
-	.byte	0x49
-	.byte	0x7
-	.long	0x71
-	.byte	0x74
-	.uleb128 0x9
-	.long	.LASF31
-	.byte	0x5
-	.byte	0x4a
-	.byte	0xb
-	.long	0xa3
-	.byte	0x78
-	.uleb128 0x9
-	.long	.LASF32
-	.byte	0x5
-	.byte	0x4d
-	.byte	0x12
-	.long	0x50
-	.byte	0x80
-	.uleb128 0x9
-	.long	.LASF33
-	.byte	0x5
-	.byte	0x4e
-	.byte	0xf
-	.long	0x57
-	.byte	0x82
-	.uleb128 0x9
-	.long	.LASF34
-	.byte	0x5
-	.byte	0x4f
-	.byte	0x8
-	.long	0x279
-	.byte	0x83
-	.uleb128 0x9
-	.long	.LASF35
-	.byte	0x5
-	.byte	0x51
-	.byte	0xf
-	.long	0x289
-	.byte	0x88
-	.uleb128 0x9
-	.long	.LASF36
-	.byte	0x5
-	.byte	0x59
-	.byte	0xd
-	.long	0xaf
-	.byte	0x90
-	.uleb128 0x9
-	.long	.LASF37
-	.byte	0x5
-	.byte	0x5b
-	.byte	0x17
-	.long	0x294
-	.byte	0x98
-	.uleb128 0x9
-	.long	.LASF38
-	.byte	0x5
-	.byte	0x5c
-	.byte	0x19
-	.long	0x29f
-	.byte	0xa0
-	.uleb128 0x9
-	.long	.LASF39
-	.byte	0x5
-	.byte	0x5d
-	.byte	0x14
-	.long	0x273
-	.byte	0xa8
-	.uleb128 0x9
-	.long	.LASF40
-	.byte	0x5
-	.byte	0x5e
-	.byte	0x9
-	.long	0x47
-	.byte	0xb0
-	.uleb128 0x9
-	.long	.LASF41
-	.byte	0x5
-	.byte	0x5f
-	.byte	0xa
-	.long	0x2d
-	.byte	0xb8
-	.uleb128 0x9
-	.long	.LASF42
-	.byte	0x5
-	.byte	0x60
-	.byte	0x7
-	.long	0x71
-	.byte	0xc0
-	.uleb128 0x9
-	.long	.LASF43
-	.byte	0x5
-	.byte	0x62
-	.byte	0x8
-	.long	0x2a5
-	.byte	0xc4
-	.byte	0
-	.uleb128 0x2
-	.long	.LASF44
-	.byte	0x6
-	.byte	0x7
-	.byte	0x19
-	.long	0xcd
-	.uleb128 0xa
-	.long	.LASF168
-	.byte	0x5
-	.byte	0x2b
-	.byte	0xe
-	.uleb128 0xb
-	.long	.LASF45
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x268
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xcd
-	.uleb128 0xc
-	.long	0xc1
-	.long	0x289
-	.uleb128 0xd
-	.long	0x39
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x260
-	.uleb128 0xb
-	.long	.LASF46
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x28f
-	.uleb128 0xb
-	.long	.LASF47
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x29a
-	.uleb128 0xc
-	.long	0xc1
-	.long	0x2b5
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x13
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xc8
-	.uleb128 0x7
-	.long	0x2b5
-	.uleb128 0xe
-	.long	.LASF48
-	.byte	0x7
-	.byte	0x89
-	.byte	0xe
-	.long	0x2cc
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x254
-	.uleb128 0xe
-	.long	.LASF49
-	.byte	0x7
-	.byte	0x8a
-	.byte	0xe
-	.long	0x2cc
-	.uleb128 0xe
-	.long	.LASF50
-	.byte	0x7
-	.byte	0x8b
-	.byte	0xe
-	.long	0x2cc
-	.uleb128 0xe
-	.long	.LASF51
-	.byte	0x8
-	.byte	0x1a
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xc
-	.long	0x2bb
-	.long	0x301
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0x7
-	.long	0x2f6
-	.uleb128 0xe
-	.long	.LASF52
-	.byte	0x8
-	.byte	0x1b
-	.byte	0x1a
-	.long	0x301
-	.uleb128 0xe
-	.long	.LASF53
-	.byte	0x8
-	.byte	0x1e
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF54
-	.byte	0x8
-	.byte	0x1f
-	.byte	0x1a
-	.long	0x301
-	.uleb128 0x2
-	.long	.LASF55
-	.byte	0x9
-	.byte	0x1b
-	.byte	0x13
-	.long	0x84
-	.uleb128 0x2
-	.long	.LASF56
-	.byte	0xa
-	.byte	0x19
-	.byte	0x14
-	.long	0x65
-	.uleb128 0x2
-	.long	.LASF57
-	.byte	0xa
-	.byte	0x1a
-	.byte	0x14
-	.long	0x78
-	.uleb128 0x2
-	.long	.LASF58
-	.byte	0xa
-	.byte	0x1b
-	.byte	0x14
-	.long	0x97
-	.uleb128 0x2
-	.long	.LASF59
-	.byte	0xb
-	.byte	0x5a
-	.byte	0x1b
-	.long	0x39
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x5
-	.long	.LASF60
-	.uleb128 0x3
-	.byte	0x8
-	.byte	0x7
-	.long	.LASF61
-	.uleb128 0x2
-	.long	.LASF62
-	.byte	0xc
-	.byte	0x25
-	.byte	0x12
-	.long	0x342
-	.uleb128 0x2
-	.long	.LASF63
-	.byte	0xc
-	.byte	0x2b
-	.byte	0x12
-	.long	0x34e
-	.uleb128 0x2
-	.long	.LASF64
-	.byte	0xc
-	.byte	0x2c
-	.byte	0x11
-	.long	0x32a
-	.uleb128 0x2
-	.long	.LASF65
-	.byte	0xc
-	.byte	0x30
-	.byte	0x12
-	.long	0x34e
-	.uleb128 0x2
-	.long	.LASF66
-	.byte	0xc
-	.byte	0x38
-	.byte	0x12
-	.long	0x336
-	.uleb128 0x10
-	.byte	0x18
-	.byte	0xc
-	.value	0x210
-	.byte	0x9
-	.long	0x40f
-	.uleb128 0x11
-	.long	.LASF67
-	.byte	0xc
-	.value	0x212
-	.byte	0xe
-	.long	0x374
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF68
-	.byte	0xc
-	.value	0x213
-	.byte	0x11
-	.long	0x49
-	.byte	0x4
-	.uleb128 0x11
-	.long	.LASF69
-	.byte	0xc
-	.value	0x214
-	.byte	0x11
-	.long	0x49
-	.byte	0x5
-	.uleb128 0x11
-	.long	.LASF70
-	.byte	0xc
-	.value	0x215
-	.byte	0x11
-	.long	0x3a4
-	.byte	0x6
-	.uleb128 0x11
-	.long	.LASF71
-	.byte	0xc
-	.value	0x216
-	.byte	0xe
-	.long	0x398
-	.byte	0x8
-	.uleb128 0x11
-	.long	.LASF72
-	.byte	0xc
-	.value	0x217
-	.byte	0xf
-	.long	0x380
-	.byte	0x10
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF73
-	.byte	0xc
-	.value	0x218
-	.byte	0x3
-	.long	0x3b0
-	.uleb128 0x10
-	.byte	0x10
-	.byte	0xc
-	.value	0x284
-	.byte	0x9
-	.long	0x443
-	.uleb128 0x11
-	.long	.LASF74
-	.byte	0xc
-	.value	0x286
-	.byte	0xe
-	.long	0x398
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF75
-	.byte	0xc
-	.value	0x287
-	.byte	0xf
-	.long	0x380
-	.byte	0x8
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF76
-	.byte	0xc
-	.value	0x288
-	.byte	0x3
-	.long	0x41c
-	.uleb128 0x10
-	.byte	0x18
-	.byte	0xc
-	.value	0x293
-	.byte	0x9
-	.long	0x485
-	.uleb128 0x11
-	.long	.LASF74
-	.byte	0xc
-	.value	0x295
-	.byte	0xe
-	.long	0x398
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF75
-	.byte	0xc
-	.value	0x296
-	.byte	0xf
-	.long	0x380
-	.byte	0x8
-	.uleb128 0x11
-	.long	.LASF77
-	.byte	0xc
-	.value	0x297
-	.byte	0x10
-	.long	0x38c
-	.byte	0x10
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF78
-	.byte	0xc
-	.value	0x298
-	.byte	0x3
-	.long	0x450
-	.uleb128 0x13
-	.byte	0x8
-	.byte	0xc
-	.value	0x340
-	.byte	0x3
-	.long	0x4b7
-	.uleb128 0x14
-	.long	.LASF79
-	.byte	0xc
-	.value	0x342
-	.byte	0x13
-	.long	0x380
-	.uleb128 0x14
-	.long	.LASF80
-	.byte	0xc
-	.value	0x343
-	.byte	0x12
-	.long	0x398
-	.byte	0
-	.uleb128 0x10
-	.byte	0x10
-	.byte	0xc
-	.value	0x33d
-	.byte	0x9
-	.long	0x4de
-	.uleb128 0x11
-	.long	.LASF81
-	.byte	0xc
-	.value	0x33f
-	.byte	0x10
-	.long	0x38c
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF82
-	.byte	0xc
-	.value	0x344
-	.byte	0x7
-	.long	0x492
-	.byte	0x8
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF83
-	.byte	0xc
-	.value	0x345
-	.byte	0x3
-	.long	0x4b7
-	.uleb128 0x13
-	.byte	0x8
-	.byte	0xc
-	.value	0x470
-	.byte	0x3
-	.long	0x503
-	.uleb128 0x14
-	.long	.LASF84
-	.byte	0xc
-	.value	0x472
-	.byte	0x10
-	.long	0x34e
-	.byte	0
-	.uleb128 0x10
-	.byte	0x10
-	.byte	0xc
-	.value	0x46d
-	.byte	0x9
-	.long	0x52a
-	.uleb128 0x11
-	.long	.LASF85
-	.byte	0xc
-	.value	0x46f
-	.byte	0xc
-	.long	0x34e
-	.byte	0
-	.uleb128 0x11
-	.long	.LASF86
-	.byte	0xc
-	.value	0x476
-	.byte	0x7
-	.long	0x4eb
-	.byte	0x8
-	.byte	0
-	.uleb128 0x12
-	.long	.LASF87
-	.byte	0xc
-	.value	0x477
-	.byte	0x3
-	.long	0x503
-	.uleb128 0x15
-	.long	.LASF88
-	.byte	0xd
-	.value	0x21f
-	.byte	0xf
-	.long	0x544
-	.uleb128 0x6
-	.byte	0x8
-	.long	0xbb
-	.uleb128 0x15
-	.long	.LASF89
-	.byte	0xd
-	.value	0x221
-	.byte	0xf
-	.long	0x544
-	.uleb128 0xe
-	.long	.LASF90
-	.byte	0xe
-	.byte	0x24
-	.byte	0xe
-	.long	0xbb
-	.uleb128 0xe
-	.long	.LASF91
-	.byte	0xe
-	.byte	0x32
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF92
-	.byte	0xe
-	.byte	0x37
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF93
-	.byte	0xe
-	.byte	0x3b
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF94
-	.byte	0xf
-	.byte	0x32
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF95
-	.byte	0xf
-	.byte	0x34
-	.byte	0x13
-	.long	0x59f
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x4de
-	.uleb128 0xe
-	.long	.LASF96
-	.byte	0xf
-	.byte	0x35
-	.byte	0x16
-	.long	0x5b1
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x52a
-	.uleb128 0xe
-	.long	.LASF97
-	.byte	0xf
-	.byte	0x36
-	.byte	0x16
-	.long	0x39
-	.uleb128 0xe
-	.long	.LASF98
-	.byte	0xf
-	.byte	0x37
-	.byte	0xe
-	.long	0x47
-	.uleb128 0xc
-	.long	0x4de
-	.long	0x5da
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF99
-	.byte	0xf
-	.byte	0x38
-	.byte	0x12
-	.long	0x5cf
-	.uleb128 0x8
-	.long	.LASF101
-	.byte	0x28
-	.byte	0x1
-	.byte	0x6d
-	.byte	0x8
-	.long	0x635
-	.uleb128 0x9
-	.long	.LASF102
-	.byte	0x1
-	.byte	0x6f
-	.byte	0xd
-	.long	0x398
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF103
-	.byte	0x1
-	.byte	0x70
-	.byte	0x8
-	.long	0xbb
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF104
-	.byte	0x1
-	.byte	0x71
-	.byte	0xd
-	.long	0x59f
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF105
-	.byte	0x1
-	.byte	0x72
-	.byte	0x13
-	.long	0x635
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF106
-	.byte	0x1
-	.byte	0x73
-	.byte	0x13
-	.long	0x635
-	.byte	0x20
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x5e6
-	.uleb128 0x16
-	.byte	0x7
-	.byte	0x4
-	.long	0x40
-	.byte	0x1
-	.byte	0x7b
-	.byte	0x7
-	.long	0x65c
-	.uleb128 0x17
-	.long	.LASF107
-	.byte	0
-	.uleb128 0x17
-	.long	.LASF108
-	.byte	0x1
-	.uleb128 0x17
-	.long	.LASF109
-	.byte	0x2
-	.byte	0
-	.uleb128 0x8
-	.long	.LASF110
-	.byte	0x28
-	.byte	0x1
-	.byte	0x75
-	.byte	0x8
-	.long	0x6ab
-	.uleb128 0x9
-	.long	.LASF111
-	.byte	0x1
-	.byte	0x77
-	.byte	0x6
-	.long	0x71
-	.byte	0
-	.uleb128 0x9
-	.long	.LASF112
-	.byte	0x1
-	.byte	0x79
-	.byte	0x13
-	.long	0x635
-	.byte	0x8
-	.uleb128 0x9
-	.long	.LASF113
-	.byte	0x1
-	.byte	0x7a
-	.byte	0xd
-	.long	0x398
-	.byte	0x10
-	.uleb128 0x9
-	.long	.LASF114
-	.byte	0x1
-	.byte	0x7f
-	.byte	0x4
-	.long	0x63b
-	.byte	0x18
-	.uleb128 0x9
-	.long	.LASF115
-	.byte	0x1
-	.byte	0x80
-	.byte	0xd
-	.long	0x398
-	.byte	0x20
-	.byte	0
-	.uleb128 0xe
-	.long	.LASF116
-	.byte	0x1
-	.byte	0x8d
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF117
-	.byte	0x1
-	.byte	0x8e
-	.byte	0xc
-	.long	0x71
-	.uleb128 0xe
-	.long	.LASF118
-	.byte	0x1
-	.byte	0x8f
-	.byte	0x17
-	.long	0x65c
-	.uleb128 0x15
-	.long	.LASF119
-	.byte	0x1
-	.value	0x12c
-	.byte	0xe
-	.long	0x47
-	.uleb128 0x15
-	.long	.LASF120
-	.byte	0x1
-	.value	0x27f
-	.byte	0xc
-	.long	0x71
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x40f
-	.uleb128 0x18
-	.long	0x54a
-	.uleb128 0x9
-	.byte	0x3
-	.quad	environ
-	.uleb128 0x19
-	.long	0x593
-	.byte	0x2
-	.byte	0x20
-	.byte	0xc
-	.uleb128 0x9
-	.byte	0x3
-	.quad	p_dyn
-	.uleb128 0x19
-	.long	0x5a5
-	.byte	0x2
-	.byte	0x21
-	.byte	0xf
-	.uleb128 0x9
-	.byte	0x3
-	.quad	p_auxv
-	.uleb128 0x19
-	.long	0x5b7
-	.byte	0x2
-	.byte	0x22
-	.byte	0xf
-	.uleb128 0x9
-	.byte	0x3
-	.quad	page_size
-	.uleb128 0x1a
-	.long	0x5c3
-	.byte	0x2
-	.value	0x120
-	.byte	0x7
-	.uleb128 0x9
-	.byte	0x3
-	.quad	sp_on_entry
-	.uleb128 0x1b
-	.long	.LASF169
-	.byte	0x2
-	.value	0x147
-	.byte	0x6
-	.quad	.LFB69
-	.quad	.LFE69-.LFB69
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x777
-	.uleb128 0x1c
-	.long	.LASF130
-	.byte	0x2
-	.value	0x147
-	.byte	0x14
-	.long	0x71
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -20
-	.byte	0
-	.uleb128 0x1d
-	.long	.LASF128
-	.byte	0x2
-	.value	0x123
-	.byte	0x5
-	.long	0x71
-	.quad	.LFB68
-	.quad	.LFE68-.LFB68
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0x9f1
-	.uleb128 0x1e
-	.long	.LASF121
-	.byte	0x2
-	.value	0x127
-	.byte	0x1a
-	.long	0x9f1
-	.uleb128 0x1
-	.byte	0x53
-	.uleb128 0x1e
-	.long	.LASF122
-	.byte	0x2
-	.value	0x130
-	.byte	0x6
-	.long	0x71
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -372
-	.uleb128 0x1e
-	.long	.LASF123
-	.byte	0x2
-	.value	0x131
-	.byte	0x9
-	.long	0x544
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -384
-	.uleb128 0x1f
-	.string	"ret"
-	.byte	0x2
-	.value	0x13d
-	.byte	0x6
-	.long	0x71
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -36
-	.uleb128 0x20
-	.long	0xc6f
-	.quad	.LBB40
-	.quad	.LBE40-.LBB40
-	.byte	0x2
-	.value	0x133
-	.byte	0x2
-	.uleb128 0x21
-	.long	0xc94
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -64
-	.uleb128 0x21
-	.long	0xc88
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -56
-	.uleb128 0x21
-	.long	0xc7c
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x22
-	.quad	.LBB41
-	.quad	.LBE41-.LBB41
-	.uleb128 0x23
-	.long	0xca0
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -72
-	.uleb128 0x23
-	.long	0xcaa
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -80
-	.uleb128 0x23
-	.long	0xcb6
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -88
-	.uleb128 0x23
-	.long	0xcc2
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -96
-	.uleb128 0x23
-	.long	0xcce
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -104
-	.uleb128 0x23
-	.long	0xcda
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -112
-	.uleb128 0x24
-	.long	0xb03
-	.quad	.LBB42
-	.quad	.LBE42-.LBB42
-	.byte	0x2
-	.byte	0x45
-	.byte	0x2
-	.uleb128 0x21
-	.long	0xb10
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -120
-	.uleb128 0x22
-	.quad	.LBB43
-	.quad	.LBE43-.LBB43
-	.uleb128 0x23
-	.long	0xb1c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -128
-	.uleb128 0x23
-	.long	0xb28
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -136
-	.uleb128 0x23
-	.long	0xb34
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -144
-	.uleb128 0x23
-	.long	0xb40
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -152
-	.uleb128 0x23
-	.long	0xb4c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -160
-	.uleb128 0x23
-	.long	0xb58
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -168
-	.uleb128 0x23
-	.long	0xb64
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -176
-	.uleb128 0x23
-	.long	0xb70
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -184
-	.uleb128 0x23
-	.long	0xb7c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -192
-	.uleb128 0x23
-	.long	0xb88
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -200
-	.uleb128 0x23
-	.long	0xb94
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -208
-	.uleb128 0x23
-	.long	0xba0
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -216
-	.uleb128 0x23
-	.long	0xbac
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -224
-	.uleb128 0x23
-	.long	0xbb8
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -232
-	.uleb128 0x23
-	.long	0xbc4
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -240
-	.uleb128 0x25
-	.long	0xbd0
-	.quad	.LBB44
-	.quad	.LBE44-.LBB44
-	.long	0x97e
-	.uleb128 0x23
-	.long	0xbd5
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -244
-	.uleb128 0x24
-	.long	0xc2b
-	.quad	.LBB45
-	.quad	.LBE45-.LBB45
-	.byte	0x2
-	.byte	0xd3
-	.byte	0x8
-	.uleb128 0x21
-	.long	0xc50
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -296
-	.uleb128 0x21
-	.long	0xc44
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -288
-	.uleb128 0x21
-	.long	0xc38
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -280
-	.uleb128 0x22
-	.quad	.LBB46
-	.quad	.LBE46-.LBB46
-	.uleb128 0x23
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -304
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x26
-	.long	0xbe0
-	.quad	.LBB47
-	.quad	.LBE47-.LBB47
-	.uleb128 0x23
-	.long	0xbe1
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -308
-	.uleb128 0x24
-	.long	0xc2b
-	.quad	.LBB48
-	.quad	.LBE48-.LBB48
-	.byte	0x2
-	.byte	0xde
-	.byte	0x8
-	.uleb128 0x21
-	.long	0xc50
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -360
-	.uleb128 0x21
-	.long	0xc44
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -352
-	.uleb128 0x21
-	.long	0xc38
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -344
-	.uleb128 0x22
-	.quad	.LBB49
-	.quad	.LBE49-.LBB49
-	.uleb128 0x23
-	.long	0xc5c
-	.uleb128 0x3
-	.byte	0x91
-	.sleb128 -368
-	.byte	0
-	.byte	0
-	.byte	0
-	.byte	0
-	.byte	0
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x49
-	.uleb128 0x27
-	.long	.LASF163
-	.byte	0x2
-	.value	0x10a
-	.byte	0xd
-	.quad	.LFB67
-	.quad	.LFE67-.LFB67
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xa7c
-	.uleb128 0x1e
-	.long	.LASF124
-	.byte	0x2
-	.value	0x10e
-	.byte	0xc
-	.long	0x35a
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.uleb128 0x1e
-	.long	.LASF125
-	.byte	0x2
-	.value	0x10f
-	.byte	0xc
-	.long	0x35a
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -32
-	.uleb128 0x28
-	.long	.LASF170
-	.long	0xa8c
-	.uleb128 0x9
-	.byte	0x3
-	.quad	__PRETTY_FUNCTION__.5026
-	.uleb128 0x1e
-	.long	.LASF126
-	.byte	0x2
-	.value	0x113
-	.byte	0x10
-	.long	0x5b1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x22
-	.quad	.LBB39
-	.quad	.LBE39-.LBB39
-	.uleb128 0x1e
-	.long	.LASF127
-	.byte	0x2
-	.value	0x116
-	.byte	0xd
-	.long	0x35a
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.long	0xc8
-	.long	0xa8c
-	.uleb128 0xd
-	.long	0x39
-	.byte	0x10
-	.byte	0
-	.uleb128 0x7
-	.long	0xa7c
-	.uleb128 0x29
-	.long	.LASF129
-	.byte	0x2
-	.byte	0xfd
-	.byte	0xb
-	.long	0x35a
-	.quad	.LFB66
-	.quad	.LFE66-.LFB66
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xad2
-	.uleb128 0x2a
-	.string	"off"
-	.byte	0x2
-	.byte	0xfd
-	.byte	0x2e
-	.long	0x40
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -36
-	.uleb128 0x2b
-	.long	.LASF131
-	.byte	0x2
-	.byte	0xff
-	.byte	0xc
-	.long	0x35a
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.uleb128 0x2c
-	.long	.LASF132
-	.byte	0x2
-	.byte	0xe7
-	.byte	0x5
-	.long	0x71
-	.quad	.LFB65
-	.quad	.LFE65-.LFB65
-	.uleb128 0x1
-	.byte	0x9c
-	.long	0xb03
-	.uleb128 0x2a
-	.string	"tp"
-	.byte	0x2
-	.byte	0xe7
-	.byte	0x1c
-	.long	0x47
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.uleb128 0x2d
-	.long	.LASF147
-	.byte	0x2
-	.byte	0x9b
-	.byte	0x33
-	.byte	0x3
-	.long	0xbed
-	.uleb128 0x2e
-	.long	.LASF149
-	.byte	0x2
-	.byte	0x9b
-	.byte	0x55
-	.long	0x9f1
-	.uleb128 0x2f
-	.long	.LASF95
-	.byte	0x2
-	.byte	0x9f
-	.byte	0xd
-	.long	0x59f
-	.uleb128 0x2f
-	.long	.LASF133
-	.byte	0x2
-	.byte	0xa1
-	.byte	0xd
-	.long	0x6e9
-	.uleb128 0x2f
-	.long	.LASF134
-	.byte	0x2
-	.byte	0xa2
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF135
-	.byte	0x2
-	.byte	0xa4
-	.byte	0x8
-	.long	0x47
-	.uleb128 0x2f
-	.long	.LASF136
-	.byte	0x2
-	.byte	0xa5
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF137
-	.byte	0x2
-	.byte	0xa7
-	.byte	0xe
-	.long	0xbed
-	.uleb128 0x2f
-	.long	.LASF138
-	.byte	0x2
-	.byte	0xa8
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF139
-	.byte	0x2
-	.byte	0xa9
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF140
-	.byte	0x2
-	.byte	0xaa
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF141
-	.byte	0x2
-	.byte	0xac
-	.byte	0xd
-	.long	0xbf3
-	.uleb128 0x2f
-	.long	.LASF142
-	.byte	0x2
-	.byte	0xad
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF143
-	.byte	0x2
-	.byte	0xae
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF144
-	.byte	0x2
-	.byte	0xaf
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF145
-	.byte	0x2
-	.byte	0xb1
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x2f
-	.long	.LASF146
-	.byte	0x2
-	.byte	0xc4
-	.byte	0x10
-	.long	0x39
-	.uleb128 0x30
-	.long	0xbe0
-	.uleb128 0x31
-	.string	"i"
-	.byte	0x2
-	.byte	0xcf
-	.byte	0xb
-	.long	0x71
-	.byte	0
-	.uleb128 0x32
-	.uleb128 0x31
-	.string	"i"
-	.byte	0x2
-	.byte	0xd7
-	.byte	0xb
-	.long	0x71
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x485
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x443
-	.uleb128 0x2d
-	.long	.LASF148
-	.byte	0x2
-	.byte	0x7c
-	.byte	0x1
-	.byte	0x3
-	.long	0xc2b
-	.uleb128 0x2e
-	.long	.LASF150
-	.byte	0x2
-	.byte	0x7c
-	.byte	0x17
-	.long	0xbf3
-	.uleb128 0x2e
-	.long	.LASF149
-	.byte	0x2
-	.byte	0x7c
-	.byte	0x2d
-	.long	0x9f1
-	.uleb128 0x2e
-	.long	.LASF151
-	.byte	0x2
-	.byte	0x7c
-	.byte	0x41
-	.long	0x6e9
-	.byte	0
-	.uleb128 0x2d
-	.long	.LASF152
-	.byte	0x2
-	.byte	0x49
-	.byte	0x1
-	.byte	0x3
-	.long	0xc69
-	.uleb128 0x2e
-	.long	.LASF153
-	.byte	0x2
-	.byte	0x49
-	.byte	0x19
-	.long	0xbed
-	.uleb128 0x2e
-	.long	.LASF149
-	.byte	0x2
-	.byte	0x49
-	.byte	0x30
-	.long	0x9f1
-	.uleb128 0x2e
-	.long	.LASF151
-	.byte	0x2
-	.byte	0x49
-	.byte	0x44
-	.long	0x6e9
-	.uleb128 0x2f
-	.long	.LASF154
-	.byte	0x2
-	.byte	0x4d
-	.byte	0xe
-	.long	0xc69
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x398
-	.uleb128 0x2d
-	.long	.LASF155
-	.byte	0x2
-	.byte	0x26
-	.byte	0x33
-	.byte	0x3
-	.long	0xce7
-	.uleb128 0x2e
-	.long	.LASF98
-	.byte	0x2
-	.byte	0x26
-	.byte	0x4a
-	.long	0x9f1
-	.uleb128 0x2e
-	.long	.LASF156
-	.byte	0x2
-	.byte	0x27
-	.byte	0x8
-	.long	0xce7
-	.uleb128 0x2e
-	.long	.LASF157
-	.byte	0x2
-	.byte	0x27
-	.byte	0x18
-	.long	0xced
-	.uleb128 0x31
-	.string	"p"
-	.byte	0x2
-	.byte	0x34
-	.byte	0xd
-	.long	0xcf3
-	.uleb128 0x2f
-	.long	.LASF158
-	.byte	0x2
-	.byte	0x36
-	.byte	0x9
-	.long	0x544
-	.uleb128 0x2f
-	.long	.LASF159
-	.byte	0x2
-	.byte	0x39
-	.byte	0x9
-	.long	0x544
-	.uleb128 0x2f
-	.long	.LASF160
-	.byte	0x2
-	.byte	0x3c
-	.byte	0x9
-	.long	0xcf9
-	.uleb128 0x2f
-	.long	.LASF161
-	.byte	0x2
-	.byte	0x3f
-	.byte	0x10
-	.long	0x5b1
-	.uleb128 0x2f
-	.long	.LASF162
-	.byte	0x2
-	.byte	0x44
-	.byte	0x11
-	.long	0x9f1
-	.byte	0
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x71
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x544
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x35a
-	.uleb128 0x6
-	.byte	0x8
-	.long	0x47
-	.uleb128 0x33
-	.long	.LASF164
-	.byte	0x1
-	.value	0x116
-	.byte	0xf
-	.long	0x5b1
-	.quad	.LFB7
-	.quad	.LFE7-.LFB7
-	.uleb128 0x1
-	.byte	0x9c
-	.uleb128 0x34
-	.string	"a"
-	.byte	0x1
-	.value	0x116
-	.byte	0x29
-	.long	0x5b1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -40
-	.uleb128 0x34
-	.string	"tag"
-	.byte	0x1
-	.value	0x116
-	.byte	0x37
-	.long	0x398
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -48
-	.uleb128 0x22
-	.quad	.LBB38
-	.quad	.LBE38-.LBB38
-	.uleb128 0x1f
-	.string	"aux"
-	.byte	0x1
-	.value	0x118
-	.byte	0x15
-	.long	0x5b1
-	.uleb128 0x2
-	.byte	0x91
-	.sleb128 -24
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_abbrev,"",@progbits
-.Ldebug_abbrev0:
-	.uleb128 0x1
-	.uleb128 0x11
-	.byte	0x1
-	.uleb128 0x25
-	.uleb128 0xe
-	.uleb128 0x13
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1b
-	.uleb128 0xe
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x10
-	.uleb128 0x17
-	.byte	0
-	.byte	0
-	.uleb128 0x2
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0xe
-	.byte	0
-	.byte	0
-	.uleb128 0x4
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x5
-	.uleb128 0x24
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0x3
-	.uleb128 0x8
-	.byte	0
-	.byte	0
-	.uleb128 0x6
-	.uleb128 0xf
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x7
-	.uleb128 0x26
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x8
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x9
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xa
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xb
-	.uleb128 0x13
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xc
-	.uleb128 0x1
-	.byte	0x1
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0xd
-	.uleb128 0x21
-	.byte	0
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2f
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0xe
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0xf
-	.uleb128 0x21
-	.byte	0
-	.byte	0
-	.byte	0
-	.uleb128 0x10
-	.uleb128 0x13
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x11
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x38
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x12
-	.uleb128 0x16
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x13
-	.uleb128 0x17
-	.byte	0x1
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x14
-	.uleb128 0xd
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x15
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3c
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x16
-	.uleb128 0x4
-	.byte	0x1
-	.uleb128 0x3e
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x17
-	.uleb128 0x28
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x1c
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x18
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x47
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x19
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x47
-	.uleb128 0x13
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1a
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x47
-	.uleb128 0x13
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1b
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x1c
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1d
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x1e
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x1f
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x20
-	.uleb128 0x1d
-	.byte	0x1
-	.uleb128 0x31
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x58
-	.uleb128 0xb
-	.uleb128 0x59
-	.uleb128 0x5
-	.uleb128 0x57
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x21
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x31
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x22
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.byte	0
-	.byte	0
-	.uleb128 0x23
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x31
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x24
-	.uleb128 0x1d
-	.byte	0x1
-	.uleb128 0x31
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x58
-	.uleb128 0xb
-	.uleb128 0x59
-	.uleb128 0xb
-	.uleb128 0x57
-	.uleb128 0xb
-	.byte	0
-	.byte	0
-	.uleb128 0x25
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x31
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x26
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x31
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.byte	0
-	.byte	0
-	.uleb128 0x27
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x28
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x34
-	.uleb128 0x19
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x29
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2117
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x2a
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x2b
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.uleb128 0x2c
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3f
-	.uleb128 0x19
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2116
-	.uleb128 0x19
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x2d
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x20
-	.uleb128 0xb
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x2e
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x2f
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x30
-	.uleb128 0xb
-	.byte	0x1
-	.uleb128 0x1
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x31
-	.uleb128 0x34
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0xb
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.byte	0
-	.byte	0
-	.uleb128 0x32
-	.uleb128 0xb
-	.byte	0x1
-	.byte	0
-	.byte	0
-	.uleb128 0x33
-	.uleb128 0x2e
-	.byte	0x1
-	.uleb128 0x3
-	.uleb128 0xe
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x27
-	.uleb128 0x19
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x11
-	.uleb128 0x1
-	.uleb128 0x12
-	.uleb128 0x7
-	.uleb128 0x40
-	.uleb128 0x18
-	.uleb128 0x2117
-	.uleb128 0x19
-	.byte	0
-	.byte	0
-	.uleb128 0x34
-	.uleb128 0x5
-	.byte	0
-	.uleb128 0x3
-	.uleb128 0x8
-	.uleb128 0x3a
-	.uleb128 0xb
-	.uleb128 0x3b
-	.uleb128 0x5
-	.uleb128 0x39
-	.uleb128 0xb
-	.uleb128 0x49
-	.uleb128 0x13
-	.uleb128 0x2
-	.uleb128 0x18
-	.byte	0
-	.byte	0
-	.byte	0
-	.section	.debug_aranges,"",@progbits
-	.long	0x2c
-	.value	0x2
-	.long	.Ldebug_info0
-	.byte	0x8
-	.byte	0
-	.value	0
-	.value	0
-	.quad	.Ltext0
-	.quad	.Letext0-.Ltext0
-	.quad	0
-	.quad	0
-	.section	.debug_line,"",@progbits
-.Ldebug_line0:
-	.section	.debug_str,"MS",@progbits,1
-.LASF12:
-	.string	"__off_t"
-.LASF5:
-	.string	"short int"
-.LASF16:
-	.string	"_IO_read_ptr"
-.LASF28:
-	.string	"_chain"
-.LASF124:
-	.string	"tp_as_read"
-.LASF70:
-	.string	"st_shndx"
-.LASF6:
-	.string	"size_t"
-.LASF59:
-	.string	"uintptr_t"
-.LASF87:
-	.string	"Elf64_auxv_t"
-.LASF137:
-	.string	"rela_dyn_start"
-.LASF34:
-	.string	"_shortbuf"
-.LASF68:
-	.string	"st_info"
-.LASF143:
-	.string	"rel_dyn_entsz"
-.LASF18:
-	.string	"_IO_read_base"
-.LASF22:
-	.string	"_IO_buf_base"
-.LASF80:
-	.string	"d_ptr"
-.LASF61:
-	.string	"long long unsigned int"
-.LASF9:
-	.string	"__int64_t"
-.LASF109:
-	.string	"RT_DELETE"
-.LASF127:
-	.string	"sysinfo_as_read"
-.LASF37:
-	.string	"_codecvt"
-.LASF103:
-	.string	"l_name"
-.LASF60:
-	.string	"long long int"
-.LASF4:
-	.string	"signed char"
-.LASF106:
-	.string	"l_prev"
-.LASF170:
-	.string	"__PRETTY_FUNCTION__"
-.LASF29:
-	.string	"_fileno"
-.LASF17:
-	.string	"_IO_read_end"
-.LASF10:
-	.string	"long int"
-.LASF159:
-	.string	"address_of_envp0"
-.LASF15:
-	.string	"_flags"
-.LASF38:
-	.string	"_wide_data"
-.LASF120:
-	.string	"_etext"
-.LASF23:
-	.string	"_IO_buf_end"
-.LASF32:
-	.string	"_cur_column"
-.LASF112:
-	.string	"r_map"
-.LASF46:
-	.string	"_IO_codecvt"
-.LASF75:
-	.string	"r_info"
-.LASF86:
-	.string	"a_un"
-.LASF54:
-	.string	"_sys_errlist"
-.LASF82:
-	.string	"d_un"
-.LASF71:
-	.string	"st_value"
-.LASF31:
-	.string	"_old_offset"
-.LASF36:
-	.string	"_offset"
-.LASF66:
-	.string	"Elf64_Section"
-.LASF132:
-	.string	"__wrap___init_tp"
-.LASF121:
-	.string	"bp_after_main_prologue"
-.LASF154:
-	.string	"reloc_addr"
-.LASF136:
-	.string	"rela_plt_sz"
-.LASF62:
-	.string	"Elf64_Word"
-.LASF162:
-	.string	"base_addr"
-.LASF128:
-	.string	"_start"
-.LASF8:
-	.string	"__uint32_t"
-.LASF149:
-	.string	"at_base"
-.LASF45:
-	.string	"_IO_marker"
-.LASF48:
-	.string	"stdin"
-.LASF1:
-	.string	"unsigned int"
-.LASF160:
-	.string	"address_of_auxv0"
-.LASF0:
-	.string	"long unsigned int"
-.LASF20:
-	.string	"_IO_write_ptr"
-.LASF125:
-	.string	"tp_as_read_from_itself"
-.LASF134:
-	.string	"dynsym_nsyms"
-.LASF51:
-	.string	"sys_nerr"
-.LASF76:
-	.string	"Elf64_Rel"
-.LASF3:
-	.string	"short unsigned int"
-.LASF69:
-	.string	"st_other"
-.LASF133:
-	.string	"dynsym_start"
-.LASF161:
-	.string	"p_pagesize"
-.LASF24:
-	.string	"_IO_save_base"
-.LASF165:
-	.string	"GNU C99 8.3.0 -mtune=generic -march=x86-64 -g -std=gnu99 -fPIC -fno-stack-protector"
-.LASF89:
-	.string	"environ"
-.LASF129:
-	.string	"__get_from_tls_reg_offset"
-.LASF56:
-	.string	"uint16_t"
-.LASF107:
-	.string	"RT_CONSISTENT"
-.LASF35:
-	.string	"_lock"
-.LASF113:
-	.string	"r_brk"
-.LASF95:
-	.string	"p_dyn"
-.LASF42:
-	.string	"_mode"
-.LASF49:
-	.string	"stdout"
-.LASF140:
-	.string	"rela_dyn_nents"
-.LASF148:
-	.string	"do_one_rel"
-.LASF147:
-	.string	"bootstrap_relocate"
-.LASF72:
-	.string	"st_size"
-.LASF108:
-	.string	"RT_ADD"
-.LASF111:
-	.string	"r_version"
-.LASF79:
-	.string	"d_val"
-.LASF145:
-	.string	"pltrel"
-.LASF146:
-	.string	"dynrel"
-.LASF156:
-	.string	"p_argc"
-.LASF90:
-	.string	"optarg"
-.LASF141:
-	.string	"rel_dyn_start"
-.LASF169:
-	.string	"__GI_exit"
-.LASF91:
-	.string	"optind"
-.LASF115:
-	.string	"r_ldbase"
-.LASF131:
-	.string	"word_read"
-.LASF157:
-	.string	"p_argv"
-.LASF21:
-	.string	"_IO_write_end"
-.LASF58:
-	.string	"uint64_t"
-.LASF64:
-	.string	"Elf64_Sxword"
-.LASF135:
-	.string	"rela_plt_start"
-.LASF83:
-	.string	"Elf64_Dyn"
-.LASF168:
-	.string	"_IO_lock_t"
-.LASF100:
-	.string	"_IO_FILE"
-.LASF88:
-	.string	"__environ"
-.LASF11:
-	.string	"__uint64_t"
-.LASF163:
-	.string	"tls_sanity_check"
-.LASF97:
-	.string	"page_size"
-.LASF52:
-	.string	"sys_errlist"
-.LASF139:
-	.string	"rela_dyn_entsz"
-.LASF27:
-	.string	"_markers"
-.LASF116:
-	.string	"_fini"
-.LASF153:
-	.string	"p_rela"
-.LASF94:
-	.string	"_begin"
-.LASF77:
-	.string	"r_addend"
-.LASF155:
-	.string	"preinit"
-.LASF2:
-	.string	"unsigned char"
-.LASF98:
-	.string	"sp_on_entry"
-.LASF150:
-	.string	"p_rel"
-.LASF164:
-	.string	"auxv_lookup"
-.LASF30:
-	.string	"_flags2"
-.LASF43:
-	.string	"_unused2"
-.LASF151:
-	.string	"p_dynsym"
-.LASF53:
-	.string	"_sys_nerr"
-.LASF166:
-	.string	"/usr/local/src/liballocs/contrib/donald/src/premain.c"
-.LASF114:
-	.string	"r_state"
-.LASF44:
-	.string	"FILE"
-.LASF118:
-	.string	"_r_debug"
-.LASF138:
-	.string	"rela_dyn_sz"
-.LASF93:
-	.string	"optopt"
-.LASF57:
-	.string	"uint32_t"
-.LASF158:
-	.string	"address_of_argv0"
-.LASF67:
-	.string	"st_name"
-.LASF126:
-	.string	"sysinfo_ent"
-.LASF117:
-	.string	"_init"
-.LASF14:
-	.string	"char"
-.LASF7:
-	.string	"__uint16_t"
-.LASF167:
-	.string	"/usr/local/src/liballocs/allocsld"
-.LASF92:
-	.string	"opterr"
-.LASF13:
-	.string	"__off64_t"
-.LASF104:
-	.string	"l_ld"
-.LASF26:
-	.string	"_IO_save_end"
-.LASF78:
-	.string	"Elf64_Rela"
-.LASF81:
-	.string	"d_tag"
-.LASF73:
-	.string	"Elf64_Sym"
-.LASF84:
-	.string	"a_val"
-.LASF41:
-	.string	"__pad5"
-.LASF152:
-	.string	"do_one_rela"
-.LASF99:
-	.string	"_DYNAMIC"
-.LASF65:
-	.string	"Elf64_Addr"
-.LASF50:
-	.string	"stderr"
-.LASF96:
-	.string	"p_auxv"
-.LASF102:
-	.string	"l_addr"
-.LASF110:
-	.string	"r_debug"
-.LASF130:
-	.string	"status"
-.LASF40:
-	.string	"_freeres_buf"
-.LASF105:
-	.string	"l_next"
-.LASF63:
-	.string	"Elf64_Xword"
-.LASF25:
-	.string	"_IO_backup_base"
-.LASF144:
-	.string	"rel_dyn_nents"
-.LASF33:
-	.string	"_vtable_offset"
-.LASF122:
-	.string	"argc"
-.LASF39:
-	.string	"_freeres_list"
-.LASF74:
-	.string	"r_offset"
-.LASF101:
-	.string	"link_map"
-.LASF47:
-	.string	"_IO_wide_data"
-.LASF55:
-	.string	"int64_t"
-.LASF142:
-	.string	"rel_dyn_sz"
-.LASF123:
-	.string	"argv"
-.LASF19:
-	.string	"_IO_write_base"
-.LASF119:
-	.string	"__libc_stack_end"
-.LASF85:
-	.string	"a_type"
-	.hidden	main
-	.hidden	_begin
-	.ident	"GCC: (Debian 8.3.0-6) 8.3.0"
-	.section	.note.GNU-stack,"",@progbits
diff --git a/contrib/cil b/contrib/cil
index 73bf4aa..01e71e5 160000
--- a/contrib/cil
+++ b/contrib/cil
@@ -1 +1 @@
-Subproject commit 73bf4aab3ffbb8999171e8d45ca528c1d5b3df43
+Subproject commit 01e71e5f174adf6e0dc14a732c041a1d7906d354
diff --git a/contrib/cil.stamp b/contrib/cil.stamp
deleted file mode 100644
index e69de29..0000000
diff --git a/contrib/libdlbind b/contrib/libdlbind
index 7e3f081..22b88e5 160000
--- a/contrib/libdlbind
+++ b/contrib/libdlbind
@@ -1 +1 @@
-Subproject commit 7e3f081356d1a7236ef3f73279fb11d58ceb9425
+Subproject commit 22b88e5acab1e2baad6b6824c66a9d339b48aa23
diff --git a/include/liballocs.h b/include/liballocs.h
index 4bf4846..3c6ae59 100644
--- a/include/liballocs.h
+++ b/include/liballocs.h
@@ -178,7 +178,7 @@ liballocs_err_t extract_and_output_alloc_site_and_type(
     struct insert *p_ins,
     struct uniqtype **out_type,
     void **out_site
-);
+) __attribute__((visibility("hidden")));
 
 
 /* We define a dladdr that caches stuff. */
@@ -777,14 +777,6 @@ static inline int __liballocs_walk_stack(int (*cb)(void *, void *, void *, void
 		// try to get the bp, but no problem if we don't
 		unw_ret = unw_get_reg(&cursor, UNW_TDEP_BP, &bp); 
 		_Bool got_higherframe_bp __attribute__((unused)) = 0;
-
-		char sym[256]; unw_word_t offset;
-		printf("0x%lx:", ip);
-		if (unw_get_proc_name(&cursor, sym, sizeof(sym), &offset) == 0) {
-			printf(" (%s+0x%lx)\n", sym, offset);
-		} else {
-			printf(" -- error: unable to obtain symbol name for this frame\n");
-		}
 		
 		ret = cb((void*) ip, (void*) sp, (void*) bp, arg);
 		if (ret) return ret;
diff --git a/include/pageindex.h b/include/pageindex.h
index 6404353..2c6622a 100644
--- a/include/pageindex.h
+++ b/include/pageindex.h
@@ -113,19 +113,13 @@ struct big_allocation *__liballocs_split_bigalloc_at_page_boundary(struct big_al
 _Bool __liballocs_delete_all_bigallocs_overlapping_range(const void *begin, const void *end) __attribute__((visibility("hidden")));
 
 struct big_allocation * __liballocs_find_common_parent_bigalloc(const void *ptr, const void *end);
-struct big_allocation *__lookup_bigalloc_under_pageindex(const void *mem, struct allocator *a, void **out_object_start);
-struct big_allocation *__lookup_bigalloc_under(const void *mem, struct allocator *a, struct big_allocation *start, void **out_object_start);
+struct big_allocation *__lookup_bigalloc_under_pageindex(const void *mem, struct allocator *a, void **out_object_start) __attribute__((visibility("hidden")));
+struct big_allocation *__lookup_bigalloc_under(const void *mem, struct allocator *a, struct big_allocation *start, void **out_object_start) __attribute__((visibility("hidden")));
 struct big_allocation *__lookup_bigalloc_under_by_suballocator(const void *mem, struct allocator *sub_a, struct big_allocation *start, void **out_object_start) __attribute__((visibility("hidden")));
 struct big_allocation *__lookup_bigalloc_from_root(const void *mem, struct allocator *a, void **out_object_start);
 struct big_allocation *__lookup_bigalloc_from_root_by_suballocator(const void *mem, struct allocator *sub_a, void **out_object_start);
-struct big_allocation *__lookup_bigalloc_top_level(const void *mem);
+struct big_allocation *__lookup_bigalloc_top_level(const void *mem) __attribute__((visibility("hidden")));
 struct big_allocation *__lookup_deepest_bigalloc(const void *mem) __attribute__((visibility("hidden")));
-struct frame_uniqtype_and_offset pc_to_frame_uniqtype(const void *addr);
-struct frame_uniqtype_and_offset
-{
-	struct uniqtype *u;
-	unsigned o;
-};
 
 struct allocator *__liballocs_get_allocator_upper_bound(const void *obj) __attribute__((visibility("protected")));
 struct allocator *__liballocs_ool_get_allocator(const void *obj) __attribute__((visibility("protected")));
diff --git a/include/uniqtype-bfs.h b/include/uniqtype-bfs.h
index 8ac7773..98f39f3 100644
--- a/include/uniqtype-bfs.h
+++ b/include/uniqtype-bfs.h
@@ -61,9 +61,5 @@ void __uniqtype_process_bfs_queue(
 	follow_ptr_fn *follow_ptr, void *fp_arg,
 	on_blacken_fn *on_blacken, void *ob_arg);
 
-void build_adjacency_list_recursive(
-	__uniqtype_node_rec **p_adj_u_head, __uniqtype_node_rec **p_adj_u_tail, 
-	void *obj_start, struct uniqtype *obj_t, 
-	unsigned long start_offset, struct uniqtype *t_at_offset, 
-	follow_ptr_fn *follow_ptr, void *fp_arg);
+
 #endif
diff --git a/src/allocators/malloc.c b/src/allocators/malloc.c
deleted file mode 100644
index 6061208..0000000
--- a/src/allocators/malloc.c
+++ /dev/null
@@ -1,6284 +0,0 @@
-// /*
-//   This is a version (aka dlmalloc) of malloc/free/realloc written by
-//   Doug Lea and released to the public domain, as explained at
-//   http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
-//   comments, complaints, performance data, etc to dl@cs.oswego.edu
-
-// * Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
-//    Note: There may be an updated version of this malloc obtainable at
-//            ftp://gee.cs.oswego.edu/pub/misc/malloc.c
-//          Check before installing!
-
-// * Quickstart
-
-//   This library is all in one file to simplify the most common usage:
-//   ftp it, compile it (-O3), and link it into another program. All of
-//   the compile-time options default to reasonable values for use on
-//   most platforms.  You might later want to step through various
-//   compile-time and dynamic tuning options.
-
-//   For convenience, an include file for code using this malloc is at:
-//      ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.6.h
-//   You don't really need this .h file unless you call functions not
-//   defined in your system include files.  The .h file contains only the
-//   excerpts from this file needed for using this malloc on ANSI C/C++
-//   systems, so long as you haven't changed compile-time options about
-//   naming and tuning parameters.  If you do, then you can create your
-//   own malloc.h that does include all settings by cutting at the point
-//   indicated below. Note that you may already by default be using a C
-//   library containing a malloc that is based on some version of this
-//   malloc (for example in linux). You might still want to use the one
-//   in this file to customize settings or to avoid overheads associated
-//   with library versions.
-
-// * Vital statistics:
-
-//   Supported pointer/size_t representation:       4 or 8 bytes
-//        size_t MUST be an unsigned type of the same width as
-//        pointers. (If you are using an ancient system that declares
-//        size_t as a signed type, or need it to be a different width
-//        than pointers, you can use a previous release of this malloc
-//        (e.g. 2.7.2) supporting these.)
-
-//   Alignment:                                     8 bytes (minimum)
-//        This suffices for nearly all current machines and C compilers.
-//        However, you can define MALLOC_ALIGNMENT to be wider than this
-//        if necessary (up to 128bytes), at the expense of using more space.
-
-//   Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)
-//                                           8 or 16 bytes (if 8byte sizes)
-//        Each malloced chunk has a hidden word of overhead holding size
-//        and status information, and additional cross-check word
-//        if FOOTERS is defined.
-
-//   Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)
-//                           8-byte ptrs:  32 bytes    (including overhead)
-
-//        Even a request for zero bytes (i.e., malloc(0)) returns a
-//        pointer to something of the minimum allocatable size.
-//        The maximum overhead wastage (i.e., number of extra bytes
-//        allocated than were requested in malloc) is less than or equal
-//        to the minimum size, except for requests >= mmap_threshold that
-//        are serviced via mmap(), where the worst case wastage is about
-//        32 bytes plus the remainder from a system page (the minimal
-//        mmap unit); typically 4096 or 8192 bytes.
-
-//   Security: static-safe; optionally more or less
-//        The "security" of malloc refers to the ability of malicious
-//        code to accentuate the effects of errors (for example, freeing
-//        space that is not currently malloc'ed or overwriting past the
-//        ends of chunks) in code that calls malloc.  This malloc
-//        guarantees not to modify any memory locations below the base of
-//        heap, i.e., static variables, even in the presence of usage
-//        errors.  The routines additionally detect most improper frees
-//        and reallocs.  All this holds as long as the static bookkeeping
-//        for malloc itself is not corrupted by some other means.  This
-//        is only one aspect of security -- these checks do not, and
-//        cannot, detect all possible programming errors.
-
-//        If FOOTERS is defined nonzero, then each allocated chunk
-//        carries an additional check word to verify that it was malloced
-//        from its space.  These check words are the same within each
-//        execution of a program using malloc, but differ across
-//        executions, so externally crafted fake chunks cannot be
-//        freed. This improves security by rejecting frees/reallocs that
-//        could corrupt heap memory, in addition to the checks preventing
-//        writes to statics that are always on.  This may further improve
-//        security at the expense of time and space overhead.  (Note that
-//        FOOTERS may also be worth using with MSPACES.)
-
-//        By default detected errors cause the program to abort (calling
-//        "abort()"). You can override this to instead proceed past
-//        errors by defining PROCEED_ON_ERROR.  In this case, a bad free
-//        has no effect, and a malloc that encounters a bad address
-//        caused by user overwrites will ignore the bad address by
-//        dropping pointers and indices to all known memory. This may
-//        be appropriate for programs that should continue if at all
-//        possible in the face of programming errors, although they may
-//        run out of memory because dropped memory is never reclaimed.
-
-//        If you don't like either of these options, you can define
-//        CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything
-//        else. And if if you are sure that your program using malloc has
-//        no errors or vulnerabilities, you can define INSECURE to 1,
-//        which might (or might not) provide a small performance improvement.
-
-//        It is also possible to limit the maximum total allocatable
-//        space, using malloc_set_footprint_limit. This is not
-//        designed as a security feature in itself (calls to set limits
-//        are not screened or privileged), but may be useful as one
-//        aspect of a secure implementation.
-
-//   Thread-safety: NOT thread-safe unless USE_LOCKS defined non-zero
-//        When USE_LOCKS is defined, each public call to malloc, free,
-//        etc is surrounded with a lock. By default, this uses a plain
-//        pthread mutex, win32 critical section, or a spin-lock if if
-//        available for the platform and not disabled by setting
-//        USE_SPIN_LOCKS=0.  However, if USE_RECURSIVE_LOCKS is defined,
-//        recursive versions are used instead (which are not required for
-//        base functionality but may be needed in layered extensions).
-//        Using a global lock is not especially fast, and can be a major
-//        bottleneck.  It is designed only to provide minimal protection
-//        in concurrent environments, and to provide a basis for
-//        extensions.  If you are using malloc in a concurrent program,
-//        consider instead using nedmalloc
-//        (http://www.nedprod.com/programs/portable/nedmalloc/) or
-//        ptmalloc (See http://www.malloc.de), which are derived from
-//        versions of this malloc.
-
-//   System requirements: Any combination of MORECORE and/or MMAP/MUNMAP
-//        This malloc can use unix sbrk or any emulation (invoked using
-//        the CALL_MORECORE macro) and/or mmap/munmap or any emulation
-//        (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system
-//        memory.  On most unix systems, it tends to work best if both
-//        MORECORE and MMAP are enabled.  On Win32, it uses emulations
-//        based on VirtualAlloc. It also uses common C library functions
-//        like memset.
-
-//   Compliance: I believe it is compliant with the Single Unix Specification
-//        (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably
-//        others as well.
-
-// * Overview of algorithms
-
-//   This is not the fastest, most space-conserving, most portable, or
-//   most tunable malloc ever written. However it is among the fastest
-//   while also being among the most space-conserving, portable and
-//   tunable.  Consistent balance across these factors results in a good
-//   general-purpose allocator for malloc-intensive programs.
-
-//   In most ways, this malloc is a best-fit allocator. Generally, it
-//   chooses the best-fitting existing chunk for a request, with ties
-//   broken in approximately least-recently-used order. (This strategy
-//   normally maintains low fragmentation.) However, for requests less
-//   than 256bytes, it deviates from best-fit when there is not an
-//   exactly fitting available chunk by preferring to use space adjacent
-//   to that used for the previous small request, as well as by breaking
-//   ties in approximately most-recently-used order. (These enhance
-//   locality of series of small allocations.)  And for very large requests
-//   (>= 256Kb by default), it relies on system memory mapping
-//   facilities, if supported.  (This helps avoid carrying around and
-//   possibly fragmenting memory used only for large chunks.)
-
-//   All operations (except malloc_stats and mallinfo) have execution
-//   times that are bounded by a constant factor of the number of bits in
-//   a size_t, not counting any clearing in calloc or copying in realloc,
-//   or actions surrounding MORECORE and MMAP that have times
-//   proportional to the number of non-contiguous regions returned by
-//   system allocation routines, which is often just 1. In real-time
-//   applications, you can optionally suppress segment traversals using
-//   NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
-//   system allocators return non-contiguous spaces, at the typical
-//   expense of carrying around more memory and increased fragmentation.
-
-//   The implementation is not very modular and seriously overuses
-//   macros. Perhaps someday all C compilers will do as good a job
-//   inlining modular code as can now be done by brute-force expansion,
-//   but now, enough of them seem not to.
-
-//   Some compilers issue a lot of warnings about code that is
-//   dead/unreachable only on some platforms, and also about intentional
-//   uses of negation on unsigned types. All known cases of each can be
-//   ignored.
-
-//   For a longer but out of date high-level description, see
-//      http://gee.cs.oswego.edu/dl/html/malloc.html
-
-// * MSPACES
-//   If MSPACES is defined, then in addition to malloc, free, etc.,
-//   this file also defines mspace_malloc, mspace_free, etc. These
-//   are versions of malloc routines that take an "mspace" argument
-//   obtained using create_mspace, to control all internal bookkeeping.
-//   If ONLY_MSPACES is defined, only these versions are compiled.
-//   So if you would like to use this allocator for only some allocations,
-//   and your system malloc for others, you can compile with
-//   ONLY_MSPACES and then do something like...
-//     static mspace mymspace = create_mspace(0,0); // for example
-//     #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)
-
-//   (Note: If you only need one instance of an mspace, you can instead
-//   use "USE_DL_PREFIX" to relabel the global malloc.)
-
-//   You can similarly create thread-local allocators by storing
-//   mspaces as thread-locals. For example:
-//     static __thread mspace tlms = 0;
-//     void*  tlmalloc(size_t bytes) {
-//       if (tlms == 0) tlms = create_mspace(0, 0);
-//       return mspace_malloc(tlms, bytes);
-//     }
-//     void  tlfree(void* mem) { mspace_free(tlms, mem); }
-
-//   Unless FOOTERS is defined, each mspace is completely independent.
-//   You cannot allocate from one and free to another (although
-//   conformance is only weakly checked, so usage errors are not always
-//   caught). If FOOTERS is defined, then each chunk carries around a tag
-//   indicating its originating mspace, and frees are directed to their
-//   originating spaces. Normally, this requires use of locks.
-
-//  -------------------------  Compile-time options ---------------------------
-
-// Be careful in setting #define values for numerical constants of type
-// size_t. On some systems, literal values are not automatically extended
-// to size_t precision unless they are explicitly casted. You can also
-// use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.
-
-// WIN32                    default: defined if _WIN32 defined
-//   Defining WIN32 sets up defaults for MS environment and compilers.
-//   Otherwise defaults are for unix. Beware that there seem to be some
-//   cases where this malloc might not be a pure drop-in replacement for
-//   Win32 malloc: Random-looking failures from Win32 GDI API's (eg;
-//   SetDIBits()) may be due to bugs in some video driver implementations
-//   when pixel buffers are malloc()ed, and the region spans more than
-//   one VirtualAlloc()ed region. Because dlmalloc uses a small (64Kb)
-//   default granularity, pixel buffers may straddle virtual allocation
-//   regions more often than when using the Microsoft allocator.  You can
-//   avoid this by using VirtualAlloc() and VirtualFree() for all pixel
-//   buffers rather than using malloc().  If this is not possible,
-//   recompile this malloc with a larger DEFAULT_GRANULARITY. Note:
-//   in cases where MSC and gcc (cygwin) are known to differ on WIN32,
-//   conditions use _MSC_VER to distinguish them.
-
-// DLMALLOC_EXPORT       default: extern
-//   Defines how public APIs are declared. If you want to export via a
-//   Windows DLL, you might define this as
-//     #define DLMALLOC_EXPORT extern  __declspec(dllexport)
-//   If you want a POSIX ELF shared object, you might use
-//     #define DLMALLOC_EXPORT extern __attribute__((visibility("default")))
-
-// MALLOC_ALIGNMENT         default: (size_t)(2 * sizeof(void *))
-//   Controls the minimum alignment for malloc'ed chunks.  It must be a
-//   power of two and at least 8, even on machines for which smaller
-//   alignments would suffice. It may be defined as larger than this
-//   though. Note however that code and data structures are optimized for
-//   the case of 8-byte alignment.
-
-// MSPACES                  default: 0 (false)
-//   If true, compile in support for independent allocation spaces.
-//   This is only supported if HAVE_MMAP is true.
-
-// ONLY_MSPACES             default: 0 (false)
-//   If true, only compile in mspace versions, not regular versions.
-
-// USE_LOCKS                default: 0 (false)
-//   Causes each call to each public routine to be surrounded with
-//   pthread or WIN32 mutex lock/unlock. (If set true, this can be
-//   overridden on a per-mspace basis for mspace versions.) If set to a
-//   non-zero value other than 1, locks are used, but their
-//   implementation is left out, so lock functions must be supplied manually,
-//   as described below.
-
-// USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and spin locks available
-//   If true, uses custom spin locks for locking. This is currently
-//   supported only gcc >= 4.1, older gccs on x86 platforms, and recent
-//   MS compilers.  Otherwise, posix locks or win32 critical sections are
-//   used.
-
-// USE_RECURSIVE_LOCKS      default: not defined
-//   If defined nonzero, uses recursive (aka reentrant) locks, otherwise
-//   uses plain mutexes. This is not required for malloc proper, but may
-//   be needed for layered allocators such as nedmalloc.
-
-// LOCK_AT_FORK            default: not defined
-//   If defined nonzero, performs pthread_atfork upon initialization
-//   to initialize child lock while holding parent lock. The implementation
-//   assumes that pthread locks (not custom locks) are being used. In other
-//   cases, you may need to customize the implementation.
-
-// FOOTERS                  default: 0
-//   If true, provide extra checking and dispatching by placing
-//   information in the footers of allocated chunks. This adds
-//   space and time overhead.
-
-// INSECURE                 default: 0
-//   If true, omit checks for usage errors and heap space overwrites.
-
-// USE_DL_PREFIX            default: NOT defined
-//   Causes compiler to prefix all public routines with the string 'dl'.
-//   This can be useful when you only want to use this malloc in one part
-//   of a program, using your regular system malloc elsewhere.
-
-// MALLOC_INSPECT_ALL       default: NOT defined
-//   If defined, compiles malloc_inspect_all and mspace_inspect_all, that
-//   perform traversal of all heap space.  Unless access to these
-//   functions is otherwise restricted, you probably do not want to
-//   include them in secure implementations.
-
-// ABORT                    default: defined as abort()
-//   Defines how to abort on failed checks.  On most systems, a failed
-//   check cannot die with an "assert" or even print an informative
-//   message, because the underlying print routines in turn call malloc,
-//   which will fail again.  Generally, the best policy is to simply call
-//   abort(). It's not very useful to do more than this because many
-//   errors due to overwriting will show up as address faults (null, odd
-//   addresses etc) rather than malloc-triggered checks, so will also
-//   abort.  Also, most compilers know that abort() does not return, so
-//   can better optimize code conditionally calling it.
-
-// PROCEED_ON_ERROR           default: defined as 0 (false)
-//   Controls whether detected bad addresses cause them to bypassed
-//   rather than aborting. If set, detected bad arguments to free and
-//   realloc are ignored. And all bookkeeping information is zeroed out
-//   upon a detected overwrite of freed heap space, thus losing the
-//   ability to ever return it from malloc again, but enabling the
-//   application to proceed. If PROCEED_ON_ERROR is defined, the
-//   static variable malloc_corruption_error_count is compiled in
-//   and can be examined to see if errors have occurred. This option
-//   generates slower code than the default abort policy.
-
-// DEBUG                    default: NOT defined
-//   The DEBUG setting is mainly intended for people trying to modify
-//   this code or diagnose problems when porting to new platforms.
-//   However, it may also be able to better isolate user errors than just
-//   using runtime checks.  The assertions in the check routines spell
-//   out in more detail the assumptions and invariants underlying the
-//   algorithms.  The checking is fairly extensive, and will slow down
-//   execution noticeably. Calling malloc_stats or mallinfo with DEBUG
-//   set will attempt to check every non-mmapped allocated and free chunk
-//   in the course of computing the summaries.
-
-// ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)
-//   Debugging assertion failures can be nearly impossible if your
-//   version of the assert macro causes malloc to be called, which will
-//   lead to a cascade of further failures, blowing the runtime stack.
-//   ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),
-//   which will usually make debugging easier.
-
-// MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32
-//   The action to take before "return 0" when malloc fails to be able to
-//   return memory because there is none available.
-
-// HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES
-//   True if this system supports sbrk or an emulation of it.
-
-// MORECORE                  default: sbrk
-//   The name of the sbrk-style system routine to call to obtain more
-//   memory.  See below for guidance on writing custom MORECORE
-//   functions. The type of the argument to sbrk/MORECORE varies across
-//   systems.  It cannot be size_t, because it supports negative
-//   arguments, so it is normally the signed type of the same width as
-//   size_t (sometimes declared as "intptr_t").  It doesn't much matter
-//   though. Internally, we only call it with arguments less than half
-//   the max value of a size_t, which should work across all reasonable
-//   possibilities, although sometimes generating compiler warnings.
-
-// MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
-//   If true, take advantage of fact that consecutive calls to MORECORE
-//   with positive arguments always return contiguous increasing
-//   addresses.  This is true of unix sbrk. It does not hurt too much to
-//   set it true anyway, since malloc copes with non-contiguities.
-//   Setting it false when definitely non-contiguous saves time
-//   and possibly wasted space it would take to discover this though.
-
-// MORECORE_CANNOT_TRIM      default: NOT defined
-//   True if MORECORE cannot release space back to the system when given
-//   negative arguments. This is generally necessary only if you are
-//   using a hand-crafted MORECORE function that cannot handle negative
-//   arguments.
-
-// NO_SEGMENT_TRAVERSAL       default: 0
-//   If non-zero, suppresses traversals of memory segments
-//   returned by either MORECORE or CALL_MMAP. This disables
-//   merging of segments that are contiguous, and selectively
-//   releasing them to the OS if unused, but bounds execution times.
-
-// HAVE_MMAP                 default: 1 (true)
-//   True if this system supports mmap or an emulation of it.  If so, and
-//   HAVE_MORECORE is not true, MMAP is used for all system
-//   allocation. If set and HAVE_MORECORE is true as well, MMAP is
-//   primarily used to directly allocate very large blocks. It is also
-//   used as a backup strategy in cases where MORECORE fails to provide
-//   space from system. Note: A single call to MUNMAP is assumed to be
-//   able to unmap memory that may have be allocated using multiple calls
-//   to MMAP, so long as they are adjacent.
-
-// HAVE_MREMAP               default: 1 on linux, else 0
-//   If true realloc() uses mremap() to re-allocate large blocks and
-//   extend or shrink allocation spaces.
-
-// MMAP_CLEARS               default: 1 except on WINCE.
-//   True if mmap clears memory so calloc doesn't need to. This is true
-//   for standard unix mmap using /dev/zero and on WIN32 except for WINCE.
-
-// USE_BUILTIN_FFS            default: 0 (i.e., not used)
-//   Causes malloc to use the builtin ffs() function to compute indices.
-//   Some compilers may recognize and intrinsify ffs to be faster than the
-//   supplied C version. Also, the case of x86 using gcc is special-cased
-//   to an asm instruction, so is already as fast as it can be, and so
-//   this setting has no effect. Similarly for Win32 under recent MS compilers.
-//   (On most x86s, the asm version is only slightly faster than the C version.)
-
-// malloc_getpagesize         default: derive from system includes, or 4096.
-//   The system page size. To the extent possible, this malloc manages
-//   memory from the system in page-size units.  This may be (and
-//   usually is) a function rather than a constant. This is ignored
-//   if WIN32, where page size is determined using getSystemInfo during
-//   initialization.
-
-// USE_DEV_RANDOM             default: 0 (i.e., not used)
-//   Causes malloc to use /dev/random to initialize secure magic seed for
-//   stamping footers. Otherwise, the current time is used.
-
-// NO_MALLINFO                default: 0
-//   If defined, don't compile "mallinfo". This can be a simple way
-//   of dealing with mismatches between system declarations and
-//   those in this file.
-
-// MALLINFO_FIELD_TYPE        default: size_t
-//   The type of the fields in the mallinfo struct. This was originally
-//   defined as "int" in SVID etc, but is more usefully defined as
-//   size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set
-
-// NO_MALLOC_STATS            default: 0
-//   If defined, don't compile "malloc_stats". This avoids calls to
-//   fprintf and bringing in stdio dependencies you might not want.
-
-// REALLOC_ZERO_BYTES_FREES    default: not defined
-//   This should be set if a call to realloc with zero bytes should
-//   be the same as a call to free. Some people think it should. Otherwise,
-//   since this malloc returns a unique pointer for malloc(0), so does
-//   realloc(p, 0).
-
-// LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H
-// LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H
-// LACKS_STDLIB_H LACKS_SCHED_H LACKS_TIME_H  default: NOT defined unless on WIN32
-//   Define these if your system does not have these header files.
-//   You might need to manually insert some of the declarations they provide.
-
-// DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,
-//                                 system_info.dwAllocationGranularity in WIN32,
-//                                 otherwise 64K.
-//       Also settable using mallopt(M_GRANULARITY, x)
-//   The unit for allocating and deallocating memory from the system.  On
-//   most systems with contiguous MORECORE, there is no reason to
-//   make this more than a page. However, systems with MMAP tend to
-//   either require or encourage larger granularities.  You can increase
-//   this value to prevent system allocation functions to be called so
-//   often, especially if they are slow.  The value must be at least one
-//   page and must be a power of two.  Setting to 0 causes initialization
-//   to either page size or win32 region size.  (Note: In previous
-//   versions of malloc, the equivalent of this option was called
-//   "TOP_PAD")
-
-// DEFAULT_TRIM_THRESHOLD    default: 2MB
-//       Also settable using mallopt(M_TRIM_THRESHOLD, x)
-//   The maximum amount of unused top-most memory to keep before
-//   releasing via malloc_trim in free().  Automatic trimming is mainly
-//   useful in long-lived programs using contiguous MORECORE.  Because
-//   trimming via sbrk can be slow on some systems, and can sometimes be
-//   wasteful (in cases where programs immediately afterward allocate
-//   more large chunks) the value should be high enough so that your
-//   overall system performance would improve by releasing this much
-//   memory.  As a rough guide, you might set to a value close to the
-//   average size of a process (program) running on your system.
-//   Releasing this much memory would allow such a process to run in
-//   memory.  Generally, it is worth tuning trim thresholds when a
-//   program undergoes phases where several large chunks are allocated
-//   and released in ways that can reuse each other's storage, perhaps
-//   mixed with phases where there are no such chunks at all. The trim
-//   value must be greater than page size to have any useful effect.  To
-//   disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
-//   some people use of mallocing a huge space and then freeing it at
-//   program startup, in an attempt to reserve system memory, doesn't
-//   have the intended effect under automatic trimming, since that memory
-//   will immediately be returned to the system.
-
-// DEFAULT_MMAP_THRESHOLD       default: 256K
-//       Also settable using mallopt(M_MMAP_THRESHOLD, x)
-//   The request size threshold for using MMAP to directly service a
-//   request. Requests of at least this size that cannot be allocated
-//   using already-existing space will be serviced via mmap.  (If enough
-//   normal freed space already exists it is used instead.)  Using mmap
-//   segregates relatively large chunks of memory so that they can be
-//   individually obtained and released from the host system. A request
-//   serviced through mmap is never reused by any other request (at least
-//   not directly; the system may just so happen to remap successive
-//   requests to the same locations).  Segregating space in this way has
-//   the benefits that: Mmapped space can always be individually released
-//   back to the system, which helps keep the system level memory demands
-//   of a long-lived program low.  Also, mapped memory doesn't become
-//   `locked' between other chunks, as can happen with normally allocated
-//   chunks, which means that even trimming via malloc_trim would not
-//   release them.  However, it has the disadvantage that the space
-//   cannot be reclaimed, consolidated, and then used to service later
-//   requests, as happens with normal chunks.  The advantages of mmap
-//   nearly always outweigh disadvantages for "large" chunks, but the
-//   value of "large" may vary across systems.  The default is an
-//   empirically derived value that works well in most systems. You can
-//   disable mmap by setting to MAX_SIZE_T.
-
-// MAX_RELEASE_CHECK_RATE   default: 4095 unless not HAVE_MMAP
-//   The number of consolidated frees between checks to release
-//   unused segments when freeing. When using non-contiguous segments,
-//   especially with multiple mspaces, checking only for topmost space
-//   doesn't always suffice to trigger trimming. To compensate for this,
-//   free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
-//   current number of segments, if greater) try to release unused
-//   segments to the OS when freeing chunks that result in
-//   consolidation. The best value for this parameter is a compromise
-//   between slowing down frees with relatively costly checks that
-//   rarely trigger versus holding on to unused memory. To effectively
-//   disable, set to MAX_SIZE_T. This may lead to a very slight speed
-//   improvement at the expense of carrying around more memory.
-// */
-
-// /* Version identifier to allow people to support multiple versions */
-// #ifndef DLMALLOC_VERSION
-// #define DLMALLOC_VERSION 20806
-// #endif /* DLMALLOC_VERSION */
-
-// #ifndef DLMALLOC_EXPORT
-// #define DLMALLOC_EXPORT extern
-// #endif
-
-// #ifndef WIN32
-// #ifdef _WIN32
-// #define WIN32 1
-// #endif  /* _WIN32 */
-// #ifdef _WIN32_WCE
-// #define LACKS_FCNTL_H
-// #define WIN32 1
-// #endif /* _WIN32_WCE */
-// #endif  /* WIN32 */
-// #ifdef WIN32
-// #define WIN32_LEAN_AND_MEAN
-// #include <windows.h>
-// #include <tchar.h>
-// #define HAVE_MMAP 1
-// #define HAVE_MORECORE 0
-// #define LACKS_UNISTD_H
-// #define LACKS_SYS_PARAM_H
-// #define LACKS_SYS_MMAN_H
-// #define LACKS_STRING_H
-// #define LACKS_STRINGS_H
-// #define LACKS_SYS_TYPES_H
-// #define LACKS_ERRNO_H
-// #define LACKS_SCHED_H
-// #ifndef MALLOC_FAILURE_ACTION
-// #define MALLOC_FAILURE_ACTION
-// #endif /* MALLOC_FAILURE_ACTION */
-// #ifndef MMAP_CLEARS
-// #ifdef _WIN32_WCE /* WINCE reportedly does not clear */
-// #define MMAP_CLEARS 0
-// #else
-// #define MMAP_CLEARS 1
-// #endif /* _WIN32_WCE */
-// #endif /*MMAP_CLEARS */
-// #endif  /* WIN32 */
-
-// #if defined(DARWIN) || defined(_DARWIN)
-// /* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
-// #ifndef HAVE_MORECORE
-// #define HAVE_MORECORE 0
-// #define HAVE_MMAP 1
-// /* OSX allocators provide 16 byte alignment */
-// #ifndef MALLOC_ALIGNMENT
-// #define MALLOC_ALIGNMENT ((size_t)16U)
-// #endif
-// #endif  /* HAVE_MORECORE */
-// #endif  /* DARWIN */
-
-// #ifndef LACKS_SYS_TYPES_H
-// #include <sys/types.h>  /* For size_t */
-// #endif  /* LACKS_SYS_TYPES_H */
-
-// /* The maximum possible size_t value has all bits set */
-// #define MAX_SIZE_T           (~(size_t)0)
-
-// #ifndef USE_LOCKS /* ensure true if spin or recursive locks set */
-// #define USE_LOCKS  ((defined(USE_SPIN_LOCKS) && USE_SPIN_LOCKS != 0) || \
-//                     (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0))
-// #endif /* USE_LOCKS */
-
-// #if USE_LOCKS /* Spin locks for gcc >= 4.1, older gcc on x86, MSC >= 1310 */
-// #if ((defined(__GNUC__) &&                                              \
-//       ((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) ||      \
-//        defined(__i386__) || defined(__x86_64__))) ||                    \
-//      (defined(_MSC_VER) && _MSC_VER>=1310))
-// #ifndef USE_SPIN_LOCKS
-// #define USE_SPIN_LOCKS 1
-// #endif /* USE_SPIN_LOCKS */
-// #elif USE_SPIN_LOCKS
-// #error "USE_SPIN_LOCKS defined without implementation"
-// #endif /* ... locks available... */
-// #elif !defined(USE_SPIN_LOCKS)
-// #define USE_SPIN_LOCKS 0
-// #endif /* USE_LOCKS */
-
-// #ifndef ONLY_MSPACES
-// #define ONLY_MSPACES 0
-// #endif  /* ONLY_MSPACES */
-// #ifndef MSPACES
-// #if ONLY_MSPACES
-// #define MSPACES 1
-// #else   /* ONLY_MSPACES */
-// #define MSPACES 0
-// #endif  /* ONLY_MSPACES */
-// #endif  /* MSPACES */
-// #ifndef MALLOC_ALIGNMENT
-// #define MALLOC_ALIGNMENT ((size_t)(2 * sizeof(void *)))
-// #endif  /* MALLOC_ALIGNMENT */
-// #ifndef FOOTERS
-// #define FOOTERS 0
-// #endif  /* FOOTERS */
-// #ifndef ABORT
-// #define ABORT  abort()
-// #endif  /* ABORT */
-// #ifndef ABORT_ON_ASSERT_FAILURE
-// #define ABORT_ON_ASSERT_FAILURE 1
-// #endif  /* ABORT_ON_ASSERT_FAILURE */
-// #ifndef PROCEED_ON_ERROR
-// #define PROCEED_ON_ERROR 0
-// #endif  /* PROCEED_ON_ERROR */
-
-// #ifndef INSECURE
-// #define INSECURE 0
-// #endif  /* INSECURE */
-// #ifndef MALLOC_INSPECT_ALL
-// #define MALLOC_INSPECT_ALL 0
-// #endif  /* MALLOC_INSPECT_ALL */
-// #ifndef HAVE_MMAP
-// #define HAVE_MMAP 1
-// #endif  /* HAVE_MMAP */
-// #ifndef MMAP_CLEARS
-// #define MMAP_CLEARS 1
-// #endif  /* MMAP_CLEARS */
-// #ifndef HAVE_MREMAP
-// #ifdef linux
-// #define HAVE_MREMAP 1
-// #define _GNU_SOURCE /* Turns on mremap() definition */
-// #else   /* linux */
-// #define HAVE_MREMAP 0
-// #endif  /* linux */
-// #endif  /* HAVE_MREMAP */
-// #ifndef MALLOC_FAILURE_ACTION
-// #define MALLOC_FAILURE_ACTION  errno = ENOMEM;
-// #endif  /* MALLOC_FAILURE_ACTION */
-// #ifndef HAVE_MORECORE
-// #if ONLY_MSPACES
-// #define HAVE_MORECORE 0
-// #else   /* ONLY_MSPACES */
-// #define HAVE_MORECORE 1
-// #endif  /* ONLY_MSPACES */
-// #endif  /* HAVE_MORECORE */
-// #if !HAVE_MORECORE
-// #define MORECORE_CONTIGUOUS 0
-// #else   /* !HAVE_MORECORE */
-// #define MORECORE_DEFAULT sbrk
-// #ifndef MORECORE_CONTIGUOUS
-// #define MORECORE_CONTIGUOUS 1
-// #endif  /* MORECORE_CONTIGUOUS */
-// #endif  /* HAVE_MORECORE */
-// #ifndef DEFAULT_GRANULARITY
-// #if (MORECORE_CONTIGUOUS || defined(WIN32))
-// #define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */
-// #else   /* MORECORE_CONTIGUOUS */
-// #define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
-// #endif  /* MORECORE_CONTIGUOUS */
-// #endif  /* DEFAULT_GRANULARITY */
-// #ifndef DEFAULT_TRIM_THRESHOLD
-// #ifndef MORECORE_CANNOT_TRIM
-// #define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
-// #else   /* MORECORE_CANNOT_TRIM */
-// #define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
-// #endif  /* MORECORE_CANNOT_TRIM */
-// #endif  /* DEFAULT_TRIM_THRESHOLD */
-// #ifndef DEFAULT_MMAP_THRESHOLD
-// #if HAVE_MMAP
-// #define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
-// #else   /* HAVE_MMAP */
-// #define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
-// #endif  /* HAVE_MMAP */
-// #endif  /* DEFAULT_MMAP_THRESHOLD */
-// #ifndef MAX_RELEASE_CHECK_RATE
-// #if HAVE_MMAP
-// #define MAX_RELEASE_CHECK_RATE 4095
-// #else
-// #define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
-// #endif /* HAVE_MMAP */
-// #endif /* MAX_RELEASE_CHECK_RATE */
-// #ifndef USE_BUILTIN_FFS
-// #define USE_BUILTIN_FFS 0
-// #endif  /* USE_BUILTIN_FFS */
-// #ifndef USE_DEV_RANDOM
-// #define USE_DEV_RANDOM 0
-// #endif  /* USE_DEV_RANDOM */
-// #ifndef NO_MALLINFO
-// #define NO_MALLINFO 0
-// #endif  /* NO_MALLINFO */
-// #ifndef MALLINFO_FIELD_TYPE
-// #define MALLINFO_FIELD_TYPE size_t
-// #endif  /* MALLINFO_FIELD_TYPE */
-// #ifndef NO_MALLOC_STATS
-// #define NO_MALLOC_STATS 0
-// #endif  /* NO_MALLOC_STATS */
-// #ifndef NO_SEGMENT_TRAVERSAL
-// #define NO_SEGMENT_TRAVERSAL 0
-// #endif /* NO_SEGMENT_TRAVERSAL */
-
-// /*
-//   mallopt tuning options.  SVID/XPG defines four standard parameter
-//   numbers for mallopt, normally defined in malloc.h.  None of these
-//   are used in this malloc, so setting them has no effect. But this
-//   malloc does support the following options.
-// */
-
-// #define M_TRIM_THRESHOLD     (-1)
-// #define M_GRANULARITY        (-2)
-// #define M_MMAP_THRESHOLD     (-3)
-
-// /* ------------------------ Mallinfo declarations ------------------------ */
-
-// #if !NO_MALLINFO
-// /*
-//   This version of malloc supports the standard SVID/XPG mallinfo
-//   routine that returns a struct containing usage properties and
-//   statistics. It should work on any system that has a
-//   /usr/include/malloc.h defining struct mallinfo.  The main
-//   declaration needed is the mallinfo struct that is returned (by-copy)
-//   by mallinfo().  The malloinfo struct contains a bunch of fields that
-//   are not even meaningful in this version of malloc.  These fields are
-//   are instead filled by mallinfo() with other numbers that might be of
-//   interest.
-
-//   HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
-//   /usr/include/malloc.h file that includes a declaration of struct
-//   mallinfo.  If so, it is included; else a compliant version is
-//   declared below.  These must be precisely the same for mallinfo() to
-//   work.  The original SVID version of this struct, defined on most
-//   systems with mallinfo, declares all fields as ints. But some others
-//   define as unsigned long. If your system defines the fields using a
-//   type of different width than listed here, you MUST #include your
-//   system version and #define HAVE_USR_INCLUDE_MALLOC_H.
-// */
-
-// /* #define HAVE_USR_INCLUDE_MALLOC_H */
-
-// #ifdef HAVE_USR_INCLUDE_MALLOC_H
-// #include "/usr/include/malloc.h"
-// #else /* HAVE_USR_INCLUDE_MALLOC_H */
-// #ifndef STRUCT_MALLINFO_DECLARED
-// /* HP-UX (and others?) redefines mallinfo unless _STRUCT_MALLINFO is defined */
-// #define _STRUCT_MALLINFO
-// #define STRUCT_MALLINFO_DECLARED 1
-// struct mallinfo {
-//   MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */
-//   MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */
-//   MALLINFO_FIELD_TYPE smblks;   /* always 0 */
-//   MALLINFO_FIELD_TYPE hblks;    /* always 0 */
-//   MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */
-//   MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */
-//   MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */
-//   MALLINFO_FIELD_TYPE uordblks; /* total allocated space */
-//   MALLINFO_FIELD_TYPE fordblks; /* total free space */
-//   MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */
-// };
-// #endif /* STRUCT_MALLINFO_DECLARED */
-// #endif /* HAVE_USR_INCLUDE_MALLOC_H */
-// #endif /* NO_MALLINFO */
-
-// /*
-//   Try to persuade compilers to inline. The most critical functions for
-//   inlining are defined as macros, so these aren't used for them.
-// */
-
-// #ifndef FORCEINLINE
-//   #if defined(__GNUC__)
-// #define FORCEINLINE __inline __attribute__ ((always_inline))
-//   #elif defined(_MSC_VER)
-//     #define FORCEINLINE __forceinline
-//   #endif
-// #endif
-// #ifndef NOINLINE
-//   #if defined(__GNUC__)
-//     #define NOINLINE __attribute__ ((noinline))
-//   #elif defined(_MSC_VER)
-//     #define NOINLINE __declspec(noinline)
-//   #else
-//     #define NOINLINE
-//   #endif
-// #endif
-
-// #ifdef __cplusplus
-// extern "C" {
-// #ifndef FORCEINLINE
-//  #define FORCEINLINE inline
-// #endif
-// #endif /* __cplusplus */
-// #ifndef FORCEINLINE
-//  #define FORCEINLINE
-// #endif
-
-// #if !ONLY_MSPACES
-
-// /* ------------------- Declarations of public routines ------------------- */
-
-// // #ifndef USE_DL_PREFIX
-// // #define dlcalloc               calloc
-// // #define dlfree                 free
-// // #define dlmalloc               malloc
-// // #define dlmemalign             memalign
-// // #define dlposix_memalign       posix_memalign
-// // #define dlrealloc              realloc
-// // #define dlrealloc_in_place     realloc_in_place
-// // #define dlvalloc               valloc
-// // #define dlpvalloc              pvalloc
-// // #define dlmallinfo             mallinfo
-// // #define dlmallopt              mallopt
-// // #define dlmalloc_trim          malloc_trim
-// // #define dlmalloc_stats         malloc_stats
-// // #define dlmalloc_usable_size   malloc_usable_size
-// // #define dlmalloc_footprint     malloc_footprint
-// // #define dlmalloc_max_footprint malloc_max_footprint
-// // #define dlmalloc_footprint_limit malloc_footprint_limit
-// // #define dlmalloc_set_footprint_limit malloc_set_footprint_limit
-// // #define dlmalloc_inspect_all   malloc_inspect_all
-// // #define dlindependent_calloc   independent_calloc
-// // #define dlindependent_comalloc independent_comalloc
-// // #define dlbulk_free            bulk_free
-// // #endif /* USE_DL_PREFIX */
-
-// /*
-//   malloc(size_t n)
-//   Returns a pointer to a newly allocated chunk of at least n bytes, or
-//   null if no space is available, in which case errno is set to ENOMEM
-//   on ANSI C systems.
-
-//   If n is zero, malloc returns a minimum-sized chunk. (The minimum
-//   size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
-//   systems.)  Note that size_t is an unsigned type, so calls with
-//   arguments that would be negative if signed are interpreted as
-//   requests for huge amounts of space, which will often fail. The
-//   maximum supported value of n differs across systems, but is in all
-//   cases less than the maximum representable value of a size_t.
-// */
-// DLMALLOC_EXPORT void* dlmalloc(size_t);
-
-// /*
-//   free(void* p)
-//   Releases the chunk of memory pointed to by p, that had been previously
-//   allocated using malloc or a related routine such as realloc.
-//   It has no effect if p is null. If p was not malloced or already
-//   freed, free(p) will by default cause the current program to abort.
-// */
-// DLMALLOC_EXPORT void  dlfree(void*);
-
-// /*
-//   calloc(size_t n_elements, size_t element_size);
-//   Returns a pointer to n_elements * element_size bytes, with all locations
-//   set to zero.
-// */
-// DLMALLOC_EXPORT void* dlcalloc(size_t, size_t);
-
-// /*
-//   realloc(void* p, size_t n)
-//   Returns a pointer to a chunk of size n that contains the same data
-//   as does chunk p up to the minimum of (n, p's size) bytes, or null
-//   if no space is available.
-
-//   The returned pointer may or may not be the same as p. The algorithm
-//   prefers extending p in most cases when possible, otherwise it
-//   employs the equivalent of a malloc-copy-free sequence.
-
-//   If p is null, realloc is equivalent to malloc.
-
-//   If space is not available, realloc returns null, errno is set (if on
-//   ANSI) and p is NOT freed.
-
-//   if n is for fewer bytes than already held by p, the newly unused
-//   space is lopped off and freed if possible.  realloc with a size
-//   argument of zero (re)allocates a minimum-sized chunk.
-
-//   The old unix realloc convention of allowing the last-free'd chunk
-//   to be used as an argument to realloc is not supported.
-// */
-// DLMALLOC_EXPORT void* dlrealloc(void*, size_t);
-
-// /*
-//   realloc_in_place(void* p, size_t n)
-//   Resizes the space allocated for p to size n, only if this can be
-//   done without moving p (i.e., only if there is adjacent space
-//   available if n is greater than p's current allocated size, or n is
-//   less than or equal to p's size). This may be used instead of plain
-//   realloc if an alternative allocation strategy is needed upon failure
-//   to expand space; for example, reallocation of a buffer that must be
-//   memory-aligned or cleared. You can use realloc_in_place to trigger
-//   these alternatives only when needed.
-
-//   Returns p if successful; otherwise null.
-// */
-// DLMALLOC_EXPORT void* dlrealloc_in_place(void*, size_t);
-
-// /*
-//   memalign(size_t alignment, size_t n);
-//   Returns a pointer to a newly allocated chunk of n bytes, aligned
-//   in accord with the alignment argument.
-
-//   The alignment argument should be a power of two. If the argument is
-//   not a power of two, the nearest greater power is used.
-//   8-byte alignment is guaranteed by normal malloc calls, so don't
-//   bother calling memalign with an argument of 8 or less.
-
-//   Overreliance on memalign is a sure way to fragment space.
-// */
-// DLMALLOC_EXPORT void* dlmemalign(size_t, size_t);
-
-// /*
-//   int posix_memalign(void** pp, size_t alignment, size_t n);
-//   Allocates a chunk of n bytes, aligned in accord with the alignment
-//   argument. Differs from memalign only in that it (1) assigns the
-//   allocated memory to *pp rather than returning it, (2) fails and
-//   returns EINVAL if the alignment is not a power of two (3) fails and
-//   returns ENOMEM if memory cannot be allocated.
-// */
-// DLMALLOC_EXPORT int dlposix_memalign(void**, size_t, size_t);
-
-// /*
-//   valloc(size_t n);
-//   Equivalent to memalign(pagesize, n), where pagesize is the page
-//   size of the system. If the pagesize is unknown, 4096 is used.
-// */
-// DLMALLOC_EXPORT void* dlvalloc(size_t);
-
-// /*
-//   mallopt(int parameter_number, int parameter_value)
-//   Sets tunable parameters The format is to provide a
-//   (parameter-number, parameter-value) pair.  mallopt then sets the
-//   corresponding parameter to the argument value if it can (i.e., so
-//   long as the value is meaningful), and returns 1 if successful else
-//   0.  To workaround the fact that mallopt is specified to use int,
-//   not size_t parameters, the value -1 is specially treated as the
-//   maximum unsigned size_t value.
-
-//   SVID/XPG/ANSI defines four standard param numbers for mallopt,
-//   normally defined in malloc.h.  None of these are use in this malloc,
-//   so setting them has no effect. But this malloc also supports other
-//   options in mallopt. See below for details.  Briefly, supported
-//   parameters are as follows (listed defaults are for "typical"
-//   configurations).
-
-//   Symbol            param #  default    allowed param values
-//   M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1 disables)
-//   M_GRANULARITY        -2     page size   any power of 2 >= page size
-//   M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
-// */
-// DLMALLOC_EXPORT int dlmallopt(int, int);
-
-// /*
-//   malloc_footprint();
-//   Returns the number of bytes obtained from the system.  The total
-//   number of bytes allocated by malloc, realloc etc., is less than this
-//   value. Unlike mallinfo, this function returns only a precomputed
-//   result, so can be called frequently to monitor memory consumption.
-//   Even if locks are otherwise defined, this function does not use them,
-//   so results might not be up to date.
-// */
-// DLMALLOC_EXPORT size_t dlmalloc_footprint(void);
-
-// /*
-//   malloc_max_footprint();
-//   Returns the maximum number of bytes obtained from the system. This
-//   value will be greater than current footprint if deallocated space
-//   has been reclaimed by the system. The peak number of bytes allocated
-//   by malloc, realloc etc., is less than this value. Unlike mallinfo,
-//   this function returns only a precomputed result, so can be called
-//   frequently to monitor memory consumption.  Even if locks are
-//   otherwise defined, this function does not use them, so results might
-//   not be up to date.
-// */
-// DLMALLOC_EXPORT size_t dlmalloc_max_footprint(void);
-
-// /*
-//   malloc_footprint_limit();
-//   Returns the number of bytes that the heap is allowed to obtain from
-//   the system, returning the last value returned by
-//   malloc_set_footprint_limit, or the maximum size_t value if
-//   never set. The returned value reflects a permission. There is no
-//   guarantee that this number of bytes can actually be obtained from
-//   the system.
-// */
-// DLMALLOC_EXPORT size_t dlmalloc_footprint_limit();
-
-// /*
-//   malloc_set_footprint_limit();
-//   Sets the maximum number of bytes to obtain from the system, causing
-//   failure returns from malloc and related functions upon attempts to
-//   exceed this value. The argument value may be subject to page
-//   rounding to an enforceable limit; this actual value is returned.
-//   Using an argument of the maximum possible size_t effectively
-//   disables checks. If the argument is less than or equal to the
-//   current malloc_footprint, then all future allocations that require
-//   additional system memory will fail. However, invocation cannot
-//   retroactively deallocate existing used memory.
-// */
-// DLMALLOC_EXPORT size_t dlmalloc_set_footprint_limit(size_t bytes);
-
-// #if MALLOC_INSPECT_ALL
-// /*
-//   malloc_inspect_all(void(*handler)(void *start,
-//                                     void *end,
-//                                     size_t used_bytes,
-//                                     void* callback_arg),
-//                       void* arg);
-//   Traverses the heap and calls the given handler for each managed
-//   region, skipping all bytes that are (or may be) used for bookkeeping
-//   purposes.  Traversal does not include include chunks that have been
-//   directly memory mapped. Each reported region begins at the start
-//   address, and continues up to but not including the end address.  The
-//   first used_bytes of the region contain allocated data. If
-//   used_bytes is zero, the region is unallocated. The handler is
-//   invoked with the given callback argument. If locks are defined, they
-//   are held during the entire traversal. It is a bad idea to invoke
-//   other malloc functions from within the handler.
-
-//   For example, to count the number of in-use chunks with size greater
-//   than 1000, you could write:
-//   static int count = 0;
-//   void count_chunks(void* start, void* end, size_t used, void* arg) {
-//     if (used >= 1000) ++count;
-//   }
-//   then:
-//     malloc_inspect_all(count_chunks, NULL);
-
-//   malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.
-// */
-// DLMALLOC_EXPORT void dlmalloc_inspect_all(void(*handler)(void*, void *, size_t, void*),
-//                            void* arg);
-
-// #endif /* MALLOC_INSPECT_ALL */
-
-// #if !NO_MALLINFO
-// /*
-//   mallinfo()
-//   Returns (by copy) a struct containing various summary statistics:
-
-//   arena:     current total non-mmapped bytes allocated from system
-//   ordblks:   the number of free chunks
-//   smblks:    always zero.
-//   hblks:     current number of mmapped regions
-//   hblkhd:    total bytes held in mmapped regions
-//   usmblks:   the maximum total allocated space. This will be greater
-//                 than current total if trimming has occurred.
-//   fsmblks:   always zero
-//   uordblks:  current total allocated space (normal or mmapped)
-//   fordblks:  total free space
-//   keepcost:  the maximum number of bytes that could ideally be released
-//                back to system via malloc_trim. ("ideally" means that
-//                it ignores page restrictions etc.)
-
-//   Because these fields are ints, but internal bookkeeping may
-//   be kept as longs, the reported values may wrap around zero and
-//   thus be inaccurate.
-// */
-// DLMALLOC_EXPORT struct mallinfo dlmallinfo(void);
-// #endif /* NO_MALLINFO */
-
-// /*
-//   independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);
-
-//   independent_calloc is similar to calloc, but instead of returning a
-//   single cleared space, it returns an array of pointers to n_elements
-//   independent elements that can hold contents of size elem_size, each
-//   of which starts out cleared, and can be independently freed,
-//   realloc'ed etc. The elements are guaranteed to be adjacently
-//   allocated (this is not guaranteed to occur with multiple callocs or
-//   mallocs), which may also improve cache locality in some
-//   applications.
-
-//   The "chunks" argument is optional (i.e., may be null, which is
-//   probably the most typical usage). If it is null, the returned array
-//   is itself dynamically allocated and should also be freed when it is
-//   no longer needed. Otherwise, the chunks array must be of at least
-//   n_elements in length. It is filled in with the pointers to the
-//   chunks.
-
-//   In either case, independent_calloc returns this pointer array, or
-//   null if the allocation failed.  If n_elements is zero and "chunks"
-//   is null, it returns a chunk representing an array with zero elements
-//   (which should be freed if not wanted).
-
-//   Each element must be freed when it is no longer needed. This can be
-//   done all at once using bulk_free.
-
-//   independent_calloc simplifies and speeds up implementations of many
-//   kinds of pools.  It may also be useful when constructing large data
-//   structures that initially have a fixed number of fixed-sized nodes,
-//   but the number is not known at compile time, and some of the nodes
-//   may later need to be freed. For example:
-
-//   struct Node { int item; struct Node* next; };
-
-//   struct Node* build_list() {
-//     struct Node** pool;
-//     int n = read_number_of_nodes_needed();
-//     if (n <= 0) return 0;
-//     pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
-//     if (pool == 0) die();
-//     // organize into a linked list...
-//     struct Node* first = pool[0];
-//     for (i = 0; i < n-1; ++i)
-//       pool[i]->next = pool[i+1];
-//     free(pool);     // Can now free the array (or not, if it is needed later)
-//     return first;
-//   }
-// */
-// DLMALLOC_EXPORT void** dlindependent_calloc(size_t, size_t, void**);
-
-// /*
-//   independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);
-
-//   independent_comalloc allocates, all at once, a set of n_elements
-//   chunks with sizes indicated in the "sizes" array.    It returns
-//   an array of pointers to these elements, each of which can be
-//   independently freed, realloc'ed etc. The elements are guaranteed to
-//   be adjacently allocated (this is not guaranteed to occur with
-//   multiple callocs or mallocs), which may also improve cache locality
-//   in some applications.
-
-//   The "chunks" argument is optional (i.e., may be null). If it is null
-//   the returned array is itself dynamically allocated and should also
-//   be freed when it is no longer needed. Otherwise, the chunks array
-//   must be of at least n_elements in length. It is filled in with the
-//   pointers to the chunks.
-
-//   In either case, independent_comalloc returns this pointer array, or
-//   null if the allocation failed.  If n_elements is zero and chunks is
-//   null, it returns a chunk representing an array with zero elements
-//   (which should be freed if not wanted).
-
-//   Each element must be freed when it is no longer needed. This can be
-//   done all at once using bulk_free.
-
-//   independent_comallac differs from independent_calloc in that each
-//   element may have a different size, and also that it does not
-//   automatically clear elements.
-
-//   independent_comalloc can be used to speed up allocation in cases
-//   where several structs or objects must always be allocated at the
-//   same time.  For example:
-
-//   struct Head { ... }
-//   struct Foot { ... }
-
-//   void send_message(char* msg) {
-//     int msglen = strlen(msg);
-//     size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
-//     void* chunks[3];
-//     if (independent_comalloc(3, sizes, chunks) == 0)
-//       die();
-//     struct Head* head = (struct Head*)(chunks[0]);
-//     char*        body = (char*)(chunks[1]);
-//     struct Foot* foot = (struct Foot*)(chunks[2]);
-//     // ...
-//   }
-
-//   In general though, independent_comalloc is worth using only for
-//   larger values of n_elements. For small values, you probably won't
-//   detect enough difference from series of malloc calls to bother.
-
-//   Overuse of independent_comalloc can increase overall memory usage,
-//   since it cannot reuse existing noncontiguous small chunks that
-//   might be available for some of the elements.
-// */
-// DLMALLOC_EXPORT void** dlindependent_comalloc(size_t, size_t*, void**);
-
-// /*
-//   bulk_free(void* array[], size_t n_elements)
-//   Frees and clears (sets to null) each non-null pointer in the given
-//   array.  This is likely to be faster than freeing them one-by-one.
-//   If footers are used, pointers that have been allocated in different
-//   mspaces are not freed or cleared, and the count of all such pointers
-//   is returned.  For large arrays of pointers with poor locality, it
-//   may be worthwhile to sort this array before calling bulk_free.
-// */
-// DLMALLOC_EXPORT size_t  dlbulk_free(void**, size_t n_elements);
-
-// /*
-//   pvalloc(size_t n);
-//   Equivalent to valloc(minimum-page-that-holds(n)), that is,
-//   round up n to nearest pagesize.
-//  */
-// DLMALLOC_EXPORT void*  dlpvalloc(size_t);
-
-// /*
-//   malloc_trim(size_t pad);
-
-//   If possible, gives memory back to the system (via negative arguments
-//   to sbrk) if there is unused memory at the `high' end of the malloc
-//   pool or in unused MMAP segments. You can call this after freeing
-//   large blocks of memory to potentially reduce the system-level memory
-//   requirements of a program. However, it cannot guarantee to reduce
-//   memory. Under some allocation patterns, some large free blocks of
-//   memory will be locked between two used chunks, so they cannot be
-//   given back to the system.
-
-//   The `pad' argument to malloc_trim represents the amount of free
-//   trailing space to leave untrimmed. If this argument is zero, only
-//   the minimum amount of memory to maintain internal data structures
-//   will be left. Non-zero arguments can be supplied to maintain enough
-//   trailing space to service future expected allocations without having
-//   to re-obtain memory from the system.
-
-//   Malloc_trim returns 1 if it actually released any memory, else 0.
-// */
-// DLMALLOC_EXPORT int  dlmalloc_trim(size_t);
-
-// /*
-//   malloc_stats();
-//   Prints on stderr the amount of space obtained from the system (both
-//   via sbrk and mmap), the maximum amount (which may be more than
-//   current if malloc_trim and/or munmap got called), and the current
-//   number of bytes allocated via malloc (or realloc, etc) but not yet
-//   freed. Note that this is the number of bytes allocated, not the
-//   number requested. It will be larger than the number requested
-//   because of alignment and bookkeeping overhead. Because it includes
-//   alignment wastage as being in use, this figure may be greater than
-//   zero even when no user-level chunks are allocated.
-
-//   The reported current and maximum system memory can be inaccurate if
-//   a program makes other calls to system memory allocation functions
-//   (normally sbrk) outside of malloc.
-
-//   malloc_stats prints only the most commonly interesting statistics.
-//   More information can be obtained by calling mallinfo.
-// */
-// DLMALLOC_EXPORT void  dlmalloc_stats(void);
-
-// /*
-//   malloc_usable_size(void* p);
-
-//   Returns the number of bytes you can actually use in
-//   an allocated chunk, which may be more than you requested (although
-//   often not) due to alignment and minimum size constraints.
-//   You can use this many bytes without worrying about
-//   overwriting other allocated objects. This is not a particularly great
-//   programming practice. malloc_usable_size can be more useful in
-//   debugging and assertions, for example:
-
-//   p = malloc(n);
-//   assert(malloc_usable_size(p) >= 256);
-// */
-// size_t dlmalloc_usable_size(void*);
-
-// #endif /* ONLY_MSPACES */
-
-// #if MSPACES
-
-// /*
-//   mspace is an opaque type representing an independent
-//   region of space that supports mspace_malloc, etc.
-// */
-// typedef void* mspace;
-
-// /*
-//   create_mspace creates and returns a new independent space with the
-//   given initial capacity, or, if 0, the default granularity size.  It
-//   returns null if there is no system memory available to create the
-//   space.  If argument locked is non-zero, the space uses a separate
-//   lock to control access. The capacity of the space will grow
-//   dynamically as needed to service mspace_malloc requests.  You can
-//   control the sizes of incremental increases of this space by
-//   compiling with a different DEFAULT_GRANULARITY or dynamically
-//   setting with mallopt(M_GRANULARITY, value).
-// */
-// DLMALLOC_EXPORT mspace create_mspace(size_t capacity, int locked);
-
-// /*
-//   destroy_mspace destroys the given space, and attempts to return all
-//   of its memory back to the system, returning the total number of
-//   bytes freed. After destruction, the results of access to all memory
-//   used by the space become undefined.
-// */
-// DLMALLOC_EXPORT size_t destroy_mspace(mspace msp);
-
-// /*
-//   create_mspace_with_base uses the memory supplied as the initial base
-//   of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
-//   space is used for bookkeeping, so the capacity must be at least this
-//   large. (Otherwise 0 is returned.) When this initial space is
-//   exhausted, additional memory will be obtained from the system.
-//   Destroying this space will deallocate all additionally allocated
-//   space (if possible) but not the initial base.
-// */
-// DLMALLOC_EXPORT mspace create_mspace_with_base(void* base, size_t capacity, int locked);
-
-// /*
-//   mspace_track_large_chunks controls whether requests for large chunks
-//   are allocated in their own untracked mmapped regions, separate from
-//   others in this mspace. By default large chunks are not tracked,
-//   which reduces fragmentation. However, such chunks are not
-//   necessarily released to the system upon destroy_mspace.  Enabling
-//   tracking by setting to true may increase fragmentation, but avoids
-//   leakage when relying on destroy_mspace to release all memory
-//   allocated using this space.  The function returns the previous
-//   setting.
-// */
-// DLMALLOC_EXPORT int mspace_track_large_chunks(mspace msp, int enable);
-
-
-// /*
-//   mspace_malloc behaves as malloc, but operates within
-//   the given space.
-// */
-// DLMALLOC_EXPORT void* mspace_malloc(mspace msp, size_t bytes);
-
-// /*
-//   mspace_free behaves as free, but operates within
-//   the given space.
-
-//   If compiled with FOOTERS==1, mspace_free is not actually needed.
-//   free may be called instead of mspace_free because freed chunks from
-//   any space are handled by their originating spaces.
-// */
-// DLMALLOC_EXPORT void mspace_free(mspace msp, void* mem);
-
-// /*
-//   mspace_realloc behaves as realloc, but operates within
-//   the given space.
-
-//   If compiled with FOOTERS==1, mspace_realloc is not actually
-//   needed.  realloc may be called instead of mspace_realloc because
-//   realloced chunks from any space are handled by their originating
-//   spaces.
-// */
-// DLMALLOC_EXPORT void* mspace_realloc(mspace msp, void* mem, size_t newsize);
-
-// /*
-//   mspace_calloc behaves as calloc, but operates within
-//   the given space.
-// */
-// DLMALLOC_EXPORT void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
-
-// /*
-//   mspace_memalign behaves as memalign, but operates within
-//   the given space.
-// */
-// DLMALLOC_EXPORT void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
-
-// /*
-//   mspace_independent_calloc behaves as independent_calloc, but
-//   operates within the given space.
-// */
-// DLMALLOC_EXPORT void** mspace_independent_calloc(mspace msp, size_t n_elements,
-//                                  size_t elem_size, void* chunks[]);
-
-// /*
-//   mspace_independent_comalloc behaves as independent_comalloc, but
-//   operates within the given space.
-// */
-// DLMALLOC_EXPORT void** mspace_independent_comalloc(mspace msp, size_t n_elements,
-//                                    size_t sizes[], void* chunks[]);
-
-// /*
-//   mspace_footprint() returns the number of bytes obtained from the
-//   system for this space.
-// */
-// DLMALLOC_EXPORT size_t mspace_footprint(mspace msp);
-
-// /*
-//   mspace_max_footprint() returns the peak number of bytes obtained from the
-//   system for this space.
-// */
-// DLMALLOC_EXPORT size_t mspace_max_footprint(mspace msp);
-
-
-// #if !NO_MALLINFO
-// /*
-//   mspace_mallinfo behaves as mallinfo, but reports properties of
-//   the given space.
-// */
-// DLMALLOC_EXPORT struct mallinfo mspace_mallinfo(mspace msp);
-// #endif /* NO_MALLINFO */
-
-// /*
-//   malloc_usable_size(void* p) behaves the same as malloc_usable_size;
-// */
-// DLMALLOC_EXPORT size_t mspace_usable_size(const void* mem);
-
-// /*
-//   mspace_malloc_stats behaves as malloc_stats, but reports
-//   properties of the given space.
-// */
-// DLMALLOC_EXPORT void mspace_malloc_stats(mspace msp);
-
-// /*
-//   mspace_trim behaves as malloc_trim, but
-//   operates within the given space.
-// */
-// DLMALLOC_EXPORT int mspace_trim(mspace msp, size_t pad);
-
-// /*
-//   An alias for mallopt.
-// */
-// DLMALLOC_EXPORT int mspace_mallopt(int, int);
-
-// #endif /* MSPACES */
-
-// #ifdef __cplusplus
-// }  /* end of extern "C" */
-// #endif /* __cplusplus */
-
-// /*
-//   ========================================================================
-//   To make a fully customizable malloc.h header file, cut everything
-//   above this line, put into file malloc.h, edit to suit, and #include it
-//   on the next line, as well as in programs that use this malloc.
-//   ========================================================================
-// */
-
-// /* #include "malloc.h" */
-
-// /*------------------------------ internal #includes ---------------------- */
-
-// #ifdef _MSC_VER
-// #pragma warning( disable : 4146 ) /* no "unsigned" warnings */
-// #endif /* _MSC_VER */
-// #if !NO_MALLOC_STATS
-// #include <stdio.h>       /* for printing in malloc_stats */
-// #endif /* NO_MALLOC_STATS */
-// #ifndef LACKS_ERRNO_H
-// #include <errno.h>       /* for MALLOC_FAILURE_ACTION */
-// #endif /* LACKS_ERRNO_H */
-// #ifdef DEBUG
-// #if ABORT_ON_ASSERT_FAILURE
-// #undef assert
-// #define assert(x) if(!(x)) ABORT
-// #else /* ABORT_ON_ASSERT_FAILURE */
-// #include <assert.h>
-// #endif /* ABORT_ON_ASSERT_FAILURE */
-// #else  /* DEBUG */
-// #ifndef assert
-// #define assert(x)
-// #endif
-// #define DEBUG 0
-// #endif /* DEBUG */
-// #if !defined(WIN32) && !defined(LACKS_TIME_H)
-// #include <time.h>        /* for magic initialization */
-// #endif /* WIN32 */
-// #ifndef LACKS_STDLIB_H
-// #include <stdlib.h>      /* for abort() */
-// #endif /* LACKS_STDLIB_H */
-// #ifndef LACKS_STRING_H
-// #include <string.h>      /* for memset etc */
-// #endif  /* LACKS_STRING_H */
-// #if USE_BUILTIN_FFS
-// #ifndef LACKS_STRINGS_H
-// #include <strings.h>     /* for ffs */
-// #endif /* LACKS_STRINGS_H */
-// #endif /* USE_BUILTIN_FFS */
-// #if HAVE_MMAP
-// #ifndef LACKS_SYS_MMAN_H
-// /* On some versions of linux, mremap decl in mman.h needs __USE_GNU set */
-// #if (defined(linux) && !defined(__USE_GNU))
-// #define __USE_GNU 1
-// #include <sys/mman.h>    /* for mmap */
-// #undef __USE_GNU
-// #else
-// #include <sys/mman.h>    /* for mmap */
-// #endif /* linux */
-// #endif /* LACKS_SYS_MMAN_H */
-// #ifndef LACKS_FCNTL_H
-// #include <fcntl.h>
-// #endif /* LACKS_FCNTL_H */
-// #endif /* HAVE_MMAP */
-// #ifndef LACKS_UNISTD_H
-// #include <unistd.h>     /* for sbrk, sysconf */
-// #else /* LACKS_UNISTD_H */
-// #if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
-// extern void*     sbrk(ptrdiff_t);
-// #endif /* FreeBSD etc */
-// #endif /* LACKS_UNISTD_H */
-
-// /* Declarations for locking */
-// #if USE_LOCKS
-// #ifndef WIN32
-// #if defined (__SVR4) && defined (__sun)  /* solaris */
-// #include <thread.h>
-// #elif !defined(LACKS_SCHED_H)
-// #include <sched.h>
-// #endif /* solaris or LACKS_SCHED_H */
-// #if (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0) || !USE_SPIN_LOCKS
-// #include <pthread.h>
-// #endif /* USE_RECURSIVE_LOCKS ... */
-// #elif defined(_MSC_VER)
-// #ifndef _M_AMD64
-// /* These are already defined on AMD64 builds */
-// #ifdef __cplusplus
-// extern "C" {
-// #endif /* __cplusplus */
-// LONG __cdecl _InterlockedCompareExchange(LONG volatile *Dest, LONG Exchange, LONG Comp);
-// LONG __cdecl _InterlockedExchange(LONG volatile *Target, LONG Value);
-// #ifdef __cplusplus
-// }
-// #endif /* __cplusplus */
-// #endif /* _M_AMD64 */
-// #pragma intrinsic (_InterlockedCompareExchange)
-// #pragma intrinsic (_InterlockedExchange)
-// #define interlockedcompareexchange _InterlockedCompareExchange
-// #define interlockedexchange _InterlockedExchange
-// #elif defined(WIN32) && defined(__GNUC__)
-// #define interlockedcompareexchange(a, b, c) __sync_val_compare_and_swap(a, c, b)
-// #define interlockedexchange __sync_lock_test_and_set
-// #endif /* Win32 */
-// #else /* USE_LOCKS */
-// #endif /* USE_LOCKS */
-
-// #ifndef LOCK_AT_FORK
-// #define LOCK_AT_FORK 0
-// #endif
-
-// /* Declarations for bit scanning on win32 */
-// #if defined(_MSC_VER) && _MSC_VER>=1300
-// #ifndef BitScanForward /* Try to avoid pulling in WinNT.h */
-// #ifdef __cplusplus
-// extern "C" {
-// #endif /* __cplusplus */
-// unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
-// unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
-// #ifdef __cplusplus
-// }
-// #endif /* __cplusplus */
-
-// #define BitScanForward _BitScanForward
-// #define BitScanReverse _BitScanReverse
-// #pragma intrinsic(_BitScanForward)
-// #pragma intrinsic(_BitScanReverse)
-// #endif /* BitScanForward */
-// #endif /* defined(_MSC_VER) && _MSC_VER>=1300 */
-
-// #ifndef WIN32
-// #ifndef malloc_getpagesize
-// #  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
-// #    ifndef _SC_PAGE_SIZE
-// #      define _SC_PAGE_SIZE _SC_PAGESIZE
-// #    endif
-// #  endif
-// #  ifdef _SC_PAGE_SIZE
-// #    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
-// #  else
-// #    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
-//        extern size_t getpagesize();
-// #      define malloc_getpagesize getpagesize()
-// #    else
-// #      ifdef WIN32 /* use supplied emulation of getpagesize */
-// #        define malloc_getpagesize getpagesize()
-// #      else
-// #        ifndef LACKS_SYS_PARAM_H
-// #          include <sys/param.h>
-// #        endif
-// #        ifdef EXEC_PAGESIZE
-// #          define malloc_getpagesize EXEC_PAGESIZE
-// #        else
-// #          ifdef NBPG
-// #            ifndef CLSIZE
-// #              define malloc_getpagesize NBPG
-// #            else
-// #              define malloc_getpagesize (NBPG * CLSIZE)
-// #            endif
-// #          else
-// #            ifdef NBPC
-// #              define malloc_getpagesize NBPC
-// #            else
-// #              ifdef PAGESIZE
-// #                define malloc_getpagesize PAGESIZE
-// #              else /* just guess */
-// #                define malloc_getpagesize ((size_t)4096U)
-// #              endif
-// #            endif
-// #          endif
-// #        endif
-// #      endif
-// #    endif
-// #  endif
-// #endif
-// #endif
-
-// /* ------------------- size_t and alignment properties -------------------- */
-
-// /* The byte and bit size of a size_t */
-// #define SIZE_T_SIZE         (sizeof(size_t))
-// #define SIZE_T_BITSIZE      (sizeof(size_t) << 3)
-
-// /* Some constants coerced to size_t */
-// /* Annoying but necessary to avoid errors on some platforms */
-// #define SIZE_T_ZERO         ((size_t)0)
-// #define SIZE_T_ONE          ((size_t)1)
-// #define SIZE_T_TWO          ((size_t)2)
-// #define SIZE_T_FOUR         ((size_t)4)
-// #define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)
-// #define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)
-// #define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
-// #define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)
-
-// /* The bit mask value corresponding to MALLOC_ALIGNMENT */
-// #define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)
-
-// /* True if address a has acceptable alignment */
-// #define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)
-
-// /* the number of bytes to offset an address to align it */
-// #define align_offset(A)\
-//  ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\
-//   ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))
-
-// /* -------------------------- MMAP preliminaries ------------------------- */
-
-// /*
-//    If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and
-//    checks to fail so compiler optimizer can delete code rather than
-//    using so many "#if"s.
-// */
-
-
-// /* MORECORE and MMAP must return MFAIL on failure */
-// #define MFAIL                ((void*)(MAX_SIZE_T))
-// #define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */
-
-// #if HAVE_MMAP
-
-// #ifndef WIN32
-// #define MUNMAP_DEFAULT(a, s)  munmap((a), (s))
-// #define MMAP_PROT            (PROT_READ|PROT_WRITE)
-// #if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
-// #define MAP_ANONYMOUS        MAP_ANON
-// #endif /* MAP_ANON */
-// #ifdef MAP_ANONYMOUS
-// #define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)
-// #define MMAP_DEFAULT(s)       mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
-// #else /* MAP_ANONYMOUS */
-// /*
-//    Nearly all versions of mmap support MAP_ANONYMOUS, so the following
-//    is unlikely to be needed, but is supplied just in case.
-// */
-// #define MMAP_FLAGS           (MAP_PRIVATE)
-// static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
-// #define MMAP_DEFAULT(s) ((dev_zero_fd < 0) ? \
-//            (dev_zero_fd = open("/dev/zero", O_RDWR), \
-//             mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
-//             mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
-// #endif /* MAP_ANONYMOUS */
-
-// #define DIRECT_MMAP_DEFAULT(s) MMAP_DEFAULT(s)
-
-// #else /* WIN32 */
-
-// /* Win32 MMAP via VirtualAlloc */
-// static FORCEINLINE void* win32mmap(size_t size) {
-//   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
-//   return (ptr != 0)? ptr: MFAIL;
-// }
-
-// /* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
-// static FORCEINLINE void* win32direct_mmap(size_t size) {
-//   void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
-//                            PAGE_READWRITE);
-//   return (ptr != 0)? ptr: MFAIL;
-// }
-
-// /* This function supports releasing coalesed segments */
-// static FORCEINLINE int win32munmap(void* ptr, size_t size) {
-//   MEMORY_BASIC_INFORMATION minfo;
-//   char* cptr = (char*)ptr;
-//   while (size) {
-//     if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)
-//       return -1;
-//     if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
-//         minfo.State != MEM_COMMIT || minfo.RegionSize > size)
-//       return -1;
-//     if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)
-//       return -1;
-//     cptr += minfo.RegionSize;
-//     size -= minfo.RegionSize;
-//   }
-//   return 0;
-// }
-
-// #define MMAP_DEFAULT(s)             win32mmap(s)
-// #define MUNMAP_DEFAULT(a, s)        win32munmap((a), (s))
-// #define DIRECT_MMAP_DEFAULT(s)      win32direct_mmap(s)
-// #endif /* WIN32 */
-// #endif /* HAVE_MMAP */
-
-// #if HAVE_MREMAP
-// #ifndef WIN32
-// #define MREMAP_DEFAULT(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
-// #endif /* WIN32 */
-// #endif /* HAVE_MREMAP */
-
-// /**
-//  * Define CALL_MORECORE
-//  */
-// #if HAVE_MORECORE
-//     #ifdef MORECORE
-//         #define CALL_MORECORE(S)    MORECORE(S)
-//     #else  /* MORECORE */
-//         #define CALL_MORECORE(S)    MORECORE_DEFAULT(S)
-//     #endif /* MORECORE */
-// #else  /* HAVE_MORECORE */
-//     #define CALL_MORECORE(S)        MFAIL
-// #endif /* HAVE_MORECORE */
-
-// /**
-//  * Define CALL_MMAP/CALL_MUNMAP/CALL_DIRECT_MMAP
-//  */
-// #if HAVE_MMAP
-//     #define USE_MMAP_BIT            (SIZE_T_ONE)
-
-//     #ifdef MMAP
-//         #define CALL_MMAP(s)        MMAP(s)
-//     #else /* MMAP */
-//         #define CALL_MMAP(s)        MMAP_DEFAULT(s)
-//     #endif /* MMAP */
-//     #ifdef MUNMAP
-//         #define CALL_MUNMAP(a, s)   MUNMAP((a), (s))
-//     #else /* MUNMAP */
-//         #define CALL_MUNMAP(a, s)   MUNMAP_DEFAULT((a), (s))
-//     #endif /* MUNMAP */
-//     #ifdef DIRECT_MMAP
-//         #define CALL_DIRECT_MMAP(s) DIRECT_MMAP(s)
-//     #else /* DIRECT_MMAP */
-//         #define CALL_DIRECT_MMAP(s) DIRECT_MMAP_DEFAULT(s)
-//     #endif /* DIRECT_MMAP */
-// #else  /* HAVE_MMAP */
-//     #define USE_MMAP_BIT            (SIZE_T_ZERO)
-
-//     #define MMAP(s)                 MFAIL
-//     #define MUNMAP(a, s)            (-1)
-//     #define DIRECT_MMAP(s)          MFAIL
-//     #define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
-//     #define CALL_MMAP(s)            MMAP(s)
-//     #define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
-// #endif /* HAVE_MMAP */
-
-// /**
-//  * Define CALL_MREMAP
-//  */
-// #if HAVE_MMAP && HAVE_MREMAP
-//     #ifdef MREMAP
-//         #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP((addr), (osz), (nsz), (mv))
-//     #else /* MREMAP */
-//         #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP_DEFAULT((addr), (osz), (nsz), (mv))
-//     #endif /* MREMAP */
-// #else  /* HAVE_MMAP && HAVE_MREMAP */
-//     #define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL
-// #endif /* HAVE_MMAP && HAVE_MREMAP */
-
-// /* mstate bit set if continguous morecore disabled or failed */
-// #define USE_NONCONTIGUOUS_BIT (4U)
-
-// /* segment bit set in create_mspace_with_base */
-// #define EXTERN_BIT            (8U)
-
-
-// /* --------------------------- Lock preliminaries ------------------------ */
-
-// /*
-//   When locks are defined, there is one global lock, plus
-//   one per-mspace lock.
-
-//   The global lock_ensures that mparams.magic and other unique
-//   mparams values are initialized only once. It also protects
-//   sequences of calls to MORECORE.  In many cases sys_alloc requires
-//   two calls, that should not be interleaved with calls by other
-//   threads.  This does not protect against direct calls to MORECORE
-//   by other threads not using this lock, so there is still code to
-//   cope the best we can on interference.
-
-//   Per-mspace locks surround calls to malloc, free, etc.
-//   By default, locks are simple non-reentrant mutexes.
-
-//   Because lock-protected regions generally have bounded times, it is
-//   OK to use the supplied simple spinlocks. Spinlocks are likely to
-//   improve performance for lightly contended applications, but worsen
-//   performance under heavy contention.
-
-//   If USE_LOCKS is > 1, the definitions of lock routines here are
-//   bypassed, in which case you will need to define the type MLOCK_T,
-//   and at least INITIAL_LOCK, DESTROY_LOCK, ACQUIRE_LOCK, RELEASE_LOCK
-//   and TRY_LOCK.  You must also declare a
-//     static MLOCK_T malloc_global_mutex = { initialization values };.
-
-// */
-
-// #if !USE_LOCKS
-// #define USE_LOCK_BIT               (0U)
-// #define INITIAL_LOCK(l)            (0)
-// #define DESTROY_LOCK(l)            (0)
-// #define ACQUIRE_MALLOC_GLOBAL_LOCK()
-// #define RELEASE_MALLOC_GLOBAL_LOCK()
-
-// #else
-// #if USE_LOCKS > 1
-// /* -----------------------  User-defined locks ------------------------ */
-// /* Define your own lock implementation here */
-// /* #define INITIAL_LOCK(lk)  ... */
-// /* #define DESTROY_LOCK(lk)  ... */
-// /* #define ACQUIRE_LOCK(lk)  ... */
-// /* #define RELEASE_LOCK(lk)  ... */
-// /* #define TRY_LOCK(lk) ... */
-// /* static MLOCK_T malloc_global_mutex = ... */
-
-// #elif USE_SPIN_LOCKS
-
-// /* First, define CAS_LOCK and CLEAR_LOCK on ints */
-// /* Note CAS_LOCK defined to return 0 on success */
-
-// #if defined(__GNUC__)&& (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
-// #define CAS_LOCK(sl)     __sync_lock_test_and_set(sl, 1)
-// #define CLEAR_LOCK(sl)   __sync_lock_release(sl)
-
-// #elif (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))
-// /* Custom spin locks for older gcc on x86 */
-// static FORCEINLINE int x86_cas_lock(int *sl) {
-//   int ret;
-//   int val = 1;
-//   int cmp = 0;
-//   __asm__ __volatile__  ("lock; cmpxchgl %1, %2"
-//                          : "=a" (ret)
-//                          : "r" (val), "m" (*(sl)), "0"(cmp)
-//                          : "memory", "cc");
-//   return ret;
-// }
-
-// static FORCEINLINE void x86_clear_lock(int* sl) {
-//   assert(*sl != 0);
-//   int prev = 0;
-//   int ret;
-//   __asm__ __volatile__ ("lock; xchgl %0, %1"
-//                         : "=r" (ret)
-//                         : "m" (*(sl)), "0"(prev)
-//                         : "memory");
-// }
-
-// #define CAS_LOCK(sl)     x86_cas_lock(sl)
-// #define CLEAR_LOCK(sl)   x86_clear_lock(sl)
-
-// #else /* Win32 MSC */
-// #define CAS_LOCK(sl)     interlockedexchange(sl, (LONG)1)
-// #define CLEAR_LOCK(sl)   interlockedexchange (sl, (LONG)0)
-
-// #endif /* ... gcc spins locks ... */
-
-// /* How to yield for a spin lock */
-// #define SPINS_PER_YIELD       63
-// #if defined(_MSC_VER)
-// #define SLEEP_EX_DURATION     50 /* delay for yield/sleep */
-// #define SPIN_LOCK_YIELD  SleepEx(SLEEP_EX_DURATION, FALSE)
-// #elif defined (__SVR4) && defined (__sun) /* solaris */
-// #define SPIN_LOCK_YIELD   thr_yield();
-// #elif !defined(LACKS_SCHED_H)
-// #define SPIN_LOCK_YIELD   sched_yield();
-// #else
-// #define SPIN_LOCK_YIELD
-// #endif /* ... yield ... */
-
-// #if !defined(USE_RECURSIVE_LOCKS) || USE_RECURSIVE_LOCKS == 0
-// /* Plain spin locks use single word (embedded in malloc_states) */
-// static int spin_acquire_lock(int *sl) {
-//   int spins = 0;
-//   while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {
-//     if ((++spins & SPINS_PER_YIELD) == 0) {
-//       SPIN_LOCK_YIELD;
-//     }
-//   }
-//   return 0;
-// }
-
-// #define MLOCK_T               int
-// #define TRY_LOCK(sl)          !CAS_LOCK(sl)
-// #define RELEASE_LOCK(sl)      CLEAR_LOCK(sl)
-// #define ACQUIRE_LOCK(sl)      (CAS_LOCK(sl)? spin_acquire_lock(sl) : 0)
-// #define INITIAL_LOCK(sl)      (*sl = 0)
-// #define DESTROY_LOCK(sl)      (0)
-// static MLOCK_T malloc_global_mutex = 0;
-
-// #else /* USE_RECURSIVE_LOCKS */
-// /* types for lock owners */
-// #ifdef WIN32
-// #define THREAD_ID_T           DWORD
-// #define CURRENT_THREAD        GetCurrentThreadId()
-// #define EQ_OWNER(X,Y)         ((X) == (Y))
-// #else
-// /*
-//   Note: the following assume that pthread_t is a type that can be
-//   initialized to (casted) zero. If this is not the case, you will need to
-//   somehow redefine these or not use spin locks.
-// */
-// #define THREAD_ID_T           pthread_t
-// #define CURRENT_THREAD        pthread_self()
-// #define EQ_OWNER(X,Y)         pthread_equal(X, Y)
-// #endif
-
-// struct malloc_recursive_lock {
-//   int sl;
-//   unsigned int c;
-//   THREAD_ID_T threadid;
-// };
-
-// #define MLOCK_T  struct malloc_recursive_lock
-// static MLOCK_T malloc_global_mutex = { 0, 0, (THREAD_ID_T)0};
-
-// static FORCEINLINE void recursive_release_lock(MLOCK_T *lk) {
-//   assert(lk->sl != 0);
-//   if (--lk->c == 0) {
-//     CLEAR_LOCK(&lk->sl);
-//   }
-// }
-
-// static FORCEINLINE int recursive_acquire_lock(MLOCK_T *lk) {
-//   THREAD_ID_T mythreadid = CURRENT_THREAD;
-//   int spins = 0;
-//   for (;;) {
-//     if (*((volatile int *)(&lk->sl)) == 0) {
-//       if (!CAS_LOCK(&lk->sl)) {
-//         lk->threadid = mythreadid;
-//         lk->c = 1;
-//         return 0;
-//       }
-//     }
-//     else if (EQ_OWNER(lk->threadid, mythreadid)) {
-//       ++lk->c;
-//       return 0;
-//     }
-//     if ((++spins & SPINS_PER_YIELD) == 0) {
-//       SPIN_LOCK_YIELD;
-//     }
-//   }
-// }
-
-// static FORCEINLINE int recursive_try_lock(MLOCK_T *lk) {
-//   THREAD_ID_T mythreadid = CURRENT_THREAD;
-//   if (*((volatile int *)(&lk->sl)) == 0) {
-//     if (!CAS_LOCK(&lk->sl)) {
-//       lk->threadid = mythreadid;
-//       lk->c = 1;
-//       return 1;
-//     }
-//   }
-//   else if (EQ_OWNER(lk->threadid, mythreadid)) {
-//     ++lk->c;
-//     return 1;
-//   }
-//   return 0;
-// }
-
-// #define RELEASE_LOCK(lk)      recursive_release_lock(lk)
-// #define TRY_LOCK(lk)          recursive_try_lock(lk)
-// #define ACQUIRE_LOCK(lk)      recursive_acquire_lock(lk)
-// #define INITIAL_LOCK(lk)      ((lk)->threadid = (THREAD_ID_T)0, (lk)->sl = 0, (lk)->c = 0)
-// #define DESTROY_LOCK(lk)      (0)
-// #endif /* USE_RECURSIVE_LOCKS */
-
-// #elif defined(WIN32) /* Win32 critical sections */
-// #define MLOCK_T               CRITICAL_SECTION
-// #define ACQUIRE_LOCK(lk)      (EnterCriticalSection(lk), 0)
-// #define RELEASE_LOCK(lk)      LeaveCriticalSection(lk)
-// #define TRY_LOCK(lk)          TryEnterCriticalSection(lk)
-// #define INITIAL_LOCK(lk)      (!InitializeCriticalSectionAndSpinCount((lk), 0x80000000|4000))
-// #define DESTROY_LOCK(lk)      (DeleteCriticalSection(lk), 0)
-// #define NEED_GLOBAL_LOCK_INIT
-
-// static MLOCK_T malloc_global_mutex;
-// static volatile LONG malloc_global_mutex_status;
-
-// /* Use spin loop to initialize global lock */
-// static void init_malloc_global_mutex() {
-//   for (;;) {
-//     long stat = malloc_global_mutex_status;
-//     if (stat > 0)
-//       return;
-//     /* transition to < 0 while initializing, then to > 0) */
-//     if (stat == 0 &&
-//         interlockedcompareexchange(&malloc_global_mutex_status, (LONG)-1, (LONG)0) == 0) {
-//       InitializeCriticalSection(&malloc_global_mutex);
-//       interlockedexchange(&malloc_global_mutex_status, (LONG)1);
-//       return;
-//     }
-//     SleepEx(0, FALSE);
-//   }
-// }
-
-// #else /* pthreads-based locks */
-// #define MLOCK_T               pthread_mutex_t
-// #define ACQUIRE_LOCK(lk)      pthread_mutex_lock(lk)
-// #define RELEASE_LOCK(lk)      pthread_mutex_unlock(lk)
-// #define TRY_LOCK(lk)          (!pthread_mutex_trylock(lk))
-// #define INITIAL_LOCK(lk)      pthread_init_lock(lk)
-// #define DESTROY_LOCK(lk)      pthread_mutex_destroy(lk)
-
-// #if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0 && defined(linux) && !defined(PTHREAD_MUTEX_RECURSIVE)
-// /* Cope with old-style linux recursive lock initialization by adding */
-// /* skipped internal declaration from pthread.h */
-// extern int pthread_mutexattr_setkind_np __P ((pthread_mutexattr_t *__attr,
-//                                               int __kind));
-// #define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
-// #define pthread_mutexattr_settype(x,y) pthread_mutexattr_setkind_np(x,y)
-// #endif /* USE_RECURSIVE_LOCKS ... */
-
-// static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-// static int pthread_init_lock (MLOCK_T *lk) {
-//   pthread_mutexattr_t attr;
-//   if (pthread_mutexattr_init(&attr)) return 1;
-// #if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0
-//   if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
-// #endif
-//   if (pthread_mutex_init(lk, &attr)) return 1;
-//   if (pthread_mutexattr_destroy(&attr)) return 1;
-//   return 0;
-// }
-
-// #endif /* ... lock types ... */
-
-// /* Common code for all lock types */
-// #define USE_LOCK_BIT               (2U)
-
-// #ifndef ACQUIRE_MALLOC_GLOBAL_LOCK
-// #define ACQUIRE_MALLOC_GLOBAL_LOCK()  ACQUIRE_LOCK(&malloc_global_mutex);
-// #endif
-
-// #ifndef RELEASE_MALLOC_GLOBAL_LOCK
-// #define RELEASE_MALLOC_GLOBAL_LOCK()  RELEASE_LOCK(&malloc_global_mutex);
-// #endif
-
-// #endif /* USE_LOCKS */
-
-// /* -----------------------  Chunk representations ------------------------ */
-
-// /*
-//   (The following includes lightly edited explanations by Colin Plumb.)
-
-//   The malloc_chunk declaration below is misleading (but accurate and
-//   necessary).  It declares a "view" into memory allowing access to
-//   necessary fields at known offsets from a given base.
-
-//   Chunks of memory are maintained using a `boundary tag' method as
-//   originally described by Knuth.  (See the paper by Paul Wilson
-//   ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
-//   techniques.)  Sizes of free chunks are stored both in the front of
-//   each chunk and at the end.  This makes consolidating fragmented
-//   chunks into bigger chunks fast.  The head fields also hold bits
-//   representing whether chunks are free or in use.
-
-//   Here are some pictures to make it clearer.  They are "exploded" to
-//   show that the state of a chunk can be thought of as extending from
-//   the high 31 bits of the head field of its header through the
-//   prev_foot and PINUSE_BIT bit of the following chunk header.
-
-//   A chunk that's in use looks like:
-
-//    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//            | Size of previous chunk (if P = 0)                             |
-//            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
-//          | Size of this chunk                                         1| +-+
-//    mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          |                                                               |
-//          +-                                                             -+
-//          |                                                               |
-//          +-                                                             -+
-//          |                                                               :
-//          +-      size - sizeof(size_t) available payload bytes          -+
-//          :                                                               |
-//  chunk-> +-                                                             -+
-//          |                                                               |
-//          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
-//        | Size of next chunk (may or may not be in use)               | +-+
-//  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-//     And if it's free, it looks like this:
-
-//    chunk-> +-                                                             -+
-//            | User payload (must be in use, or we would have merged!)       |
-//            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
-//          | Size of this chunk                                         0| +-+
-//    mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          | Next pointer                                                  |
-//          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          | Prev pointer                                                  |
-//          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          |                                                               :
-//          +-      size - sizeof(struct chunk) unused bytes               -+
-//          :                                                               |
-//  chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//          | Size of this chunk                                            |
-//          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
-//        | Size of next chunk (must be in use, or we would have merged)| +-+
-//  mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//        |                                                               :
-//        +- User payload                                                -+
-//        :                                                               |
-//        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//                                                                      |0|
-//                                                                      +-+
-//   Note that since we always merge adjacent free chunks, the chunks
-//   adjacent to a free chunk must be in use.
-
-//   Given a pointer to a chunk (which can be derived trivially from the
-//   payload pointer) we can, in O(1) time, find out whether the adjacent
-//   chunks are free, and if so, unlink them from the lists that they
-//   are on and merge them with the current chunk.
-
-//   Chunks always begin on even word boundaries, so the mem portion
-//   (which is returned to the user) is also on an even word boundary, and
-//   thus at least double-word aligned.
-
-//   The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
-//   chunk size (which is always a multiple of two words), is an in-use
-//   bit for the *previous* chunk.  If that bit is *clear*, then the
-//   word before the current chunk size contains the previous chunk
-//   size, and can be used to find the front of the previous chunk.
-//   The very first chunk allocated always has this bit set, preventing
-//   access to non-existent (or non-owned) memory. If pinuse is set for
-//   any given chunk, then you CANNOT determine the size of the
-//   previous chunk, and might even get a memory addressing fault when
-//   trying to do so.
-
-//   The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
-//   the chunk size redundantly records whether the current chunk is
-//   inuse (unless the chunk is mmapped). This redundancy enables usage
-//   checks within free and realloc, and reduces indirection when freeing
-//   and consolidating chunks.
-
-//   Each freshly allocated chunk must have both cinuse and pinuse set.
-//   That is, each allocated chunk borders either a previously allocated
-//   and still in-use chunk, or the base of its memory arena. This is
-//   ensured by making all allocations from the `lowest' part of any
-//   found chunk.  Further, no free chunk physically borders another one,
-//   so each free chunk is known to be preceded and followed by either
-//   inuse chunks or the ends of memory.
-
-//   Note that the `foot' of the current chunk is actually represented
-//   as the prev_foot of the NEXT chunk. This makes it easier to
-//   deal with alignments etc but can be very confusing when trying
-//   to extend or adapt this code.
-
-//   The exceptions to all this are
-
-//      1. The special chunk `top' is the top-most available chunk (i.e.,
-//         the one bordering the end of available memory). It is treated
-//         specially.  Top is never included in any bin, is used only if
-//         no other chunk is available, and is released back to the
-//         system if it is very large (see M_TRIM_THRESHOLD).  In effect,
-//         the top chunk is treated as larger (and thus less well
-//         fitting) than any other available chunk.  The top chunk
-//         doesn't update its trailing size field since there is no next
-//         contiguous chunk that would have to index off it. However,
-//         space is still allocated for it (TOP_FOOT_SIZE) to enable
-//         separation or merging when space is extended.
-
-//      3. Chunks allocated via mmap, have both cinuse and pinuse bits
-//         cleared in their head fields.  Because they are allocated
-//         one-by-one, each must carry its own prev_foot field, which is
-//         also used to hold the offset this chunk has within its mmapped
-//         region, which is needed to preserve alignment. Each mmapped
-//         chunk is trailed by the first two fields of a fake next-chunk
-//         for sake of usage checks.
-
-// */
-
-// struct malloc_chunk {
-//   size_t               prev_foot;  /* Size of previous chunk (if free).  */
-//   size_t               head;       /* Size and inuse bits. */
-//   struct malloc_chunk* fd;         /* double links -- used only if free. */
-//   struct malloc_chunk* bk;
-// };
-
-// typedef struct malloc_chunk  mchunk;
-// typedef struct malloc_chunk* mchunkptr;
-// typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
-// typedef unsigned int bindex_t;         /* Described below */
-// typedef unsigned int binmap_t;         /* Described below */
-// typedef unsigned int flag_t;           /* The type of various bit flag sets */
-
-// /* ------------------- Chunks sizes and alignments ----------------------- */
-
-// #define MCHUNK_SIZE         (sizeof(mchunk))
-
-// #if FOOTERS
-// #define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
-// #else /* FOOTERS */
-// #define CHUNK_OVERHEAD      (SIZE_T_SIZE)
-// #endif /* FOOTERS */
-
-// /* MMapped chunks need a second word of overhead ... */
-// #define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
-// /* ... and additional padding for fake next-chunk at foot */
-// #define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)
-
-// /* The smallest size we can malloc is an aligned minimal chunk */
-// #define MIN_CHUNK_SIZE\
-//   ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
-
-// /* conversion from malloc headers to user pointers, and back */
-// #define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
-// #define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
-// /* chunk associated with aligned address A */
-// #define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
-
-// /* Bounds on request (not chunk) sizes. */
-// #define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)
-// #define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
-
-// /* pad request bytes into a usable size */
-// #define pad_request(req) \
-//    (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
-
-// /* pad request, checking for minimum (but not maximum) */
-// #define request2size(req) \
-//   (((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))
-
-
-// /* ------------------ Operations on head and foot fields ----------------- */
-
-// /*
-//   The head field of a chunk is or'ed with PINUSE_BIT when previous
-//   adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
-//   use, unless mmapped, in which case both bits are cleared.
-
-//   FLAG4_BIT is not used by this malloc, but might be useful in extensions.
-// */
-
-// #define PINUSE_BIT          (SIZE_T_ONE)
-// #define CINUSE_BIT          (SIZE_T_TWO)
-// #define FLAG4_BIT           (SIZE_T_FOUR)
-// #define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)
-// #define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
-
-// /* Head value for fenceposts */
-// #define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)
-
-// /* extraction of fields from head words */
-// #define cinuse(p)           ((p)->head & CINUSE_BIT)
-// #define pinuse(p)           ((p)->head & PINUSE_BIT)
-// #define flag4inuse(p)       ((p)->head & FLAG4_BIT)
-// #define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
-// #define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)
-
-// #define chunksize(p)        ((p)->head & ~(FLAG_BITS))
-
-// #define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
-// #define set_flag4(p)        ((p)->head |= FLAG4_BIT)
-// #define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)
-
-// /* Treat space at ptr +/- offset as a chunk */
-// #define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
-// #define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
-
-// /* Ptr to next or previous physical malloc_chunk. */
-// #define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
-// #define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
-
-// /* extract next chunk's pinuse bit */
-// #define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)
-
-// /* Get/set size at footer */
-// #define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
-// #define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
-
-// /* Set size, pinuse bit, and foot */
-// #define set_size_and_pinuse_of_free_chunk(p, s)\
-//   ((p)->head = (s|PINUSE_BIT), set_foot(p, s))
-
-// /* Set size, pinuse bit, foot, and clear next pinuse */
-// #define set_free_with_pinuse(p, s, n)\
-//   (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
-
-// /* Get the internal overhead associated with chunk p */
-// #define overhead_for(p)\
-//  (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
-
-// /* Return true if malloced space is not necessarily cleared */
-// #if MMAP_CLEARS
-// #define calloc_must_clear(p) (!is_mmapped(p))
-// #else /* MMAP_CLEARS */
-// #define calloc_must_clear(p) (1)
-// #endif /* MMAP_CLEARS */
-
-// /* ---------------------- Overlaid data structures ----------------------- */
-
-// /*
-//   When chunks are not in use, they are treated as nodes of either
-//   lists or trees.
-
-//   "Small"  chunks are stored in circular doubly-linked lists, and look
-//   like this:
-
-//     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Size of previous chunk                            |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//     `head:' |             Size of chunk, in bytes                         |P|
-//       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Forward pointer to next chunk in list             |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Back pointer to previous chunk in list            |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Unused space (may be 0 bytes long)                .
-//             .                                                               .
-//             .                                                               |
-// nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//     `foot:' |             Size of chunk, in bytes                           |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-//   Larger chunks are kept in a form of bitwise digital trees (aka
-//   tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
-//   free chunks greater than 256 bytes, their size doesn't impose any
-//   constraints on user chunk sizes.  Each node looks like:
-
-//     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Size of previous chunk                            |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//     `head:' |             Size of chunk, in bytes                         |P|
-//       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Forward pointer to next chunk of same size        |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Back pointer to previous chunk of same size       |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Pointer to left child (child[0])                  |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Pointer to right child (child[1])                 |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Pointer to parent                                 |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             bin index of this chunk                           |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//             |             Unused space                                      .
-//             .                                                               |
-// nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-//     `foot:' |             Size of chunk, in bytes                           |
-//             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
-
-//   Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
-//   of the same size are arranged in a circularly-linked list, with only
-//   the oldest chunk (the next to be used, in our FIFO ordering)
-//   actually in the tree.  (Tree members are distinguished by a non-null
-//   parent pointer.)  If a chunk with the same size an an existing node
-//   is inserted, it is linked off the existing node using pointers that
-//   work in the same way as fd/bk pointers of small chunks.
-
-//   Each tree contains a power of 2 sized range of chunk sizes (the
-//   smallest is 0x100 <= x < 0x180), which is is divided in half at each
-//   tree level, with the chunks in the smaller half of the range (0x100
-//   <= x < 0x140 for the top nose) in the left subtree and the larger
-//   half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
-//   done by inspecting individual bits.
-
-//   Using these rules, each node's left subtree contains all smaller
-//   sizes than its right subtree.  However, the node at the root of each
-//   subtree has no particular ordering relationship to either.  (The
-//   dividing line between the subtree sizes is based on trie relation.)
-//   If we remove the last chunk of a given size from the interior of the
-//   tree, we need to replace it with a leaf node.  The tree ordering
-//   rules permit a node to be replaced by any leaf below it.
-
-//   The smallest chunk in a tree (a common operation in a best-fit
-//   allocator) can be found by walking a path to the leftmost leaf in
-//   the tree.  Unlike a usual binary tree, where we follow left child
-//   pointers until we reach a null, here we follow the right child
-//   pointer any time the left one is null, until we reach a leaf with
-//   both child pointers null. The smallest chunk in the tree will be
-//   somewhere along that path.
-
-//   The worst case number of steps to add, find, or remove a node is
-//   bounded by the number of bits differentiating chunks within
-//   bins. Under current bin calculations, this ranges from 6 up to 21
-//   (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
-//   is of course much better.
-// */
-
-// struct malloc_tree_chunk {
-//   /* The first four fields must be compatible with malloc_chunk */
-//   size_t                    prev_foot;
-//   size_t                    head;
-//   struct malloc_tree_chunk* fd;
-//   struct malloc_tree_chunk* bk;
-
-//   struct malloc_tree_chunk* child[2];
-//   struct malloc_tree_chunk* parent;
-//   bindex_t                  index;
-// };
-
-// typedef struct malloc_tree_chunk  tchunk;
-// typedef struct malloc_tree_chunk* tchunkptr;
-// typedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */
-
-// /* A little helper macro for trees */
-// #define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
-
-// /* ----------------------------- Segments -------------------------------- */
-
-// /*
-//   Each malloc space may include non-contiguous segments, held in a
-//   list headed by an embedded malloc_segment record representing the
-//   top-most space. Segments also include flags holding properties of
-//   the space. Large chunks that are directly allocated by mmap are not
-//   included in this list. They are instead independently created and
-//   destroyed without otherwise keeping track of them.
-
-//   Segment management mainly comes into play for spaces allocated by
-//   MMAP.  Any call to MMAP might or might not return memory that is
-//   adjacent to an existing segment.  MORECORE normally contiguously
-//   extends the current space, so this space is almost always adjacent,
-//   which is simpler and faster to deal with. (This is why MORECORE is
-//   used preferentially to MMAP when both are available -- see
-//   sys_alloc.)  When allocating using MMAP, we don't use any of the
-//   hinting mechanisms (inconsistently) supported in various
-//   implementations of unix mmap, or distinguish reserving from
-//   committing memory. Instead, we just ask for space, and exploit
-//   contiguity when we get it.  It is probably possible to do
-//   better than this on some systems, but no general scheme seems
-//   to be significantly better.
-
-//   Management entails a simpler variant of the consolidation scheme
-//   used for chunks to reduce fragmentation -- new adjacent memory is
-//   normally prepended or appended to an existing segment. However,
-//   there are limitations compared to chunk consolidation that mostly
-//   reflect the fact that segment processing is relatively infrequent
-//   (occurring only when getting memory from system) and that we
-//   don't expect to have huge numbers of segments:
-
-//   * Segments are not indexed, so traversal requires linear scans.  (It
-//     would be possible to index these, but is not worth the extra
-//     overhead and complexity for most programs on most platforms.)
-//   * New segments are only appended to old ones when holding top-most
-//     memory; if they cannot be prepended to others, they are held in
-//     different segments.
-
-//   Except for the top-most segment of an mstate, each segment record
-//   is kept at the tail of its segment. Segments are added by pushing
-//   segment records onto the list headed by &mstate.seg for the
-//   containing mstate.
-
-//   Segment flags control allocation/merge/deallocation policies:
-//   * If EXTERN_BIT set, then we did not allocate this segment,
-//     and so should not try to deallocate or merge with others.
-//     (This currently holds only for the initial segment passed
-//     into create_mspace_with_base.)
-//   * If USE_MMAP_BIT set, the segment may be merged with
-//     other surrounding mmapped segments and trimmed/de-allocated
-//     using munmap.
-//   * If neither bit is set, then the segment was obtained using
-//     MORECORE so can be merged with surrounding MORECORE'd segments
-//     and deallocated/trimmed using MORECORE with negative arguments.
-// */
-
-// struct malloc_segment {
-//   char*        base;             /* base address */
-//   size_t       size;             /* allocated size */
-//   struct malloc_segment* next;   /* ptr to next segment */
-//   flag_t       sflags;           /* mmap and extern flag */
-// };
-
-// #define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT)
-// #define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)
-
-// typedef struct malloc_segment  msegment;
-// typedef struct malloc_segment* msegmentptr;
-
-// /* ---------------------------- malloc_state ----------------------------- */
-
-// /*
-//    A malloc_state holds all of the bookkeeping for a space.
-//    The main fields are:
-
-//   Top
-//     The topmost chunk of the currently active segment. Its size is
-//     cached in topsize.  The actual size of topmost space is
-//     topsize+TOP_FOOT_SIZE, which includes space reserved for adding
-//     fenceposts and segment records if necessary when getting more
-//     space from the system.  The size at which to autotrim top is
-//     cached from mparams in trim_check, except that it is disabled if
-//     an autotrim fails.
-
-//   Designated victim (dv)
-//     This is the preferred chunk for servicing small requests that
-//     don't have exact fits.  It is normally the chunk split off most
-//     recently to service another small request.  Its size is cached in
-//     dvsize. The link fields of this chunk are not maintained since it
-//     is not kept in a bin.
-
-//   SmallBins
-//     An array of bin headers for free chunks.  These bins hold chunks
-//     with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
-//     chunks of all the same size, spaced 8 bytes apart.  To simplify
-//     use in double-linked lists, each bin header acts as a malloc_chunk
-//     pointing to the real first node, if it exists (else pointing to
-//     itself).  This avoids special-casing for headers.  But to avoid
-//     waste, we allocate only the fd/bk pointers of bins, and then use
-//     repositioning tricks to treat these as the fields of a chunk.
-
-//   TreeBins
-//     Treebins are pointers to the roots of trees holding a range of
-//     sizes. There are 2 equally spaced treebins for each power of two
-//     from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
-//     larger.
-
-//   Bin maps
-//     There is one bit map for small bins ("smallmap") and one for
-//     treebins ("treemap).  Each bin sets its bit when non-empty, and
-//     clears the bit when empty.  Bit operations are then used to avoid
-//     bin-by-bin searching -- nearly all "search" is done without ever
-//     looking at bins that won't be selected.  The bit maps
-//     conservatively use 32 bits per map word, even if on 64bit system.
-//     For a good description of some of the bit-based techniques used
-//     here, see Henry S. Warren Jr's book "Hacker's Delight" (and
-//     supplement at http://hackersdelight.org/). Many of these are
-//     intended to reduce the branchiness of paths through malloc etc, as
-//     well as to reduce the number of memory locations read or written.
-
-//   Segments
-//     A list of segments headed by an embedded malloc_segment record
-//     representing the initial space.
-
-//   Address check support
-//     The least_addr field is the least address ever obtained from
-//     MORECORE or MMAP. Attempted frees and reallocs of any address less
-//     than this are trapped (unless INSECURE is defined).
-
-//   Magic tag
-//     A cross-check field that should always hold same value as mparams.magic.
-
-//   Max allowed footprint
-//     The maximum allowed bytes to allocate from system (zero means no limit)
-
-//   Flags
-//     Bits recording whether to use MMAP, locks, or contiguous MORECORE
-
-//   Statistics
-//     Each space keeps track of current and maximum system memory
-//     obtained via MORECORE or MMAP.
-
-//   Trim support
-//     Fields holding the amount of unused topmost memory that should trigger
-//     trimming, and a counter to force periodic scanning to release unused
-//     non-topmost segments.
-
-//   Locking
-//     If USE_LOCKS is defined, the "mutex" lock is acquired and released
-//     around every public call using this mspace.
-
-//   Extension support
-//     A void* pointer and a size_t field that can be used to help implement
-//     extensions to this malloc.
-// */
-
-// /* Bin types, widths and sizes */
-// #define NSMALLBINS        (32U)
-// #define NTREEBINS         (32U)
-// #define SMALLBIN_SHIFT    (3U)
-// #define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)
-// #define TREEBIN_SHIFT     (8U)
-// #define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)
-// #define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
-// #define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
-
-// struct malloc_state {
-//   binmap_t   smallmap;
-//   binmap_t   treemap;
-//   size_t     dvsize;
-//   size_t     topsize;
-//   char*      least_addr;
-//   mchunkptr  dv;
-//   mchunkptr  top;
-//   size_t     trim_check;
-//   size_t     release_checks;
-//   size_t     magic;
-//   mchunkptr  smallbins[(NSMALLBINS+1)*2];
-//   tbinptr    treebins[NTREEBINS];
-//   size_t     footprint;
-//   size_t     max_footprint;
-//   size_t     footprint_limit; /* zero means no limit */
-//   flag_t     mflags;
-// #if USE_LOCKS
-//   MLOCK_T    mutex;     /* locate lock among fields that rarely change */
-// #endif /* USE_LOCKS */
-//   msegment   seg;
-//   void*      extp;      /* Unused but available for extensions */
-//   size_t     exts;
-// };
-
-// typedef struct malloc_state*    mstate;
-
-// /* ------------- Global malloc_state and malloc_params ------------------- */
-
-// /*
-//   malloc_params holds global properties, including those that can be
-//   dynamically set using mallopt. There is a single instance, mparams,
-//   initialized in init_mparams. Note that the non-zeroness of "magic"
-//   also serves as an initialization flag.
-// */
-
-// struct malloc_params {
-//   size_t magic;
-//   size_t page_size;
-//   size_t granularity;
-//   size_t mmap_threshold;
-//   size_t trim_threshold;
-//   flag_t default_mflags;
-// };
-
-// static struct malloc_params mparams;
-
-// /* Ensure mparams initialized */
-// #define ensure_initialization() (void)(mparams.magic != 0 || init_mparams())
-
-// #if !ONLY_MSPACES
-
-// /* The global malloc_state used for all non-"mspace" calls */
-// static struct malloc_state _gm_;
-// #define gm                 (&_gm_)
-// #define is_global(M)       ((M) == &_gm_)
-
-// #endif /* !ONLY_MSPACES */
-
-// #define is_initialized(M)  ((M)->top != 0)
-
-// /* -------------------------- system alloc setup ------------------------- */
-
-// /* Operations on mflags */
-
-// #define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)
-// #define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)
-// #if USE_LOCKS
-// #define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)
-// #else
-// #define disable_lock(M)
-// #endif
-
-// #define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)
-// #define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)
-// #if HAVE_MMAP
-// #define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)
-// #else
-// #define disable_mmap(M)
-// #endif
-
-// #define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)
-// #define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)
-
-// #define set_lock(M,L)\
-//  ((M)->mflags = (L)?\
-//   ((M)->mflags | USE_LOCK_BIT) :\
-//   ((M)->mflags & ~USE_LOCK_BIT))
-
-// /* page-align a size */
-// #define page_align(S)\
-//  (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
-
-// /* granularity-align a size */
-// #define granularity_align(S)\
-//   (((S) + (mparams.granularity - SIZE_T_ONE))\
-//    & ~(mparams.granularity - SIZE_T_ONE))
-
-
-// /* For mmap, use granularity alignment on windows, else page-align */
-// #ifdef WIN32
-// #define mmap_align(S) granularity_align(S)
-// #else
-// #define mmap_align(S) page_align(S)
-// #endif
-
-// /* For sys_alloc, enough padding to ensure can malloc request on success */
-// #define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
-
-// #define is_page_aligned(S)\
-//    (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
-// #define is_granularity_aligned(S)\
-//    (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
-
-// /*  True if segment S holds address A */
-// #define segment_holds(S, A)\
-//   ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)
-
-// /* Return segment holding given address */
-// static msegmentptr segment_holding(mstate m, char* addr) {
-//   msegmentptr sp = &m->seg;
-//   for (;;) {
-//     if (addr >= sp->base && addr < sp->base + sp->size)
-//       return sp;
-//     if ((sp = sp->next) == 0)
-//       return 0;
-//   }
-// }
-
-// /* Return true if segment contains a segment link */
-// static int has_segment_link(mstate m, msegmentptr ss) {
-//   msegmentptr sp = &m->seg;
-//   for (;;) {
-//     if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)
-//       return 1;
-//     if ((sp = sp->next) == 0)
-//       return 0;
-//   }
-// }
-
-// #ifndef MORECORE_CANNOT_TRIM
-// #define should_trim(M,s)  ((s) > (M)->trim_check)
-// #else  /* MORECORE_CANNOT_TRIM */
-// #define should_trim(M,s)  (0)
-// #endif /* MORECORE_CANNOT_TRIM */
-
-// /*
-//   TOP_FOOT_SIZE is padding at the end of a segment, including space
-//   that may be needed to place segment records and fenceposts when new
-//   noncontiguous segments are added.
-// */
-// #define TOP_FOOT_SIZE\
-//   (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
-
-
-// /* -------------------------------  Hooks -------------------------------- */
-
-// /*
-//   PREACTION should be defined to return 0 on success, and nonzero on
-//   failure. If you are not using locking, you can redefine these to do
-//   anything you like.
-// */
-
-// #if USE_LOCKS
-// #define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
-// #define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }
-// #else /* USE_LOCKS */
-
-// #ifndef PREACTION
-// #define PREACTION(M) (0)
-// #endif  /* PREACTION */
-
-// #ifndef POSTACTION
-// #define POSTACTION(M)
-// #endif  /* POSTACTION */
-
-// #endif /* USE_LOCKS */
-
-// /*
-//   CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
-//   USAGE_ERROR_ACTION is triggered on detected bad frees and
-//   reallocs. The argument p is an address that might have triggered the
-//   fault. It is ignored by the two predefined actions, but might be
-//   useful in custom actions that try to help diagnose errors.
-// */
-
-// #if PROCEED_ON_ERROR
-
-// /* A count of the number of corruption errors causing resets */
-// int malloc_corruption_error_count;
-
-// /* default corruption action */
-// static void reset_on_error(mstate m);
-
-// #define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)
-// #define USAGE_ERROR_ACTION(m, p)
-
-// #else /* PROCEED_ON_ERROR */
-
-// #ifndef CORRUPTION_ERROR_ACTION
-// #define CORRUPTION_ERROR_ACTION(m) ABORT
-// #endif /* CORRUPTION_ERROR_ACTION */
-
-// #ifndef USAGE_ERROR_ACTION
-// #define USAGE_ERROR_ACTION(m,p) ABORT
-// #endif /* USAGE_ERROR_ACTION */
-
-// #endif /* PROCEED_ON_ERROR */
-
-
-// /* -------------------------- Debugging setup ---------------------------- */
-
-// #if ! DEBUG
-
-// #define check_free_chunk(M,P)
-// #define check_inuse_chunk(M,P)
-// #define check_malloced_chunk(M,P,N)
-// #define check_mmapped_chunk(M,P)
-// #define check_malloc_state(M)
-// #define check_top_chunk(M,P)
-
-// #else /* DEBUG */
-// #define check_free_chunk(M,P)       do_check_free_chunk(M,P)
-// #define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)
-// #define check_top_chunk(M,P)        do_check_top_chunk(M,P)
-// #define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)
-// #define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)
-// #define check_malloc_state(M)       do_check_malloc_state(M)
-
-// static void   do_check_any_chunk(mstate m, mchunkptr p);
-// static void   do_check_top_chunk(mstate m, mchunkptr p);
-// static void   do_check_mmapped_chunk(mstate m, mchunkptr p);
-// static void   do_check_inuse_chunk(mstate m, mchunkptr p);
-// static void   do_check_free_chunk(mstate m, mchunkptr p);
-// static void   do_check_malloced_chunk(mstate m, void* mem, size_t s);
-// static void   do_check_tree(mstate m, tchunkptr t);
-// static void   do_check_treebin(mstate m, bindex_t i);
-// static void   do_check_smallbin(mstate m, bindex_t i);
-// static void   do_check_malloc_state(mstate m);
-// static int    bin_find(mstate m, mchunkptr x);
-// static size_t traverse_and_check(mstate m);
-// #endif /* DEBUG */
-
-// /* ---------------------------- Indexing Bins ---------------------------- */
-
-// #define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
-// #define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
-// #define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
-// #define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
-
-// /* addressing by index. See above about smallbin repositioning */
-// #define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
-// #define treebin_at(M,i)     (&((M)->treebins[i]))
-
-// /* assign tree index for size S to variable I. Use x86 asm if possible  */
-// #if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-// #define compute_tree_index(S, I)\
-// {\
-//   unsigned int X = S >> TREEBIN_SHIFT;\
-//   if (X == 0)\
-//     I = 0;\
-//   else if (X > 0xFFFF)\
-//     I = NTREEBINS-1;\
-//   else {\
-//     unsigned int K = (unsigned) sizeof(X)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(X); \
-//     I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
-//   }\
-// }
-
-// #elif defined (__INTEL_COMPILER)
-// #define compute_tree_index(S, I)\
-// {\
-//   size_t X = S >> TREEBIN_SHIFT;\
-//   if (X == 0)\
-//     I = 0;\
-//   else if (X > 0xFFFF)\
-//     I = NTREEBINS-1;\
-//   else {\
-//     unsigned int K = _bit_scan_reverse (X); \
-//     I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
-//   }\
-// }
-
-// #elif defined(_MSC_VER) && _MSC_VER>=1300
-// #define compute_tree_index(S, I)\
-// {\
-//   size_t X = S >> TREEBIN_SHIFT;\
-//   if (X == 0)\
-//     I = 0;\
-//   else if (X > 0xFFFF)\
-//     I = NTREEBINS-1;\
-//   else {\
-//     unsigned int K;\
-//     _BitScanReverse((DWORD *) &K, (DWORD) X);\
-//     I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
-//   }\
-// }
-
-// #else /* GNUC */
-// #define compute_tree_index(S, I)\
-// {\
-//   size_t X = S >> TREEBIN_SHIFT;\
-//   if (X == 0)\
-//     I = 0;\
-//   else if (X > 0xFFFF)\
-//     I = NTREEBINS-1;\
-//   else {\
-//     unsigned int Y = (unsigned int)X;\
-//     unsigned int N = ((Y - 0x100) >> 16) & 8;\
-//     unsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\
-//     N += K;\
-//     N += K = (((Y <<= K) - 0x4000) >> 16) & 2;\
-//     K = 14 - N + ((Y <<= K) >> 15);\
-//     I = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\
-//   }\
-// }
-// #endif /* GNUC */
-
-// /* Bit representing maximum resolved size in a treebin at i */
-// #define bit_for_tree_index(i) \
-//    (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)
-
-// /* Shift placing maximum resolved bit in a treebin at i as sign bit */
-// #define leftshift_for_tree_index(i) \
-//    ((i == NTREEBINS-1)? 0 : \
-//     ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
-
-// /* The size of the smallest chunk held in bin with index i */
-// #define minsize_for_tree_index(i) \
-//    ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \
-//    (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))
-
-
-// /* ------------------------ Operations on bin maps ----------------------- */
-
-// /* bit corresponding to given index */
-// #define idx2bit(i)              ((binmap_t)(1) << (i))
-
-// /* Mark/Clear bits with given index */
-// #define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
-// #define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
-// #define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))
-
-// #define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
-// #define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
-// #define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))
-
-// /* isolate the least set bit of a bitmap */
-// #define least_bit(x)         ((x) & -(x))
-
-// /* mask with all bits to left of least bit of x on */
-// #define left_bits(x)         ((x<<1) | -(x<<1))
-
-// /* mask with all bits to left of or equal to least bit of x on */
-// #define same_or_left_bits(x) ((x) | -(x))
-
-// /* index corresponding to given bit. Use x86 asm if possible */
-
-// #if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-// #define compute_bit2idx(X, I)\
-// {\
-//   unsigned int J;\
-//   J = __builtin_ctz(X); \
-//   I = (bindex_t)J;\
-// }
-
-// #elif defined (__INTEL_COMPILER)
-// #define compute_bit2idx(X, I)\
-// {\
-//   unsigned int J;\
-//   J = _bit_scan_forward (X); \
-//   I = (bindex_t)J;\
-// }
-
-// #elif defined(_MSC_VER) && _MSC_VER>=1300
-// #define compute_bit2idx(X, I)\
-// {\
-//   unsigned int J;\
-//   _BitScanForward((DWORD *) &J, X);\
-//   I = (bindex_t)J;\
-// }
-
-// #elif USE_BUILTIN_FFS
-// #define compute_bit2idx(X, I) I = ffs(X)-1
-
-// #else
-// #define compute_bit2idx(X, I)\
-// {\
-//   unsigned int Y = X - 1;\
-//   unsigned int K = Y >> (16-4) & 16;\
-//   unsigned int N = K;        Y >>= K;\
-//   N += K = Y >> (8-3) &  8;  Y >>= K;\
-//   N += K = Y >> (4-2) &  4;  Y >>= K;\
-//   N += K = Y >> (2-1) &  2;  Y >>= K;\
-//   N += K = Y >> (1-0) &  1;  Y >>= K;\
-//   I = (bindex_t)(N + Y);\
-// }
-// #endif /* GNUC */
-
-
-// /* ----------------------- Runtime Check Support ------------------------- */
-
-// /*
-//   For security, the main invariant is that malloc/free/etc never
-//   writes to a static address other than malloc_state, unless static
-//   malloc_state itself has been corrupted, which cannot occur via
-//   malloc (because of these checks). In essence this means that we
-//   believe all pointers, sizes, maps etc held in malloc_state, but
-//   check all of those linked or offsetted from other embedded data
-//   structures.  These checks are interspersed with main code in a way
-//   that tends to minimize their run-time cost.
-
-//   When FOOTERS is defined, in addition to range checking, we also
-//   verify footer fields of inuse chunks, which can be used guarantee
-//   that the mstate controlling malloc/free is intact.  This is a
-//   streamlined version of the approach described by William Robertson
-//   et al in "Run-time Detection of Heap-based Overflows" LISA'03
-//   http://www.usenix.org/events/lisa03/tech/robertson.html The footer
-//   of an inuse chunk holds the xor of its mstate and a random seed,
-//   that is checked upon calls to free() and realloc().  This is
-//   (probabalistically) unguessable from outside the program, but can be
-//   computed by any code successfully malloc'ing any chunk, so does not
-//   itself provide protection against code that has already broken
-//   security through some other means.  Unlike Robertson et al, we
-//   always dynamically check addresses of all offset chunks (previous,
-//   next, etc). This turns out to be cheaper than relying on hashes.
-// */
-
-// #if !INSECURE
-// /* Check if address a is at least as high as any from MORECORE or MMAP */
-// #define ok_address(M, a) ((char*)(a) >= (M)->least_addr)
-// /* Check if address of next chunk n is higher than base chunk p */
-// #define ok_next(p, n)    ((char*)(p) < (char*)(n))
-// /* Check if p has inuse status */
-// #define ok_inuse(p)     is_inuse(p)
-// /* Check if p has its pinuse bit on */
-// #define ok_pinuse(p)     pinuse(p)
-
-// #else /* !INSECURE */
-// #define ok_address(M, a) (1)
-// #define ok_next(b, n)    (1)
-// #define ok_inuse(p)      (1)
-// #define ok_pinuse(p)     (1)
-// #endif /* !INSECURE */
-
-// #if (FOOTERS && !INSECURE)
-// /* Check if (alleged) mstate m has expected magic field */
-// #define ok_magic(M)      ((M)->magic == mparams.magic)
-// #else  /* (FOOTERS && !INSECURE) */
-// #define ok_magic(M)      (1)
-// #endif /* (FOOTERS && !INSECURE) */
-
-// /* In gcc, use __builtin_expect to minimize impact of checks */
-// #if !INSECURE
-// #if defined(__GNUC__) && __GNUC__ >= 3
-// #define RTCHECK(e)  __builtin_expect(e, 1)
-// #else /* GNUC */
-// #define RTCHECK(e)  (e)
-// #endif /* GNUC */
-// #else /* !INSECURE */
-// #define RTCHECK(e)  (1)
-// #endif /* !INSECURE */
-
-// /* macros to set up inuse chunks with or without footers */
-
-// #if !FOOTERS
-
-// #define mark_inuse_foot(M,p,s)
-
-// /* Macros for setting head/foot of non-mmapped chunks */
-
-// /* Set cinuse bit and pinuse bit of next chunk */
-// #define set_inuse(M,p,s)\
-//   ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
-//   ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
-
-// /* Set cinuse and pinuse of this chunk and pinuse of next chunk */
-// #define set_inuse_and_pinuse(M,p,s)\
-//   ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
-//   ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
-
-// /* Set size, cinuse and pinuse bit of this chunk */
-// #define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
-//   ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))
-
-// #else /* FOOTERS */
-
-// /* Set foot of inuse chunk to be xor of mstate and seed */
-// #define mark_inuse_foot(M,p,s)\
-//   (((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))
-
-// #define get_mstate_for(p)\
-//   ((mstate)(((mchunkptr)((char*)(p) +\
-//     (chunksize(p))))->prev_foot ^ mparams.magic))
-
-// #define set_inuse(M,p,s)\
-//   ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
-//   (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \
-//   mark_inuse_foot(M,p,s))
-
-// #define set_inuse_and_pinuse(M,p,s)\
-//   ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
-//   (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\
-//  mark_inuse_foot(M,p,s))
-
-// #define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
-//   ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
-//   mark_inuse_foot(M, p, s))
-
-// #endif /* !FOOTERS */
-
-// /* ---------------------------- setting mparams -------------------------- */
-
-// #if LOCK_AT_FORK
-// static void pre_fork(void)         { ACQUIRE_LOCK(&(gm)->mutex); }
-// static void post_fork_parent(void) { RELEASE_LOCK(&(gm)->mutex); }
-// static void post_fork_child(void)  { INITIAL_LOCK(&(gm)->mutex); }
-// #endif /* LOCK_AT_FORK */
-
-// /* Initialize mparams */
-// static int init_mparams(void) {
-// #ifdef NEED_GLOBAL_LOCK_INIT
-//   if (malloc_global_mutex_status <= 0)
-//     init_malloc_global_mutex();
-// #endif
-
-//   ACQUIRE_MALLOC_GLOBAL_LOCK();
-//   if (mparams.magic == 0) {
-//     size_t magic;
-//     size_t psize;
-//     size_t gsize;
-
-// #ifndef WIN32
-//     psize = malloc_getpagesize;
-//     gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
-// #else /* WIN32 */
-//     {
-//       SYSTEM_INFO system_info;
-//       GetSystemInfo(&system_info);
-//       psize = system_info.dwPageSize;
-//       gsize = ((DEFAULT_GRANULARITY != 0)?
-//                DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);
-//     }
-// #endif /* WIN32 */
-
-//     /* Sanity-check configuration:
-//        size_t must be unsigned and as wide as pointer type.
-//        ints must be at least 4 bytes.
-//        alignment must be at least 8.
-//        Alignment, min chunk size, and page size must all be powers of 2.
-//     */
-//     if ((sizeof(size_t) != sizeof(char*)) ||
-//         (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
-//         (sizeof(int) < 4)  ||
-//         (MALLOC_ALIGNMENT < (size_t)8U) ||
-//         ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
-//         ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
-//         ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
-//         ((psize            & (psize-SIZE_T_ONE))            != 0))
-//       ABORT;
-//     mparams.granularity = gsize;
-//     mparams.page_size = psize;
-//     mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
-//     mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
-// #if MORECORE_CONTIGUOUS
-//     mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
-// #else  /* MORECORE_CONTIGUOUS */
-//     mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
-// #endif /* MORECORE_CONTIGUOUS */
-
-// #if !ONLY_MSPACES
-//     /* Set up lock for main malloc area */
-//     gm->mflags = mparams.default_mflags;
-//     (void)INITIAL_LOCK(&gm->mutex);
-// #endif
-// #if LOCK_AT_FORK
-//     pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);
-// #endif
-
-//     {
-// #if USE_DEV_RANDOM
-//       int fd;
-//       unsigned char buf[sizeof(size_t)];
-//       /* Try to use /dev/urandom, else fall back on using time */
-//       if ((fd = open("/dev/urandom", O_RDONLY)) >= 0 &&
-//           read(fd, buf, sizeof(buf)) == sizeof(buf)) {
-//         magic = *((size_t *) buf);
-//         close(fd);
-//       }
-//       else
-// #endif /* USE_DEV_RANDOM */
-// #ifdef WIN32
-//       magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);
-// #elif defined(LACKS_TIME_H)
-//       magic = (size_t)&magic ^ (size_t)0x55555555U;
-// #else
-//       magic = (size_t)(time(0) ^ (size_t)0x55555555U);
-// #endif
-//       magic |= (size_t)8U;    /* ensure nonzero */
-//       magic &= ~(size_t)7U;   /* improve chances of fault for bad values */
-//       /* Until memory modes commonly available, use volatile-write */
-//       (*(volatile size_t *)(&(mparams.magic))) = magic;
-//     }
-//   }
-
-//   RELEASE_MALLOC_GLOBAL_LOCK();
-//   return 1;
-// }
-
-// /* support for mallopt */
-// static int change_mparam(int param_number, int value) {
-//   size_t val;
-//   ensure_initialization();
-//   val = (value == -1)? MAX_SIZE_T : (size_t)value;
-//   switch(param_number) {
-//   case M_TRIM_THRESHOLD:
-//     mparams.trim_threshold = val;
-//     return 1;
-//   case M_GRANULARITY:
-//     if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
-//       mparams.granularity = val;
-//       return 1;
-//     }
-//     else
-//       return 0;
-//   case M_MMAP_THRESHOLD:
-//     mparams.mmap_threshold = val;
-//     return 1;
-//   default:
-//     return 0;
-//   }
-// }
-
-// #if DEBUG
-// /* ------------------------- Debugging Support --------------------------- */
-
-// /* Check properties of any chunk, whether free, inuse, mmapped etc  */
-// static void do_check_any_chunk(mstate m, mchunkptr p) {
-//   assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
-//   assert(ok_address(m, p));
-// }
-
-// /* Check properties of top chunk */
-// static void do_check_top_chunk(mstate m, mchunkptr p) {
-//   msegmentptr sp = segment_holding(m, (char*)p);
-//   size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
-//   assert(sp != 0);
-//   assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
-//   assert(ok_address(m, p));
-//   assert(sz == m->topsize);
-//   assert(sz > 0);
-//   assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);
-//   assert(pinuse(p));
-//   assert(!pinuse(chunk_plus_offset(p, sz)));
-// }
-
-// /* Check properties of (inuse) mmapped chunks */
-// static void do_check_mmapped_chunk(mstate m, mchunkptr p) {
-//   size_t  sz = chunksize(p);
-//   size_t len = (sz + (p->prev_foot) + MMAP_FOOT_PAD);
-//   assert(is_mmapped(p));
-//   assert(use_mmap(m));
-//   assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
-//   assert(ok_address(m, p));
-//   assert(!is_small(sz));
-//   assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);
-//   assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);
-//   assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0);
-// }
-
-// /* Check properties of inuse chunks */
-// static void do_check_inuse_chunk(mstate m, mchunkptr p) {
-//   do_check_any_chunk(m, p);
-//   assert(is_inuse(p));
-//   assert(next_pinuse(p));
-//   /* If not pinuse and not mmapped, previous chunk has OK offset */
-//   assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);
-//   if (is_mmapped(p))
-//     do_check_mmapped_chunk(m, p);
-// }
-
-// /* Check properties of free chunks */
-// static void do_check_free_chunk(mstate m, mchunkptr p) {
-//   size_t sz = chunksize(p);
-//   mchunkptr next = chunk_plus_offset(p, sz);
-//   do_check_any_chunk(m, p);
-//   assert(!is_inuse(p));
-//   assert(!next_pinuse(p));
-//   assert (!is_mmapped(p));
-//   if (p != m->dv && p != m->top) {
-//     if (sz >= MIN_CHUNK_SIZE) {
-//       assert((sz & CHUNK_ALIGN_MASK) == 0);
-//       assert(is_aligned(chunk2mem(p)));
-//       assert(next->prev_foot == sz);
-//       assert(pinuse(p));
-//       assert (next == m->top || is_inuse(next));
-//       assert(p->fd->bk == p);
-//       assert(p->bk->fd == p);
-//     }
-//     else  /* markers are always of size SIZE_T_SIZE */
-//       assert(sz == SIZE_T_SIZE);
-//   }
-// }
-
-// /* Check properties of malloced chunks at the point they are malloced */
-// static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {
-//   if (mem != 0) {
-//     mchunkptr p = mem2chunk(mem);
-//     size_t sz = p->head & ~INUSE_BITS;
-//     do_check_inuse_chunk(m, p);
-//     assert((sz & CHUNK_ALIGN_MASK) == 0);
-//     assert(sz >= MIN_CHUNK_SIZE);
-//     assert(sz >= s);
-//     /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
-//     assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));
-//   }
-// }
-
-// /* Check a tree and its subtrees.  */
-// static void do_check_tree(mstate m, tchunkptr t) {
-//   tchunkptr head = 0;
-//   tchunkptr u = t;
-//   bindex_t tindex = t->index;
-//   size_t tsize = chunksize(t);
-//   bindex_t idx;
-//   compute_tree_index(tsize, idx);
-//   assert(tindex == idx);
-//   assert(tsize >= MIN_LARGE_SIZE);
-//   assert(tsize >= minsize_for_tree_index(idx));
-//   assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));
-
-//   do { /* traverse through chain of same-sized nodes */
-//     do_check_any_chunk(m, ((mchunkptr)u));
-//     assert(u->index == tindex);
-//     assert(chunksize(u) == tsize);
-//     assert(!is_inuse(u));
-//     assert(!next_pinuse(u));
-//     assert(u->fd->bk == u);
-//     assert(u->bk->fd == u);
-//     if (u->parent == 0) {
-//       assert(u->child[0] == 0);
-//       assert(u->child[1] == 0);
-//     }
-//     else {
-//       assert(head == 0); /* only one node on chain has parent */
-//       head = u;
-//       assert(u->parent != u);
-//       assert (u->parent->child[0] == u ||
-//               u->parent->child[1] == u ||
-//               *((tbinptr*)(u->parent)) == u);
-//       if (u->child[0] != 0) {
-//         assert(u->child[0]->parent == u);
-//         assert(u->child[0] != u);
-//         do_check_tree(m, u->child[0]);
-//       }
-//       if (u->child[1] != 0) {
-//         assert(u->child[1]->parent == u);
-//         assert(u->child[1] != u);
-//         do_check_tree(m, u->child[1]);
-//       }
-//       if (u->child[0] != 0 && u->child[1] != 0) {
-//         assert(chunksize(u->child[0]) < chunksize(u->child[1]));
-//       }
-//     }
-//     u = u->fd;
-//   } while (u != t);
-//   assert(head != 0);
-// }
-
-// /*  Check all the chunks in a treebin.  */
-// static void do_check_treebin(mstate m, bindex_t i) {
-//   tbinptr* tb = treebin_at(m, i);
-//   tchunkptr t = *tb;
-//   int empty = (m->treemap & (1U << i)) == 0;
-//   if (t == 0)
-//     assert(empty);
-//   if (!empty)
-//     do_check_tree(m, t);
-// }
-
-// /*  Check all the chunks in a smallbin.  */
-// static void do_check_smallbin(mstate m, bindex_t i) {
-//   sbinptr b = smallbin_at(m, i);
-//   mchunkptr p = b->bk;
-//   unsigned int empty = (m->smallmap & (1U << i)) == 0;
-//   if (p == b)
-//     assert(empty);
-//   if (!empty) {
-//     for (; p != b; p = p->bk) {
-//       size_t size = chunksize(p);
-//       mchunkptr q;
-//       /* each chunk claims to be free */
-//       do_check_free_chunk(m, p);
-//       /* chunk belongs in bin */
-//       assert(small_index(size) == i);
-//       assert(p->bk == b || chunksize(p->bk) == chunksize(p));
-//       /* chunk is followed by an inuse chunk */
-//       q = next_chunk(p);
-//       if (q->head != FENCEPOST_HEAD)
-//         do_check_inuse_chunk(m, q);
-//     }
-//   }
-// }
-
-// /* Find x in a bin. Used in other check functions. */
-// static int bin_find(mstate m, mchunkptr x) {
-//   size_t size = chunksize(x);
-//   if (is_small(size)) {
-//     bindex_t sidx = small_index(size);
-//     sbinptr b = smallbin_at(m, sidx);
-//     if (smallmap_is_marked(m, sidx)) {
-//       mchunkptr p = b;
-//       do {
-//         if (p == x)
-//           return 1;
-//       } while ((p = p->fd) != b);
-//     }
-//   }
-//   else {
-//     bindex_t tidx;
-//     compute_tree_index(size, tidx);
-//     if (treemap_is_marked(m, tidx)) {
-//       tchunkptr t = *treebin_at(m, tidx);
-//       size_t sizebits = size << leftshift_for_tree_index(tidx);
-//       while (t != 0 && chunksize(t) != size) {
-//         t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
-//         sizebits <<= 1;
-//       }
-//       if (t != 0) {
-//         tchunkptr u = t;
-//         do {
-//           if (u == (tchunkptr)x)
-//             return 1;
-//         } while ((u = u->fd) != t);
-//       }
-//     }
-//   }
-//   return 0;
-// }
-
-// /* Traverse each chunk and check it; return total */
-// static size_t traverse_and_check(mstate m) {
-//   size_t sum = 0;
-//   if (is_initialized(m)) {
-//     msegmentptr s = &m->seg;
-//     sum += m->topsize + TOP_FOOT_SIZE;
-//     while (s != 0) {
-//       mchunkptr q = align_as_chunk(s->base);
-//       mchunkptr lastq = 0;
-//       assert(pinuse(q));
-//       while (segment_holds(s, q) &&
-//              q != m->top && q->head != FENCEPOST_HEAD) {
-//         sum += chunksize(q);
-//         if (is_inuse(q)) {
-//           assert(!bin_find(m, q));
-//           do_check_inuse_chunk(m, q);
-//         }
-//         else {
-//           assert(q == m->dv || bin_find(m, q));
-//           assert(lastq == 0 || is_inuse(lastq)); /* Not 2 consecutive free */
-//           do_check_free_chunk(m, q);
-//         }
-//         lastq = q;
-//         q = next_chunk(q);
-//       }
-//       s = s->next;
-//     }
-//   }
-//   return sum;
-// }
-
-
-// /* Check all properties of malloc_state. */
-// static void do_check_malloc_state(mstate m) {
-//   bindex_t i;
-//   size_t total;
-//   /* check bins */
-//   for (i = 0; i < NSMALLBINS; ++i)
-//     do_check_smallbin(m, i);
-//   for (i = 0; i < NTREEBINS; ++i)
-//     do_check_treebin(m, i);
-
-//   if (m->dvsize != 0) { /* check dv chunk */
-//     do_check_any_chunk(m, m->dv);
-//     assert(m->dvsize == chunksize(m->dv));
-//     assert(m->dvsize >= MIN_CHUNK_SIZE);
-//     assert(bin_find(m, m->dv) == 0);
-//   }
-
-//   if (m->top != 0) {   /* check top chunk */
-//     do_check_top_chunk(m, m->top);
-//     /*assert(m->topsize == chunksize(m->top)); redundant */
-//     assert(m->topsize > 0);
-//     assert(bin_find(m, m->top) == 0);
-//   }
-
-//   total = traverse_and_check(m);
-//   assert(total <= m->footprint);
-//   assert(m->footprint <= m->max_footprint);
-// }
-// #endif /* DEBUG */
-
-// /* ----------------------------- statistics ------------------------------ */
-
-// #if !NO_MALLINFO
-// static struct mallinfo internal_mallinfo(mstate m) {
-//   struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-//   ensure_initialization();
-//   if (!PREACTION(m)) {
-//     check_malloc_state(m);
-//     if (is_initialized(m)) {
-//       size_t nfree = SIZE_T_ONE; /* top always free */
-//       size_t mfree = m->topsize + TOP_FOOT_SIZE;
-//       size_t sum = mfree;
-//       msegmentptr s = &m->seg;
-//       while (s != 0) {
-//         mchunkptr q = align_as_chunk(s->base);
-//         while (segment_holds(s, q) &&
-//                q != m->top && q->head != FENCEPOST_HEAD) {
-//           size_t sz = chunksize(q);
-//           sum += sz;
-//           if (!is_inuse(q)) {
-//             mfree += sz;
-//             ++nfree;
-//           }
-//           q = next_chunk(q);
-//         }
-//         s = s->next;
-//       }
-
-//       nm.arena    = sum;
-//       nm.ordblks  = nfree;
-//       nm.hblkhd   = m->footprint - sum;
-//       nm.usmblks  = m->max_footprint;
-//       nm.uordblks = m->footprint - mfree;
-//       nm.fordblks = mfree;
-//       nm.keepcost = m->topsize;
-//     }
-
-//     POSTACTION(m);
-//   }
-//   return nm;
-// }
-// #endif /* !NO_MALLINFO */
-
-// #if !NO_MALLOC_STATS
-// static void internal_malloc_stats(mstate m) {
-//   ensure_initialization();
-//   if (!PREACTION(m)) {
-//     size_t maxfp = 0;
-//     size_t fp = 0;
-//     size_t used = 0;
-//     check_malloc_state(m);
-//     if (is_initialized(m)) {
-//       msegmentptr s = &m->seg;
-//       maxfp = m->max_footprint;
-//       fp = m->footprint;
-//       used = fp - (m->topsize + TOP_FOOT_SIZE);
-
-//       while (s != 0) {
-//         mchunkptr q = align_as_chunk(s->base);
-//         while (segment_holds(s, q) &&
-//                q != m->top && q->head != FENCEPOST_HEAD) {
-//           if (!is_inuse(q))
-//             used -= chunksize(q);
-//           q = next_chunk(q);
-//         }
-//         s = s->next;
-//       }
-//     }
-//     POSTACTION(m); /* drop lock */
-//     fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));
-//     fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));
-//     fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
-//   }
-// }
-// #endif /* NO_MALLOC_STATS */
-
-// /* ----------------------- Operations on smallbins ----------------------- */
-
-// /*
-//   Various forms of linking and unlinking are defined as macros.  Even
-//   the ones for trees, which are very long but have very short typical
-//   paths.  This is ugly but reduces reliance on inlining support of
-//   compilers.
-// */
-
-// /* Link a free chunk into a smallbin  */
-// #define insert_small_chunk(M, P, S) {\
-//   bindex_t I  = small_index(S);\
-//   mchunkptr B = smallbin_at(M, I);\
-//   mchunkptr F = B;\
-//   assert(S >= MIN_CHUNK_SIZE);\
-//   if (!smallmap_is_marked(M, I))\
-//     mark_smallmap(M, I);\
-//   else if (RTCHECK(ok_address(M, B->fd)))\
-//     F = B->fd;\
-//   else {\
-//     CORRUPTION_ERROR_ACTION(M);\
-//   }\
-//   B->fd = P;\
-//   F->bk = P;\
-//   P->fd = F;\
-//   P->bk = B;\
-// }
-
-// /* Unlink a chunk from a smallbin  */
-// #define unlink_small_chunk(M, P, S) {\
-//   mchunkptr F = P->fd;\
-//   mchunkptr B = P->bk;\
-//   bindex_t I = small_index(S);\
-//   assert(P != B);\
-//   assert(P != F);\
-//   assert(chunksize(P) == small_index2size(I));\
-//   if (RTCHECK(F == smallbin_at(M,I) || (ok_address(M, F) && F->bk == P))) { \
-//     if (B == F) {\
-//       clear_smallmap(M, I);\
-//     }\
-//     else if (RTCHECK(B == smallbin_at(M,I) ||\
-//                      (ok_address(M, B) && B->fd == P))) {\
-//       F->bk = B;\
-//       B->fd = F;\
-//     }\
-//     else {\
-//       CORRUPTION_ERROR_ACTION(M);\
-//     }\
-//   }\
-//   else {\
-//     CORRUPTION_ERROR_ACTION(M);\
-//   }\
-// }
-
-// /* Unlink the first chunk from a smallbin */
-// #define unlink_first_small_chunk(M, B, P, I) {\
-//   mchunkptr F = P->fd;\
-//   assert(P != B);\
-//   assert(P != F);\
-//   assert(chunksize(P) == small_index2size(I));\
-//   if (B == F) {\
-//     clear_smallmap(M, I);\
-//   }\
-//   else if (RTCHECK(ok_address(M, F) && F->bk == P)) {\
-//     F->bk = B;\
-//     B->fd = F;\
-//   }\
-//   else {\
-//     CORRUPTION_ERROR_ACTION(M);\
-//   }\
-// }
-
-// /* Replace dv node, binning the old one */
-// /* Used only when dvsize known to be small */
-// #define replace_dv(M, P, S) {\
-//   size_t DVS = M->dvsize;\
-//   assert(is_small(DVS));\
-//   if (DVS != 0) {\
-//     mchunkptr DV = M->dv;\
-//     insert_small_chunk(M, DV, DVS);\
-//   }\
-//   M->dvsize = S;\
-//   M->dv = P;\
-// }
-
-// /* ------------------------- Operations on trees ------------------------- */
-
-// /* Insert chunk into tree */
-// #define insert_large_chunk(M, X, S) {\
-//   tbinptr* H;\
-//   bindex_t I;\
-//   compute_tree_index(S, I);\
-//   H = treebin_at(M, I);\
-//   X->index = I;\
-//   X->child[0] = X->child[1] = 0;\
-//   if (!treemap_is_marked(M, I)) {\
-//     mark_treemap(M, I);\
-//     *H = X;\
-//     X->parent = (tchunkptr)H;\
-//     X->fd = X->bk = X;\
-//   }\
-//   else {\
-//     tchunkptr T = *H;\
-//     size_t K = S << leftshift_for_tree_index(I);\
-//     for (;;) {\
-//       if (chunksize(T) != S) {\
-//         tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
-//         K <<= 1;\
-//         if (*C != 0)\
-//           T = *C;\
-//         else if (RTCHECK(ok_address(M, C))) {\
-//           *C = X;\
-//           X->parent = T;\
-//           X->fd = X->bk = X;\
-//           break;\
-//         }\
-//         else {\
-//           CORRUPTION_ERROR_ACTION(M);\
-//           break;\
-//         }\
-//       }\
-//       else {\
-//         tchunkptr F = T->fd;\
-//         if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
-//           T->fd = F->bk = X;\
-//           X->fd = F;\
-//           X->bk = T;\
-//           X->parent = 0;\
-//           break;\
-//         }\
-//         else {\
-//           CORRUPTION_ERROR_ACTION(M);\
-//           break;\
-//         }\
-//       }\
-//     }\
-//   }\
-// }
-
-// /*
-//   Unlink steps:
-
-//   1. If x is a chained node, unlink it from its same-sized fd/bk links
-//      and choose its bk node as its replacement.
-//   2. If x was the last node of its size, but not a leaf node, it must
-//      be replaced with a leaf node (not merely one with an open left or
-//      right), to make sure that lefts and rights of descendents
-//      correspond properly to bit masks.  We use the rightmost descendent
-//      of x.  We could use any other leaf, but this is easy to locate and
-//      tends to counteract removal of leftmosts elsewhere, and so keeps
-//      paths shorter than minimally guaranteed.  This doesn't loop much
-//      because on average a node in a tree is near the bottom.
-//   3. If x is the base of a chain (i.e., has parent links) relink
-//      x's parent and children to x's replacement (or null if none).
-// */
-
-// #define unlink_large_chunk(M, X) {\
-//   tchunkptr XP = X->parent;\
-//   tchunkptr R;\
-//   if (X->bk != X) {\
-//     tchunkptr F = X->fd;\
-//     R = X->bk;\
-//     if (RTCHECK(ok_address(M, F) && F->bk == X && R->fd == X)) {\
-//       F->bk = R;\
-//       R->fd = F;\
-//     }\
-//     else {\
-//       CORRUPTION_ERROR_ACTION(M);\
-//     }\
-//   }\
-//   else {\
-//     tchunkptr* RP;\
-//     if (((R = *(RP = &(X->child[1]))) != 0) ||\
-//         ((R = *(RP = &(X->child[0]))) != 0)) {\
-//       tchunkptr* CP;\
-//       while ((*(CP = &(R->child[1])) != 0) ||\
-//              (*(CP = &(R->child[0])) != 0)) {\
-//         R = *(RP = CP);\
-//       }\
-//       if (RTCHECK(ok_address(M, RP)))\
-//         *RP = 0;\
-//       else {\
-//         CORRUPTION_ERROR_ACTION(M);\
-//       }\
-//     }\
-//   }\
-//   if (XP != 0) {\
-//     tbinptr* H = treebin_at(M, X->index);\
-//     if (X == *H) {\
-//       if ((*H = R) == 0) \
-//         clear_treemap(M, X->index);\
-//     }\
-//     else if (RTCHECK(ok_address(M, XP))) {\
-//       if (XP->child[0] == X) \
-//         XP->child[0] = R;\
-//       else \
-//         XP->child[1] = R;\
-//     }\
-//     else\
-//       CORRUPTION_ERROR_ACTION(M);\
-//     if (R != 0) {\
-//       if (RTCHECK(ok_address(M, R))) {\
-//         tchunkptr C0, C1;\
-//         R->parent = XP;\
-//         if ((C0 = X->child[0]) != 0) {\
-//           if (RTCHECK(ok_address(M, C0))) {\
-//             R->child[0] = C0;\
-//             C0->parent = R;\
-//           }\
-//           else\
-//             CORRUPTION_ERROR_ACTION(M);\
-//         }\
-//         if ((C1 = X->child[1]) != 0) {\
-//           if (RTCHECK(ok_address(M, C1))) {\
-//             R->child[1] = C1;\
-//             C1->parent = R;\
-//           }\
-//           else\
-//             CORRUPTION_ERROR_ACTION(M);\
-//         }\
-//       }\
-//       else\
-//         CORRUPTION_ERROR_ACTION(M);\
-//     }\
-//   }\
-// }
-
-// /* Relays to large vs small bin operations */
-
-// #define insert_chunk(M, P, S)\
-//   if (is_small(S)) insert_small_chunk(M, P, S)\
-//   else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }
-
-// #define unlink_chunk(M, P, S)\
-//   if (is_small(S)) unlink_small_chunk(M, P, S)\
-//   else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }
-
-
-// /* Relays to internal calls to malloc/free from realloc, memalign etc */
-
-// #if ONLY_MSPACES
-// #define internal_malloc(m, b) mspace_malloc(m, b)
-// #define internal_free(m, mem) mspace_free(m,mem);
-// #else /* ONLY_MSPACES */
-// #if MSPACES
-// #define internal_malloc(m, b)\
-//   ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
-// #define internal_free(m, mem)\
-//    if (m == gm) dlfree(mem); else mspace_free(m,mem);
-// #else /* MSPACES */
-// #define internal_malloc(m, b) dlmalloc(b)
-// #define internal_free(m, mem) dlfree(mem)
-// #endif /* MSPACES */
-// #endif /* ONLY_MSPACES */
-
-// /* -----------------------  Direct-mmapping chunks ----------------------- */
-
-// /*
-//   Directly mmapped chunks are set up with an offset to the start of
-//   the mmapped region stored in the prev_foot field of the chunk. This
-//   allows reconstruction of the required argument to MUNMAP when freed,
-//   and also allows adjustment of the returned chunk to meet alignment
-//   requirements (especially in memalign).
-// */
-
-// /* Malloc using mmap */
-// static void* mmap_alloc(mstate m, size_t nb) {
-//   size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
-//   if (m->footprint_limit != 0) {
-//     size_t fp = m->footprint + mmsize;
-//     if (fp <= m->footprint || fp > m->footprint_limit)
-//       return 0;
-//   }
-//   if (mmsize > nb) {     /* Check for wrap around 0 */
-//     char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
-//     if (mm != CMFAIL) {
-//       size_t offset = align_offset(chunk2mem(mm));
-//       size_t psize = mmsize - offset - MMAP_FOOT_PAD;
-//       mchunkptr p = (mchunkptr)(mm + offset);
-//       p->prev_foot = offset;
-//       p->head = psize;
-//       mark_inuse_foot(m, p, psize);
-//       chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
-//       chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;
-
-//       if (m->least_addr == 0 || mm < m->least_addr)
-//         m->least_addr = mm;
-//       if ((m->footprint += mmsize) > m->max_footprint)
-//         m->max_footprint = m->footprint;
-//       assert(is_aligned(chunk2mem(p)));
-//       check_mmapped_chunk(m, p);
-//       return chunk2mem(p);
-//     }
-//   }
-//   return 0;
-// }
-
-// /* Realloc using mmap */
-// static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {
-//   size_t oldsize = chunksize(oldp);
-//   (void)flags; /* placate people compiling -Wunused */
-//   if (is_small(nb)) /* Can't shrink mmap regions below small size */
-//     return 0;
-//   /* Keep old chunk if big enough but not too big */
-//   if (oldsize >= nb + SIZE_T_SIZE &&
-//       (oldsize - nb) <= (mparams.granularity << 1))
-//     return oldp;
-//   else {
-//     size_t offset = oldp->prev_foot;
-//     size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;
-//     size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
-//     char* cp = (char*)CALL_MREMAP((char*)oldp - offset,
-//                                   oldmmsize, newmmsize, flags);
-//     if (cp != CMFAIL) {
-//       mchunkptr newp = (mchunkptr)(cp + offset);
-//       size_t psize = newmmsize - offset - MMAP_FOOT_PAD;
-//       newp->head = psize;
-//       mark_inuse_foot(m, newp, psize);
-//       chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;
-//       chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;
-
-//       if (cp < m->least_addr)
-//         m->least_addr = cp;
-//       if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
-//         m->max_footprint = m->footprint;
-//       check_mmapped_chunk(m, newp);
-//       return newp;
-//     }
-//   }
-//   return 0;
-// }
-
-
-// /* -------------------------- mspace management -------------------------- */
-
-// /* Initialize top chunk and its size */
-// static void init_top(mstate m, mchunkptr p, size_t psize) {
-//   /* Ensure alignment */
-//   size_t offset = align_offset(chunk2mem(p));
-//   p = (mchunkptr)((char*)p + offset);
-//   psize -= offset;
-
-//   m->top = p;
-//   m->topsize = psize;
-//   p->head = psize | PINUSE_BIT;
-//   /* set size of fake trailing chunk holding overhead space only once */
-//   chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
-//   m->trim_check = mparams.trim_threshold; /* reset on each update */
-// }
-
-// /* Initialize bins for a new mstate that is otherwise zeroed out */
-// static void init_bins(mstate m) {
-//   /* Establish circular links for smallbins */
-//   bindex_t i;
-//   for (i = 0; i < NSMALLBINS; ++i) {
-//     sbinptr bin = smallbin_at(m,i);
-//     bin->fd = bin->bk = bin;
-//   }
-// }
-
-// #if PROCEED_ON_ERROR
-
-// /* default corruption action */
-// static void reset_on_error(mstate m) {
-//   int i;
-//   ++malloc_corruption_error_count;
-//   /* Reinitialize fields to forget about all memory */
-//   m->smallmap = m->treemap = 0;
-//   m->dvsize = m->topsize = 0;
-//   m->seg.base = 0;
-//   m->seg.size = 0;
-//   m->seg.next = 0;
-//   m->top = m->dv = 0;
-//   for (i = 0; i < NTREEBINS; ++i)
-//     *treebin_at(m, i) = 0;
-//   init_bins(m);
-// }
-// #endif /* PROCEED_ON_ERROR */
-
-// /* Allocate chunk and prepend remainder with chunk in successor base. */
-// static void* prepend_alloc(mstate m, char* newbase, char* oldbase,
-//                            size_t nb) {
-//   mchunkptr p = align_as_chunk(newbase);
-//   mchunkptr oldfirst = align_as_chunk(oldbase);
-//   size_t psize = (char*)oldfirst - (char*)p;
-//   mchunkptr q = chunk_plus_offset(p, nb);
-//   size_t qsize = psize - nb;
-//   set_size_and_pinuse_of_inuse_chunk(m, p, nb);
-
-//   assert((char*)oldfirst > (char*)q);
-//   assert(pinuse(oldfirst));
-//   assert(qsize >= MIN_CHUNK_SIZE);
-
-//   /* consolidate remainder with first chunk of old base */
-//   if (oldfirst == m->top) {
-//     size_t tsize = m->topsize += qsize;
-//     m->top = q;
-//     q->head = tsize | PINUSE_BIT;
-//     check_top_chunk(m, q);
-//   }
-//   else if (oldfirst == m->dv) {
-//     size_t dsize = m->dvsize += qsize;
-//     m->dv = q;
-//     set_size_and_pinuse_of_free_chunk(q, dsize);
-//   }
-//   else {
-//     if (!is_inuse(oldfirst)) {
-//       size_t nsize = chunksize(oldfirst);
-//       unlink_chunk(m, oldfirst, nsize);
-//       oldfirst = chunk_plus_offset(oldfirst, nsize);
-//       qsize += nsize;
-//     }
-//     set_free_with_pinuse(q, qsize, oldfirst);
-//     insert_chunk(m, q, qsize);
-//     check_free_chunk(m, q);
-//   }
-
-//   check_malloced_chunk(m, chunk2mem(p), nb);
-//   return chunk2mem(p);
-// }
-
-// /* Add a segment to hold a new noncontiguous region */
-// static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {
-//   /* Determine locations and sizes of segment, fenceposts, old top */
-//   char* old_top = (char*)m->top;
-//   msegmentptr oldsp = segment_holding(m, old_top);
-//   char* old_end = oldsp->base + oldsp->size;
-//   size_t ssize = pad_request(sizeof(struct malloc_segment));
-//   char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
-//   size_t offset = align_offset(chunk2mem(rawsp));
-//   char* asp = rawsp + offset;
-//   char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
-//   mchunkptr sp = (mchunkptr)csp;
-//   msegmentptr ss = (msegmentptr)(chunk2mem(sp));
-//   mchunkptr tnext = chunk_plus_offset(sp, ssize);
-//   mchunkptr p = tnext;
-//   int nfences = 0;
-
-//   /* reset top to new space */
-//   init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
-
-//   /* Set up segment record */
-//   assert(is_aligned(ss));
-//   set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
-//   *ss = m->seg; /* Push current record */
-//   m->seg.base = tbase;
-//   m->seg.size = tsize;
-//   m->seg.sflags = mmapped;
-//   m->seg.next = ss;
-
-//   /* Insert trailing fenceposts */
-//   for (;;) {
-//     mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);
-//     p->head = FENCEPOST_HEAD;
-//     ++nfences;
-//     if ((char*)(&(nextp->head)) < old_end)
-//       p = nextp;
-//     else
-//       break;
-//   }
-//   assert(nfences >= 2);
-
-//   /* Insert the rest of old top into a bin as an ordinary free chunk */
-//   if (csp != old_top) {
-//     mchunkptr q = (mchunkptr)old_top;
-//     size_t psize = csp - old_top;
-//     mchunkptr tn = chunk_plus_offset(q, psize);
-//     set_free_with_pinuse(q, psize, tn);
-//     insert_chunk(m, q, psize);
-//   }
-
-//   check_top_chunk(m, m->top);
-// }
-
-// /* -------------------------- System allocation -------------------------- */
-
-// /* Get memory from system using MORECORE or MMAP */
-// static void* sys_alloc(mstate m, size_t nb) {
-//   char* tbase = CMFAIL;
-//   size_t tsize = 0;
-//   flag_t mmap_flag = 0;
-//   size_t asize; /* allocation size */
-
-//   ensure_initialization();
-
-//   /* Directly map large chunks, but only if already initialized */
-//   if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
-//     void* mem = mmap_alloc(m, nb);
-//     if (mem != 0)
-//       return mem;
-//   }
-
-//   asize = granularity_align(nb + SYS_ALLOC_PADDING);
-//   if (asize <= nb)
-//     return 0; /* wraparound */
-//   if (m->footprint_limit != 0) {
-//     size_t fp = m->footprint + asize;
-//     if (fp <= m->footprint || fp > m->footprint_limit)
-//       return 0;
-//   }
-
-//   /*
-//     Try getting memory in any of three ways (in most-preferred to
-//     least-preferred order):
-//     1. A call to MORECORE that can normally contiguously extend memory.
-//        (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
-//        or main space is mmapped or a previous contiguous call failed)
-//     2. A call to MMAP new space (disabled if not HAVE_MMAP).
-//        Note that under the default settings, if MORECORE is unable to
-//        fulfill a request, and HAVE_MMAP is true, then mmap is
-//        used as a noncontiguous system allocator. This is a useful backup
-//        strategy for systems with holes in address spaces -- in this case
-//        sbrk cannot contiguously expand the heap, but mmap may be able to
-//        find space.
-//     3. A call to MORECORE that cannot usually contiguously extend memory.
-//        (disabled if not HAVE_MORECORE)
-
-//    In all cases, we need to request enough bytes from system to ensure
-//    we can malloc nb bytes upon success, so pad with enough space for
-//    top_foot, plus alignment-pad to make sure we don't lose bytes if
-//    not on boundary, and round this up to a granularity unit.
-//   */
-
-//   if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {
-//     char* br = CMFAIL;
-//     size_t ssize = asize; /* sbrk call size */
-//     msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);
-//     ACQUIRE_MALLOC_GLOBAL_LOCK();
-
-//     if (ss == 0) {  /* First time through or recovery */
-//       char* base = (char*)CALL_MORECORE(0);
-//       if (base != CMFAIL) {
-//         size_t fp;
-//         /* Adjust to end on a page boundary */
-//         if (!is_page_aligned(base))
-//           ssize += (page_align((size_t)base) - (size_t)base);
-//         fp = m->footprint + ssize; /* recheck limits */
-//         if (ssize > nb && ssize < HALF_MAX_SIZE_T &&
-//             (m->footprint_limit == 0 ||
-//              (fp > m->footprint && fp <= m->footprint_limit)) &&
-//             (br = (char*)(CALL_MORECORE(ssize))) == base) {
-//           tbase = base;
-//           tsize = ssize;
-//         }
-//       }
-//     }
-//     else {
-//       /* Subtract out existing available top space from MORECORE request. */
-//       ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);
-//       /* Use mem here only if it did continuously extend old space */
-//       if (ssize < HALF_MAX_SIZE_T &&
-//           (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {
-//         tbase = br;
-//         tsize = ssize;
-//       }
-//     }
-
-//     if (tbase == CMFAIL) {    /* Cope with partial failure */
-//       if (br != CMFAIL) {    /* Try to use/extend the space we did get */
-//         if (ssize < HALF_MAX_SIZE_T &&
-//             ssize < nb + SYS_ALLOC_PADDING) {
-//           size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);
-//           if (esize < HALF_MAX_SIZE_T) {
-//             char* end = (char*)CALL_MORECORE(esize);
-//             if (end != CMFAIL)
-//               ssize += esize;
-//             else {            /* Can't use; try to release */
-//               (void) CALL_MORECORE(-ssize);
-//               br = CMFAIL;
-//             }
-//           }
-//         }
-//       }
-//       if (br != CMFAIL) {    /* Use the space we did get */
-//         tbase = br;
-//         tsize = ssize;
-//       }
-//       else
-//         disable_contiguous(m); /* Don't try contiguous path in the future */
-//     }
-
-//     RELEASE_MALLOC_GLOBAL_LOCK();
-//   }
-
-//   if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */
-//     char* mp = (char*)(CALL_MMAP(asize));
-//     if (mp != CMFAIL) {
-//       tbase = mp;
-//       tsize = asize;
-//       mmap_flag = USE_MMAP_BIT;
-//     }
-//   }
-
-//   if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */
-//     if (asize < HALF_MAX_SIZE_T) {
-//       char* br = CMFAIL;
-//       char* end = CMFAIL;
-//       ACQUIRE_MALLOC_GLOBAL_LOCK();
-//       br = (char*)(CALL_MORECORE(asize));
-//       end = (char*)(CALL_MORECORE(0));
-//       RELEASE_MALLOC_GLOBAL_LOCK();
-//       if (br != CMFAIL && end != CMFAIL && br < end) {
-//         size_t ssize = end - br;
-//         if (ssize > nb + TOP_FOOT_SIZE) {
-//           tbase = br;
-//           tsize = ssize;
-//         }
-//       }
-//     }
-//   }
-
-//   if (tbase != CMFAIL) {
-
-//     if ((m->footprint += tsize) > m->max_footprint)
-//       m->max_footprint = m->footprint;
-
-//     if (!is_initialized(m)) { /* first-time initialization */
-//       if (m->least_addr == 0 || tbase < m->least_addr)
-//         m->least_addr = tbase;
-//       m->seg.base = tbase;
-//       m->seg.size = tsize;
-//       m->seg.sflags = mmap_flag;
-//       m->magic = mparams.magic;
-//       m->release_checks = MAX_RELEASE_CHECK_RATE;
-//       init_bins(m);
-// #if !ONLY_MSPACES
-//       if (is_global(m))
-//         init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
-//       else
-// #endif
-//       {
-//         /* Offset top by embedded malloc_state */
-//         mchunkptr mn = next_chunk(mem2chunk(m));
-//         init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
-//       }
-//     }
-
-//     else {
-//       /* Try to merge with an existing segment */
-//       msegmentptr sp = &m->seg;
-//       /* Only consider most recent segment if traversal suppressed */
-//       while (sp != 0 && tbase != sp->base + sp->size)
-//         sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
-//       if (sp != 0 &&
-//           !is_extern_segment(sp) &&
-//           (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
-//           segment_holds(sp, m->top)) { /* append */
-//         sp->size += tsize;
-//         init_top(m, m->top, m->topsize + tsize);
-//       }
-//       else {
-//         if (tbase < m->least_addr)
-//           m->least_addr = tbase;
-//         sp = &m->seg;
-//         while (sp != 0 && sp->base != tbase + tsize)
-//           sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
-//         if (sp != 0 &&
-//             !is_extern_segment(sp) &&
-//             (sp->sflags & USE_MMAP_BIT) == mmap_flag) {
-//           char* oldbase = sp->base;
-//           sp->base = tbase;
-//           sp->size += tsize;
-//           return prepend_alloc(m, tbase, oldbase, nb);
-//         }
-//         else
-//           add_segment(m, tbase, tsize, mmap_flag);
-//       }
-//     }
-
-//     if (nb < m->topsize) { /* Allocate from new or extended top space */
-//       size_t rsize = m->topsize -= nb;
-//       mchunkptr p = m->top;
-//       mchunkptr r = m->top = chunk_plus_offset(p, nb);
-//       r->head = rsize | PINUSE_BIT;
-//       set_size_and_pinuse_of_inuse_chunk(m, p, nb);
-//       check_top_chunk(m, m->top);
-//       check_malloced_chunk(m, chunk2mem(p), nb);
-//       return chunk2mem(p);
-//     }
-//   }
-
-//   MALLOC_FAILURE_ACTION;
-//   return 0;
-// }
-
-// /* -----------------------  system deallocation -------------------------- */
-
-// /* Unmap and unlink any mmapped segments that don't contain used chunks */
-// static size_t release_unused_segments(mstate m) {
-//   size_t released = 0;
-//   int nsegs = 0;
-//   msegmentptr pred = &m->seg;
-//   msegmentptr sp = pred->next;
-//   while (sp != 0) {
-//     char* base = sp->base;
-//     size_t size = sp->size;
-//     msegmentptr next = sp->next;
-//     ++nsegs;
-//     if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
-//       mchunkptr p = align_as_chunk(base);
-//       size_t psize = chunksize(p);
-//       /* Can unmap if first chunk holds entire segment and not pinned */
-//       if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
-//         tchunkptr tp = (tchunkptr)p;
-//         assert(segment_holds(sp, (char*)sp));
-//         if (p == m->dv) {
-//           m->dv = 0;
-//           m->dvsize = 0;
-//         }
-//         else {
-//           unlink_large_chunk(m, tp);
-//         }
-//         if (CALL_MUNMAP(base, size) == 0) {
-//           released += size;
-//           m->footprint -= size;
-//           /* unlink obsoleted record */
-//           sp = pred;
-//           sp->next = next;
-//         }
-//         else { /* back out if cannot unmap */
-//           insert_large_chunk(m, tp, psize);
-//         }
-//       }
-//     }
-//     if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
-//       break;
-//     pred = sp;
-//     sp = next;
-//   }
-//   /* Reset check counter */
-//   m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
-//                        (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);
-//   return released;
-// }
-
-// static int sys_trim(mstate m, size_t pad) {
-//   size_t released = 0;
-//   ensure_initialization();
-//   if (pad < MAX_REQUEST && is_initialized(m)) {
-//     pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */
-
-//     if (m->topsize > pad) {
-//       /* Shrink top space in granularity-size units, keeping at least one */
-//       size_t unit = mparams.granularity;
-//       size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
-//                       SIZE_T_ONE) * unit;
-//       msegmentptr sp = segment_holding(m, (char*)m->top);
-
-//       if (!is_extern_segment(sp)) {
-//         if (is_mmapped_segment(sp)) {
-//           if (HAVE_MMAP &&
-//               sp->size >= extra &&
-//               !has_segment_link(m, sp)) { /* can't shrink if pinned */
-//             size_t newsize = sp->size - extra;
-//             (void)newsize; /* placate people compiling -Wunused-variable */
-//             /* Prefer mremap, fall back to munmap */
-//             if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
-//                 (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
-//               released = extra;
-//             }
-//           }
-//         }
-//         else if (HAVE_MORECORE) {
-//           if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
-//             extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
-//           ACQUIRE_MALLOC_GLOBAL_LOCK();
-//           {
-//             /* Make sure end of memory is where we last set it. */
-//             char* old_br = (char*)(CALL_MORECORE(0));
-//             if (old_br == sp->base + sp->size) {
-//               char* rel_br = (char*)(CALL_MORECORE(-extra));
-//               char* new_br = (char*)(CALL_MORECORE(0));
-//               if (rel_br != CMFAIL && new_br < old_br)
-//                 released = old_br - new_br;
-//             }
-//           }
-//           RELEASE_MALLOC_GLOBAL_LOCK();
-//         }
-//       }
-
-//       if (released != 0) {
-//         sp->size -= released;
-//         m->footprint -= released;
-//         init_top(m, m->top, m->topsize - released);
-//         check_top_chunk(m, m->top);
-//       }
-//     }
-
-//     /* Unmap any unused mmapped segments */
-//     if (HAVE_MMAP)
-//       released += release_unused_segments(m);
-
-//     /* On failure, disable autotrim to avoid repeated failed future calls */
-//     if (released == 0 && m->topsize > m->trim_check)
-//       m->trim_check = MAX_SIZE_T;
-//   }
-
-//   return (released != 0)? 1 : 0;
-// }
-
-// /* Consolidate and bin a chunk. Differs from exported versions
-//    of free mainly in that the chunk need not be marked as inuse.
-// */
-// static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
-//   mchunkptr next = chunk_plus_offset(p, psize);
-//   if (!pinuse(p)) {
-//     mchunkptr prev;
-//     size_t prevsize = p->prev_foot;
-//     if (is_mmapped(p)) {
-//       psize += prevsize + MMAP_FOOT_PAD;
-//       if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
-//         m->footprint -= psize;
-//       return;
-//     }
-//     prev = chunk_minus_offset(p, prevsize);
-//     psize += prevsize;
-//     p = prev;
-//     if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
-//       if (p != m->dv) {
-//         unlink_chunk(m, p, prevsize);
-//       }
-//       else if ((next->head & INUSE_BITS) == INUSE_BITS) {
-//         m->dvsize = psize;
-//         set_free_with_pinuse(p, psize, next);
-//         return;
-//       }
-//     }
-//     else {
-//       CORRUPTION_ERROR_ACTION(m);
-//       return;
-//     }
-//   }
-//   if (RTCHECK(ok_address(m, next))) {
-//     if (!cinuse(next)) {  /* consolidate forward */
-//       if (next == m->top) {
-//         size_t tsize = m->topsize += psize;
-//         m->top = p;
-//         p->head = tsize | PINUSE_BIT;
-//         if (p == m->dv) {
-//           m->dv = 0;
-//           m->dvsize = 0;
-//         }
-//         return;
-//       }
-//       else if (next == m->dv) {
-//         size_t dsize = m->dvsize += psize;
-//         m->dv = p;
-//         set_size_and_pinuse_of_free_chunk(p, dsize);
-//         return;
-//       }
-//       else {
-//         size_t nsize = chunksize(next);
-//         psize += nsize;
-//         unlink_chunk(m, next, nsize);
-//         set_size_and_pinuse_of_free_chunk(p, psize);
-//         if (p == m->dv) {
-//           m->dvsize = psize;
-//           return;
-//         }
-//       }
-//     }
-//     else {
-//       set_free_with_pinuse(p, psize, next);
-//     }
-//     insert_chunk(m, p, psize);
-//   }
-//   else {
-//     CORRUPTION_ERROR_ACTION(m);
-//   }
-// }
-
-// /* ---------------------------- malloc --------------------------- */
-
-// /* allocate a large request from the best fitting chunk in a treebin */
-// static void* tmalloc_large(mstate m, size_t nb) {
-//   tchunkptr v = 0;
-//   size_t rsize = -nb; /* Unsigned negation */
-//   tchunkptr t;
-//   bindex_t idx;
-//   compute_tree_index(nb, idx);
-//   if ((t = *treebin_at(m, idx)) != 0) {
-//     /* Traverse tree for this bin looking for node with size == nb */
-//     size_t sizebits = nb << leftshift_for_tree_index(idx);
-//     tchunkptr rst = 0;  /* The deepest untaken right subtree */
-//     for (;;) {
-//       tchunkptr rt;
-//       size_t trem = chunksize(t) - nb;
-//       if (trem < rsize) {
-//         v = t;
-//         if ((rsize = trem) == 0)
-//           break;
-//       }
-//       rt = t->child[1];
-//       t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
-//       if (rt != 0 && rt != t)
-//         rst = rt;
-//       if (t == 0) {
-//         t = rst; /* set t to least subtree holding sizes > nb */
-//         break;
-//       }
-//       sizebits <<= 1;
-//     }
-//   }
-//   if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */
-//     binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
-//     if (leftbits != 0) {
-//       bindex_t i;
-//       binmap_t leastbit = least_bit(leftbits);
-//       compute_bit2idx(leastbit, i);
-//       t = *treebin_at(m, i);
-//     }
-//   }
-
-//   while (t != 0) { /* find smallest of tree or subtree */
-//     size_t trem = chunksize(t) - nb;
-//     if (trem < rsize) {
-//       rsize = trem;
-//       v = t;
-//     }
-//     t = leftmost_child(t);
-//   }
-
-//   /*  If dv is a better fit, return 0 so malloc will use it */
-//   if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
-//     if (RTCHECK(ok_address(m, v))) { /* split */
-//       mchunkptr r = chunk_plus_offset(v, nb);
-//       assert(chunksize(v) == rsize + nb);
-//       if (RTCHECK(ok_next(v, r))) {
-//         unlink_large_chunk(m, v);
-//         if (rsize < MIN_CHUNK_SIZE)
-//           set_inuse_and_pinuse(m, v, (rsize + nb));
-//         else {
-//           set_size_and_pinuse_of_inuse_chunk(m, v, nb);
-//           set_size_and_pinuse_of_free_chunk(r, rsize);
-//           insert_chunk(m, r, rsize);
-//         }
-//         return chunk2mem(v);
-//       }
-//     }
-//     CORRUPTION_ERROR_ACTION(m);
-//   }
-//   return 0;
-// }
-
-// /* allocate a small request from the best fitting chunk in a treebin */
-// static void* tmalloc_small(mstate m, size_t nb) {
-//   tchunkptr t, v;
-//   size_t rsize;
-//   bindex_t i;
-//   binmap_t leastbit = least_bit(m->treemap);
-//   compute_bit2idx(leastbit, i);
-//   v = t = *treebin_at(m, i);
-//   rsize = chunksize(t) - nb;
-
-//   while ((t = leftmost_child(t)) != 0) {
-//     size_t trem = chunksize(t) - nb;
-//     if (trem < rsize) {
-//       rsize = trem;
-//       v = t;
-//     }
-//   }
-
-//   if (RTCHECK(ok_address(m, v))) {
-//     mchunkptr r = chunk_plus_offset(v, nb);
-//     assert(chunksize(v) == rsize + nb);
-//     if (RTCHECK(ok_next(v, r))) {
-//       unlink_large_chunk(m, v);
-//       if (rsize < MIN_CHUNK_SIZE)
-//         set_inuse_and_pinuse(m, v, (rsize + nb));
-//       else {
-//         set_size_and_pinuse_of_inuse_chunk(m, v, nb);
-//         set_size_and_pinuse_of_free_chunk(r, rsize);
-//         replace_dv(m, r, rsize);
-//       }
-//       return chunk2mem(v);
-//     }
-//   }
-
-//   CORRUPTION_ERROR_ACTION(m);
-//   return 0;
-// }
-
-// #if !ONLY_MSPACES
-
-// void* dlmalloc(size_t bytes) {
-//   printf("Overiding regular malloc");
-//   /*
-//      Basic algorithm:
-//      If a small request (< 256 bytes minus per-chunk overhead):
-//        1. If one exists, use a remainderless chunk in associated smallbin.
-//           (Remainderless means that there are too few excess bytes to
-//           represent as a chunk.)
-//        2. If it is big enough, use the dv chunk, which is normally the
-//           chunk adjacent to the one used for the most recent small request.
-//        3. If one exists, split the smallest available chunk in a bin,
-//           saving remainder in dv.
-//        4. If it is big enough, use the top chunk.
-//        5. If available, get memory from system and use it
-//      Otherwise, for a large request:
-//        1. Find the smallest available binned chunk that fits, and use it
-//           if it is better fitting than dv chunk, splitting if necessary.
-//        2. If better fitting than any binned chunk, use the dv chunk.
-//        3. If it is big enough, use the top chunk.
-//        4. If request size >= mmap threshold, try to directly mmap this chunk.
-//        5. If available, get memory from system and use it
-
-//      The ugly goto's here ensure that postaction occurs along all paths.
-//   */
-
-// #if USE_LOCKS
-//   ensure_initialization(); /* initialize in sys_alloc if not using locks */
-// #endif
-
-//   if (!PREACTION(gm)) {
-//     void* mem;
-//     size_t nb;
-//     if (bytes <= MAX_SMALL_REQUEST) {
-//       bindex_t idx;
-//       binmap_t smallbits;
-//       nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
-//       idx = small_index(nb);
-//       smallbits = gm->smallmap >> idx;
-
-//       if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
-//         mchunkptr b, p;
-//         idx += ~smallbits & 1;       /* Uses next bin if idx empty */
-//         b = smallbin_at(gm, idx);
-//         p = b->fd;
-//         assert(chunksize(p) == small_index2size(idx));
-//         unlink_first_small_chunk(gm, b, p, idx);
-//         set_inuse_and_pinuse(gm, p, small_index2size(idx));
-//         mem = chunk2mem(p);
-//         check_malloced_chunk(gm, mem, nb);
-//         goto postaction;
-//       }
-
-//       else if (nb > gm->dvsize) {
-//         if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
-//           mchunkptr b, p, r;
-//           size_t rsize;
-//           bindex_t i;
-//           binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
-//           binmap_t leastbit = least_bit(leftbits);
-//           compute_bit2idx(leastbit, i);
-//           b = smallbin_at(gm, i);
-//           p = b->fd;
-//           assert(chunksize(p) == small_index2size(i));
-//           unlink_first_small_chunk(gm, b, p, i);
-//           rsize = small_index2size(i) - nb;
-//           /* Fit here cannot be remainderless if 4byte sizes */
-//           if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
-//             set_inuse_and_pinuse(gm, p, small_index2size(i));
-//           else {
-//             set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
-//             r = chunk_plus_offset(p, nb);
-//             set_size_and_pinuse_of_free_chunk(r, rsize);
-//             replace_dv(gm, r, rsize);
-//           }
-//           mem = chunk2mem(p);
-//           check_malloced_chunk(gm, mem, nb);
-//           goto postaction;
-//         }
-
-//         else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
-//           check_malloced_chunk(gm, mem, nb);
-//           goto postaction;
-//         }
-//       }
-//     }
-//     else if (bytes >= MAX_REQUEST)
-//       nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
-//     else {
-//       nb = pad_request(bytes);
-//       if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
-//         check_malloced_chunk(gm, mem, nb);
-//         goto postaction;
-//       }
-//     }
-
-//     if (nb <= gm->dvsize) {
-//       size_t rsize = gm->dvsize - nb;
-//       mchunkptr p = gm->dv;
-//       if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
-//         mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
-//         gm->dvsize = rsize;
-//         set_size_and_pinuse_of_free_chunk(r, rsize);
-//         set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
-//       }
-//       else { /* exhaust dv */
-//         size_t dvs = gm->dvsize;
-//         gm->dvsize = 0;
-//         gm->dv = 0;
-//         set_inuse_and_pinuse(gm, p, dvs);
-//       }
-//       mem = chunk2mem(p);
-//       check_malloced_chunk(gm, mem, nb);
-//       goto postaction;
-//     }
-
-//     else if (nb < gm->topsize) { /* Split top */
-//       size_t rsize = gm->topsize -= nb;
-//       mchunkptr p = gm->top;
-//       mchunkptr r = gm->top = chunk_plus_offset(p, nb);
-//       r->head = rsize | PINUSE_BIT;
-//       set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
-//       mem = chunk2mem(p);
-//       check_top_chunk(gm, gm->top);
-//       check_malloced_chunk(gm, mem, nb);
-//       goto postaction;
-//     }
-
-//     mem = sys_alloc(gm, nb);
-
-//   postaction:
-//     POSTACTION(gm);
-//     return mem;
-//   }
-
-//   return 0;
-// }
-
-// /* ---------------------------- free --------------------------- */
-
-// void dlfree(void* mem) {
-//   /*
-//      Consolidate freed chunks with preceeding or succeeding bordering
-//      free chunks, if they exist, and then place in a bin.  Intermixed
-//      with special cases for top, dv, mmapped chunks, and usage errors.
-//   */
-
-//  // Temporary no-op
-//  printf("No op here");
-
-// //   if (mem != 0) {
-// //     mchunkptr p  = mem2chunk(mem);
-// // #if FOOTERS
-// //     mstate fm = get_mstate_for(p);
-// //     if (!ok_magic(fm)) {
-// //       USAGE_ERROR_ACTION(fm, p);
-// //       return;
-// //     }
-// // #else /* FOOTERS */
-// // #define fm gm
-// // #endif /* FOOTERS */
-// //     if (!PREACTION(fm)) {
-// //       check_inuse_chunk(fm, p);
-// //       if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
-// //         size_t psize = chunksize(p);
-// //         mchunkptr next = chunk_plus_offset(p, psize);
-// //         if (!pinuse(p)) {
-// //           size_t prevsize = p->prev_foot;
-// //           if (is_mmapped(p)) {
-// //             psize += prevsize + MMAP_FOOT_PAD;
-// //             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
-// //               fm->footprint -= psize;
-// //             goto postaction;
-// //           }
-// //           else {
-// //             mchunkptr prev = chunk_minus_offset(p, prevsize);
-// //             psize += prevsize;
-// //             p = prev;
-// //             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
-// //               if (p != fm->dv) {
-// //                 unlink_chunk(fm, p, prevsize);
-// //               }
-// //               else if ((next->head & INUSE_BITS) == INUSE_BITS) {
-// //                 fm->dvsize = psize;
-// //                 set_free_with_pinuse(p, psize, next);
-// //                 goto postaction;
-// //               }
-// //             }
-// //             else
-// //               goto erroraction;
-// //           }
-// //         }
-
-// //         if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
-// //           if (!cinuse(next)) {  /* consolidate forward */
-// //             if (next == fm->top) {
-// //               size_t tsize = fm->topsize += psize;
-// //               fm->top = p;
-// //               p->head = tsize | PINUSE_BIT;
-// //               if (p == fm->dv) {
-// //                 fm->dv = 0;
-// //                 fm->dvsize = 0;
-// //               }
-// //               if (should_trim(fm, tsize))
-// //                 sys_trim(fm, 0);
-// //               goto postaction;
-// //             }
-// //             else if (next == fm->dv) {
-// //               size_t dsize = fm->dvsize += psize;
-// //               fm->dv = p;
-// //               set_size_and_pinuse_of_free_chunk(p, dsize);
-// //               goto postaction;
-// //             }
-// //             else {
-// //               size_t nsize = chunksize(next);
-// //               psize += nsize;
-// //               unlink_chunk(fm, next, nsize);
-// //               set_size_and_pinuse_of_free_chunk(p, psize);
-// //               if (p == fm->dv) {
-// //                 fm->dvsize = psize;
-// //                 goto postaction;
-// //               }
-// //             }
-// //           }
-// //           else
-// //             set_free_with_pinuse(p, psize, next);
-
-// //           if (is_small(psize)) {
-// //             insert_small_chunk(fm, p, psize);
-// //             check_free_chunk(fm, p);
-// //           }
-// //           else {
-// //             tchunkptr tp = (tchunkptr)p;
-// //             insert_large_chunk(fm, tp, psize);
-// //             check_free_chunk(fm, p);
-// //             if (--fm->release_checks == 0)
-// //               release_unused_segments(fm);
-// //           }
-// //           goto postaction;
-// //         }
-// //       }
-// //     erroraction:
-// //       USAGE_ERROR_ACTION(fm, p);
-// //     postaction:
-// //       POSTACTION(fm);
-// //     }
-// //   }
-// // #if !FOOTERS
-// // #undef fm
-// // #endif /* FOOTERS */
-// }
-
-// void* dlcalloc(size_t n_elements, size_t elem_size) {
-//   void* mem;
-//   size_t req = 0;
-//   if (n_elements != 0) {
-//     req = n_elements * elem_size;
-//     if (((n_elements | elem_size) & ~(size_t)0xffff) &&
-//         (req / n_elements != elem_size))
-//       req = MAX_SIZE_T; /* force downstream failure on overflow */
-//   }
-//   mem = dlmalloc(req);
-//   if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
-//     memset(mem, 0, req);
-//   return mem;
-// }
-
-// #endif /* !ONLY_MSPACES */
-
-// /* ------------ Internal support for realloc, memalign, etc -------------- */
-
-// /* Try to realloc; only in-place unless can_move true */
-// static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
-//                                    int can_move) {
-//   mchunkptr newp = 0;
-//   size_t oldsize = chunksize(p);
-//   mchunkptr next = chunk_plus_offset(p, oldsize);
-//   if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
-//               ok_next(p, next) && ok_pinuse(next))) {
-//     if (is_mmapped(p)) {
-//       newp = mmap_resize(m, p, nb, can_move);
-//     }
-//     else if (oldsize >= nb) {             /* already big enough */
-//       size_t rsize = oldsize - nb;
-//       if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */
-//         mchunkptr r = chunk_plus_offset(p, nb);
-//         set_inuse(m, p, nb);
-//         set_inuse(m, r, rsize);
-//         dispose_chunk(m, r, rsize);
-//       }
-//       newp = p;
-//     }
-//     else if (next == m->top) {  /* extend into top */
-//       if (oldsize + m->topsize > nb) {
-//         size_t newsize = oldsize + m->topsize;
-//         size_t newtopsize = newsize - nb;
-//         mchunkptr newtop = chunk_plus_offset(p, nb);
-//         set_inuse(m, p, nb);
-//         newtop->head = newtopsize |PINUSE_BIT;
-//         m->top = newtop;
-//         m->topsize = newtopsize;
-//         newp = p;
-//       }
-//     }
-//     else if (next == m->dv) { /* extend into dv */
-//       size_t dvs = m->dvsize;
-//       if (oldsize + dvs >= nb) {
-//         size_t dsize = oldsize + dvs - nb;
-//         if (dsize >= MIN_CHUNK_SIZE) {
-//           mchunkptr r = chunk_plus_offset(p, nb);
-//           mchunkptr n = chunk_plus_offset(r, dsize);
-//           set_inuse(m, p, nb);
-//           set_size_and_pinuse_of_free_chunk(r, dsize);
-//           clear_pinuse(n);
-//           m->dvsize = dsize;
-//           m->dv = r;
-//         }
-//         else { /* exhaust dv */
-//           size_t newsize = oldsize + dvs;
-//           set_inuse(m, p, newsize);
-//           m->dvsize = 0;
-//           m->dv = 0;
-//         }
-//         newp = p;
-//       }
-//     }
-//     else if (!cinuse(next)) { /* extend into next free chunk */
-//       size_t nextsize = chunksize(next);
-//       if (oldsize + nextsize >= nb) {
-//         size_t rsize = oldsize + nextsize - nb;
-//         unlink_chunk(m, next, nextsize);
-//         if (rsize < MIN_CHUNK_SIZE) {
-//           size_t newsize = oldsize + nextsize;
-//           set_inuse(m, p, newsize);
-//         }
-//         else {
-//           mchunkptr r = chunk_plus_offset(p, nb);
-//           set_inuse(m, p, nb);
-//           set_inuse(m, r, rsize);
-//           dispose_chunk(m, r, rsize);
-//         }
-//         newp = p;
-//       }
-//     }
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(m, chunk2mem(p));
-//   }
-//   return newp;
-// }
-
-// static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
-//   void* mem = 0;
-//   if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
-//     alignment = MIN_CHUNK_SIZE;
-//   if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
-//     size_t a = MALLOC_ALIGNMENT << 1;
-//     while (a < alignment) a <<= 1;
-//     alignment = a;
-//   }
-//   if (bytes >= MAX_REQUEST - alignment) {
-//     if (m != 0)  { /* Test isn't needed but avoids compiler warning */
-//       MALLOC_FAILURE_ACTION;
-//     }
-//   }
-//   else {
-//     size_t nb = request2size(bytes);
-//     size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
-//     mem = internal_malloc(m, req);
-//     if (mem != 0) {
-//       mchunkptr p = mem2chunk(mem);
-//       if (PREACTION(m))
-//         return 0;
-//       if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
-//         /*
-//           Find an aligned spot inside chunk.  Since we need to give
-//           back leading space in a chunk of at least MIN_CHUNK_SIZE, if
-//           the first calculation places us at a spot with less than
-//           MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
-//           We've allocated enough total room so that this is always
-//           possible.
-//         */
-//         char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
-//                                                        SIZE_T_ONE)) &
-//                                              -alignment));
-//         char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
-//           br : br+alignment;
-//         mchunkptr newp = (mchunkptr)pos;
-//         size_t leadsize = pos - (char*)(p);
-//         size_t newsize = chunksize(p) - leadsize;
-
-//         if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
-//           newp->prev_foot = p->prev_foot + leadsize;
-//           newp->head = newsize;
-//         }
-//         else { /* Otherwise, give back leader, use the rest */
-//           set_inuse(m, newp, newsize);
-//           set_inuse(m, p, leadsize);
-//           dispose_chunk(m, p, leadsize);
-//         }
-//         p = newp;
-//       }
-
-//       /* Give back spare room at the end */
-//       if (!is_mmapped(p)) {
-//         size_t size = chunksize(p);
-//         if (size > nb + MIN_CHUNK_SIZE) {
-//           size_t remainder_size = size - nb;
-//           mchunkptr remainder = chunk_plus_offset(p, nb);
-//           set_inuse(m, p, nb);
-//           set_inuse(m, remainder, remainder_size);
-//           dispose_chunk(m, remainder, remainder_size);
-//         }
-//       }
-
-//       mem = chunk2mem(p);
-//       assert (chunksize(p) >= nb);
-//       assert(((size_t)mem & (alignment - 1)) == 0);
-//       check_inuse_chunk(m, p);
-//       POSTACTION(m);
-//     }
-//   }
-//   return mem;
-// }
-
-// /*
-//   Common support for independent_X routines, handling
-//     all of the combinations that can result.
-//   The opts arg has:
-//     bit 0 set if all elements are same size (using sizes[0])
-//     bit 1 set if elements should be zeroed
-// */
-// static void** ialloc(mstate m,
-//                      size_t n_elements,
-//                      size_t* sizes,
-//                      int opts,
-//                      void* chunks[]) {
-
-//   size_t    element_size;   /* chunksize of each element, if all same */
-//   size_t    contents_size;  /* total size of elements */
-//   size_t    array_size;     /* request size of pointer array */
-//   void*     mem;            /* malloced aggregate space */
-//   mchunkptr p;              /* corresponding chunk */
-//   size_t    remainder_size; /* remaining bytes while splitting */
-//   void**    marray;         /* either "chunks" or malloced ptr array */
-//   mchunkptr array_chunk;    /* chunk for malloced ptr array */
-//   flag_t    was_enabled;    /* to disable mmap */
-//   size_t    size;
-//   size_t    i;
-
-//   ensure_initialization();
-//   /* compute array length, if needed */
-//   if (chunks != 0) {
-//     if (n_elements == 0)
-//       return chunks; /* nothing to do */
-//     marray = chunks;
-//     array_size = 0;
-//   }
-//   else {
-//     /* if empty req, must still return chunk representing empty array */
-//     if (n_elements == 0)
-//       return (void**)internal_malloc(m, 0);
-//     marray = 0;
-//     array_size = request2size(n_elements * (sizeof(void*)));
-//   }
-
-//   /* compute total element size */
-//   if (opts & 0x1) { /* all-same-size */
-//     element_size = request2size(*sizes);
-//     contents_size = n_elements * element_size;
-//   }
-//   else { /* add up all the sizes */
-//     element_size = 0;
-//     contents_size = 0;
-//     for (i = 0; i != n_elements; ++i)
-//       contents_size += request2size(sizes[i]);
-//   }
-
-//   size = contents_size + array_size;
-
-//   /*
-//      Allocate the aggregate chunk.  First disable direct-mmapping so
-//      malloc won't use it, since we would not be able to later
-//      free/realloc space internal to a segregated mmap region.
-//   */
-//   was_enabled = use_mmap(m);
-//   disable_mmap(m);
-//   mem = internal_malloc(m, size - CHUNK_OVERHEAD);
-//   if (was_enabled)
-//     enable_mmap(m);
-//   if (mem == 0)
-//     return 0;
-
-//   if (PREACTION(m)) return 0;
-//   p = mem2chunk(mem);
-//   remainder_size = chunksize(p);
-
-//   assert(!is_mmapped(p));
-
-//   if (opts & 0x2) {       /* optionally clear the elements */
-//     memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
-//   }
-
-//   /* If not provided, allocate the pointer array as final part of chunk */
-//   if (marray == 0) {
-//     size_t  array_chunk_size;
-//     array_chunk = chunk_plus_offset(p, contents_size);
-//     array_chunk_size = remainder_size - contents_size;
-//     marray = (void**) (chunk2mem(array_chunk));
-//     set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
-//     remainder_size = contents_size;
-//   }
-
-//   /* split out elements */
-//   for (i = 0; ; ++i) {
-//     marray[i] = chunk2mem(p);
-//     if (i != n_elements-1) {
-//       if (element_size != 0)
-//         size = element_size;
-//       else
-//         size = request2size(sizes[i]);
-//       remainder_size -= size;
-//       set_size_and_pinuse_of_inuse_chunk(m, p, size);
-//       p = chunk_plus_offset(p, size);
-//     }
-//     else { /* the final element absorbs any overallocation slop */
-//       set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);
-//       break;
-//     }
-//   }
-
-// #if DEBUG
-//   if (marray != chunks) {
-//     /* final element must have exactly exhausted chunk */
-//     if (element_size != 0) {
-//       assert(remainder_size == element_size);
-//     }
-//     else {
-//       assert(remainder_size == request2size(sizes[i]));
-//     }
-//     check_inuse_chunk(m, mem2chunk(marray));
-//   }
-//   for (i = 0; i != n_elements; ++i)
-//     check_inuse_chunk(m, mem2chunk(marray[i]));
-
-// #endif /* DEBUG */
-
-//   POSTACTION(m);
-//   return marray;
-// }
-
-// /* Try to free all pointers in the given array.
-//    Note: this could be made faster, by delaying consolidation,
-//    at the price of disabling some user integrity checks, We
-//    still optimize some consolidations by combining adjacent
-//    chunks before freeing, which will occur often if allocated
-//    with ialloc or the array is sorted.
-// */
-// static size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {
-//   size_t unfreed = 0;
-//   if (!PREACTION(m)) {
-//     void** a;
-//     void** fence = &(array[nelem]);
-//     for (a = array; a != fence; ++a) {
-//       void* mem = *a;
-//       if (mem != 0) {
-//         mchunkptr p = mem2chunk(mem);
-//         size_t psize = chunksize(p);
-// #if FOOTERS
-//         if (get_mstate_for(p) != m) {
-//           ++unfreed;
-//           continue;
-//         }
-// #endif
-//         check_inuse_chunk(m, p);
-//         *a = 0;
-//         if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
-//           void ** b = a + 1; /* try to merge with next chunk */
-//           mchunkptr next = next_chunk(p);
-//           if (b != fence && *b == chunk2mem(next)) {
-//             size_t newsize = chunksize(next) + psize;
-//             set_inuse(m, p, newsize);
-//             *b = chunk2mem(p);
-//           }
-//           else
-//             dispose_chunk(m, p, psize);
-//         }
-//         else {
-//           CORRUPTION_ERROR_ACTION(m);
-//           break;
-//         }
-//       }
-//     }
-//     if (should_trim(m, m->topsize))
-//       sys_trim(m, 0);
-//     POSTACTION(m);
-//   }
-//   return unfreed;
-// }
-
-// /* Traversal */
-// #if MALLOC_INSPECT_ALL
-// static void internal_inspect_all(mstate m,
-//                                  void(*handler)(void *start,
-//                                                 void *end,
-//                                                 size_t used_bytes,
-//                                                 void* callback_arg),
-//                                  void* arg) {
-//   if (is_initialized(m)) {
-//     mchunkptr top = m->top;
-//     msegmentptr s;
-//     for (s = &m->seg; s != 0; s = s->next) {
-//       mchunkptr q = align_as_chunk(s->base);
-//       while (segment_holds(s, q) && q->head != FENCEPOST_HEAD) {
-//         mchunkptr next = next_chunk(q);
-//         size_t sz = chunksize(q);
-//         size_t used;
-//         void* start;
-//         if (is_inuse(q)) {
-//           used = sz - CHUNK_OVERHEAD; /* must not be mmapped */
-//           start = chunk2mem(q);
-//         }
-//         else {
-//           used = 0;
-//           if (is_small(sz)) {     /* offset by possible bookkeeping */
-//             start = (void*)((char*)q + sizeof(struct malloc_chunk));
-//           }
-//           else {
-//             start = (void*)((char*)q + sizeof(struct malloc_tree_chunk));
-//           }
-//         }
-//         if (start < (void*)next)  /* skip if all space is bookkeeping */
-//           handler(start, next, used, arg);
-//         if (q == top)
-//           break;
-//         q = next;
-//       }
-//     }
-//   }
-// }
-// #endif /* MALLOC_INSPECT_ALL */
-
-// /* ------------------ Exported realloc, memalign, etc -------------------- */
-
-// #if !ONLY_MSPACES
-
-// void* dlrealloc(void* oldmem, size_t bytes) {
-//   void* mem = 0;
-//   if (oldmem == 0) {
-//     mem = dlmalloc(bytes);
-//   }
-//   else if (bytes >= MAX_REQUEST) {
-//     MALLOC_FAILURE_ACTION;
-//   }
-// #ifdef REALLOC_ZERO_BYTES_FREES
-//   else if (bytes == 0) {
-//     dlfree(oldmem);
-//   }
-// #endif /* REALLOC_ZERO_BYTES_FREES */
-//   else {
-//     size_t nb = request2size(bytes);
-//     mchunkptr oldp = mem2chunk(oldmem);
-// #if ! FOOTERS
-//     mstate m = gm;
-// #else /* FOOTERS */
-//     mstate m = get_mstate_for(oldp);
-//     if (!ok_magic(m)) {
-//       USAGE_ERROR_ACTION(m, oldmem);
-//       return 0;
-//     }
-// #endif /* FOOTERS */
-//     if (!PREACTION(m)) {
-//       mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
-//       POSTACTION(m);
-//       if (newp != 0) {
-//         check_inuse_chunk(m, newp);
-//         mem = chunk2mem(newp);
-//       }
-//       else {
-//         mem = internal_malloc(m, bytes);
-//         if (mem != 0) {
-//           size_t oc = chunksize(oldp) - overhead_for(oldp);
-//           memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
-//           internal_free(m, oldmem);
-//         }
-//       }
-//     }
-//   }
-//   return mem;
-// }
-
-// void* dlrealloc_in_place(void* oldmem, size_t bytes) {
-//   void* mem = 0;
-//   if (oldmem != 0) {
-//     if (bytes >= MAX_REQUEST) {
-//       MALLOC_FAILURE_ACTION;
-//     }
-//     else {
-//       size_t nb = request2size(bytes);
-//       mchunkptr oldp = mem2chunk(oldmem);
-// #if ! FOOTERS
-//       mstate m = gm;
-// #else /* FOOTERS */
-//       mstate m = get_mstate_for(oldp);
-//       if (!ok_magic(m)) {
-//         USAGE_ERROR_ACTION(m, oldmem);
-//         return 0;
-//       }
-// #endif /* FOOTERS */
-//       if (!PREACTION(m)) {
-//         mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
-//         POSTACTION(m);
-//         if (newp == oldp) {
-//           check_inuse_chunk(m, newp);
-//           mem = oldmem;
-//         }
-//       }
-//     }
-//   }
-//   return mem;
-// }
-
-// void* dlmemalign(size_t alignment, size_t bytes) {
-//   if (alignment <= MALLOC_ALIGNMENT) {
-//     return dlmalloc(bytes);
-//   }
-//   return internal_memalign(gm, alignment, bytes);
-// }
-
-// int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
-//   void* mem = 0;
-//   if (alignment == MALLOC_ALIGNMENT)
-//     mem = dlmalloc(bytes);
-//   else {
-//     size_t d = alignment / sizeof(void*);
-//     size_t r = alignment % sizeof(void*);
-//     if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
-//       return EINVAL;
-//     else if (bytes <= MAX_REQUEST - alignment) {
-//       if (alignment <  MIN_CHUNK_SIZE)
-//         alignment = MIN_CHUNK_SIZE;
-//       mem = internal_memalign(gm, alignment, bytes);
-//     }
-//   }
-//   if (mem == 0)
-//     return ENOMEM;
-//   else {
-//     *pp = mem;
-//     return 0;
-//   }
-// }
-
-// void* dlvalloc(size_t bytes) {
-//   size_t pagesz;
-//   ensure_initialization();
-//   pagesz = mparams.page_size;
-//   return dlmemalign(pagesz, bytes);
-// }
-
-// void* dlpvalloc(size_t bytes) {
-//   size_t pagesz;
-//   ensure_initialization();
-//   pagesz = mparams.page_size;
-//   return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
-// }
-
-// void** dlindependent_calloc(size_t n_elements, size_t elem_size,
-//                             void* chunks[]) {
-//   size_t sz = elem_size; /* serves as 1-element array */
-//   return ialloc(gm, n_elements, &sz, 3, chunks);
-// }
-
-// void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
-//                               void* chunks[]) {
-//   return ialloc(gm, n_elements, sizes, 0, chunks);
-// }
-
-// size_t dlbulk_free(void* array[], size_t nelem) {
-//   return internal_bulk_free(gm, array, nelem);
-// }
-
-// #if MALLOC_INSPECT_ALL
-// void dlmalloc_inspect_all(void(*handler)(void *start,
-//                                          void *end,
-//                                          size_t used_bytes,
-//                                          void* callback_arg),
-//                           void* arg) {
-//   ensure_initialization();
-//   if (!PREACTION(gm)) {
-//     internal_inspect_all(gm, handler, arg);
-//     POSTACTION(gm);
-//   }
-// }
-// #endif /* MALLOC_INSPECT_ALL */
-
-// int dlmalloc_trim(size_t pad) {
-//   int result = 0;
-//   ensure_initialization();
-//   if (!PREACTION(gm)) {
-//     result = sys_trim(gm, pad);
-//     POSTACTION(gm);
-//   }
-//   return result;
-// }
-
-// size_t dlmalloc_footprint(void) {
-//   return gm->footprint;
-// }
-
-// size_t dlmalloc_max_footprint(void) {
-//   return gm->max_footprint;
-// }
-
-// size_t dlmalloc_footprint_limit(void) {
-//   size_t maf = gm->footprint_limit;
-//   return maf == 0 ? MAX_SIZE_T : maf;
-// }
-
-// size_t dlmalloc_set_footprint_limit(size_t bytes) {
-//   size_t result;  /* invert sense of 0 */
-//   if (bytes == 0)
-//     result = granularity_align(1); /* Use minimal size */
-//   if (bytes == MAX_SIZE_T)
-//     result = 0;                    /* disable */
-//   else
-//     result = granularity_align(bytes);
-//   return gm->footprint_limit = result;
-// }
-
-// #if !NO_MALLINFO
-// struct mallinfo dlmallinfo(void) {
-//   return internal_mallinfo(gm);
-// }
-// #endif /* NO_MALLINFO */
-
-// #if !NO_MALLOC_STATS
-// void dlmalloc_stats() {
-//   internal_malloc_stats(gm);
-// }
-// #endif /* NO_MALLOC_STATS */
-
-// int dlmallopt(int param_number, int value) {
-//   return change_mparam(param_number, value);
-// }
-
-// size_t dlmalloc_usable_size(void* mem) {
-//   if (mem != 0) {
-//     mchunkptr p = mem2chunk(mem);
-//     if (is_inuse(p))
-//       return chunksize(p) - overhead_for(p);
-//   }
-//   return 0;
-// }
-
-// #endif /* !ONLY_MSPACES */
-
-// /* ----------------------------- user mspaces ---------------------------- */
-
-// #if MSPACES
-
-// static mstate init_user_mstate(char* tbase, size_t tsize) {
-//   size_t msize = pad_request(sizeof(struct malloc_state));
-//   mchunkptr mn;
-//   mchunkptr msp = align_as_chunk(tbase);
-//   mstate m = (mstate)(chunk2mem(msp));
-//   memset(m, 0, msize);
-//   (void)INITIAL_LOCK(&m->mutex);
-//   msp->head = (msize|INUSE_BITS);
-//   m->seg.base = m->least_addr = tbase;
-//   m->seg.size = m->footprint = m->max_footprint = tsize;
-//   m->magic = mparams.magic;
-//   m->release_checks = MAX_RELEASE_CHECK_RATE;
-//   m->mflags = mparams.default_mflags;
-//   m->extp = 0;
-//   m->exts = 0;
-//   disable_contiguous(m);
-//   init_bins(m);
-//   mn = next_chunk(mem2chunk(m));
-//   init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);
-//   check_top_chunk(m, m->top);
-//   return m;
-// }
-
-// mspace create_mspace(size_t capacity, int locked) {
-//   mstate m = 0;
-//   size_t msize;
-//   ensure_initialization();
-//   msize = pad_request(sizeof(struct malloc_state));
-//   if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
-//     size_t rs = ((capacity == 0)? mparams.granularity :
-//                  (capacity + TOP_FOOT_SIZE + msize));
-//     size_t tsize = granularity_align(rs);
-//     char* tbase = (char*)(CALL_MMAP(tsize));
-//     if (tbase != CMFAIL) {
-//       m = init_user_mstate(tbase, tsize);
-//       m->seg.sflags = USE_MMAP_BIT;
-//       set_lock(m, locked);
-//     }
-//   }
-//   return (mspace)m;
-// }
-
-// mspace create_mspace_with_base(void* base, size_t capacity, int locked) {
-//   mstate m = 0;
-//   size_t msize;
-//   ensure_initialization();
-//   msize = pad_request(sizeof(struct malloc_state));
-//   if (capacity > msize + TOP_FOOT_SIZE &&
-//       capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
-//     m = init_user_mstate((char*)base, capacity);
-//     m->seg.sflags = EXTERN_BIT;
-//     set_lock(m, locked);
-//   }
-//   return (mspace)m;
-// }
-
-// int mspace_track_large_chunks(mspace msp, int enable) {
-//   int ret = 0;
-//   mstate ms = (mstate)msp;
-//   if (!PREACTION(ms)) {
-//     if (!use_mmap(ms)) {
-//       ret = 1;
-//     }
-//     if (!enable) {
-//       enable_mmap(ms);
-//     } else {
-//       disable_mmap(ms);
-//     }
-//     POSTACTION(ms);
-//   }
-//   return ret;
-// }
-
-// size_t destroy_mspace(mspace msp) {
-//   size_t freed = 0;
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     msegmentptr sp = &ms->seg;
-//     (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */
-//     while (sp != 0) {
-//       char* base = sp->base;
-//       size_t size = sp->size;
-//       flag_t flag = sp->sflags;
-//       (void)base; /* placate people compiling -Wunused-variable */
-//       sp = sp->next;
-//       if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&
-//           CALL_MUNMAP(base, size) == 0)
-//         freed += size;
-//     }
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return freed;
-// }
-
-// /*
-//   mspace versions of routines are near-clones of the global
-//   versions. This is not so nice but better than the alternatives.
-// */
-
-// void* mspace_malloc(mspace msp, size_t bytes) {
-//   mstate ms = (mstate)msp;
-//   if (!ok_magic(ms)) {
-//     USAGE_ERROR_ACTION(ms,ms);
-//     return 0;
-//   }
-//   if (!PREACTION(ms)) {
-//     void* mem;
-//     size_t nb;
-//     if (bytes <= MAX_SMALL_REQUEST) {
-//       bindex_t idx;
-//       binmap_t smallbits;
-//       nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
-//       idx = small_index(nb);
-//       smallbits = ms->smallmap >> idx;
-
-//       if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
-//         mchunkptr b, p;
-//         idx += ~smallbits & 1;       /* Uses next bin if idx empty */
-//         b = smallbin_at(ms, idx);
-//         p = b->fd;
-//         assert(chunksize(p) == small_index2size(idx));
-//         unlink_first_small_chunk(ms, b, p, idx);
-//         set_inuse_and_pinuse(ms, p, small_index2size(idx));
-//         mem = chunk2mem(p);
-//         check_malloced_chunk(ms, mem, nb);
-//         goto postaction;
-//       }
-
-//       else if (nb > ms->dvsize) {
-//         if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
-//           mchunkptr b, p, r;
-//           size_t rsize;
-//           bindex_t i;
-//           binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
-//           binmap_t leastbit = least_bit(leftbits);
-//           compute_bit2idx(leastbit, i);
-//           b = smallbin_at(ms, i);
-//           p = b->fd;
-//           assert(chunksize(p) == small_index2size(i));
-//           unlink_first_small_chunk(ms, b, p, i);
-//           rsize = small_index2size(i) - nb;
-//           /* Fit here cannot be remainderless if 4byte sizes */
-//           if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
-//             set_inuse_and_pinuse(ms, p, small_index2size(i));
-//           else {
-//             set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
-//             r = chunk_plus_offset(p, nb);
-//             set_size_and_pinuse_of_free_chunk(r, rsize);
-//             replace_dv(ms, r, rsize);
-//           }
-//           mem = chunk2mem(p);
-//           check_malloced_chunk(ms, mem, nb);
-//           goto postaction;
-//         }
-
-//         else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
-//           check_malloced_chunk(ms, mem, nb);
-//           goto postaction;
-//         }
-//       }
-//     }
-//     else if (bytes >= MAX_REQUEST)
-//       nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
-//     else {
-//       nb = pad_request(bytes);
-//       if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {
-//         check_malloced_chunk(ms, mem, nb);
-//         goto postaction;
-//       }
-//     }
-
-//     if (nb <= ms->dvsize) {
-//       size_t rsize = ms->dvsize - nb;
-//       mchunkptr p = ms->dv;
-//       if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
-//         mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
-//         ms->dvsize = rsize;
-//         set_size_and_pinuse_of_free_chunk(r, rsize);
-//         set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
-//       }
-//       else { /* exhaust dv */
-//         size_t dvs = ms->dvsize;
-//         ms->dvsize = 0;
-//         ms->dv = 0;
-//         set_inuse_and_pinuse(ms, p, dvs);
-//       }
-//       mem = chunk2mem(p);
-//       check_malloced_chunk(ms, mem, nb);
-//       goto postaction;
-//     }
-
-//     else if (nb < ms->topsize) { /* Split top */
-//       size_t rsize = ms->topsize -= nb;
-//       mchunkptr p = ms->top;
-//       mchunkptr r = ms->top = chunk_plus_offset(p, nb);
-//       r->head = rsize | PINUSE_BIT;
-//       set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
-//       mem = chunk2mem(p);
-//       check_top_chunk(ms, ms->top);
-//       check_malloced_chunk(ms, mem, nb);
-//       goto postaction;
-//     }
-
-//     mem = sys_alloc(ms, nb);
-
-//   postaction:
-//     POSTACTION(ms);
-//     return mem;
-//   }
-
-//   return 0;
-// }
-
-// void mspace_free(mspace msp, void* mem) {
-//   if (mem != 0) {
-//     mchunkptr p  = mem2chunk(mem);
-// #if FOOTERS
-//     mstate fm = get_mstate_for(p);
-//     (void)msp; /* placate people compiling -Wunused */
-// #else /* FOOTERS */
-//     mstate fm = (mstate)msp;
-// #endif /* FOOTERS */
-//     if (!ok_magic(fm)) {
-//       USAGE_ERROR_ACTION(fm, p);
-//       return;
-//     }
-//     if (!PREACTION(fm)) {
-//       check_inuse_chunk(fm, p);
-//       if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
-//         size_t psize = chunksize(p);
-//         mchunkptr next = chunk_plus_offset(p, psize);
-//         if (!pinuse(p)) {
-//           size_t prevsize = p->prev_foot;
-//           if (is_mmapped(p)) {
-//             psize += prevsize + MMAP_FOOT_PAD;
-//             if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
-//               fm->footprint -= psize;
-//             goto postaction;
-//           }
-//           else {
-//             mchunkptr prev = chunk_minus_offset(p, prevsize);
-//             psize += prevsize;
-//             p = prev;
-//             if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
-//               if (p != fm->dv) {
-//                 unlink_chunk(fm, p, prevsize);
-//               }
-//               else if ((next->head & INUSE_BITS) == INUSE_BITS) {
-//                 fm->dvsize = psize;
-//                 set_free_with_pinuse(p, psize, next);
-//                 goto postaction;
-//               }
-//             }
-//             else
-//               goto erroraction;
-//           }
-//         }
-
-//         if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
-//           if (!cinuse(next)) {  /* consolidate forward */
-//             if (next == fm->top) {
-//               size_t tsize = fm->topsize += psize;
-//               fm->top = p;
-//               p->head = tsize | PINUSE_BIT;
-//               if (p == fm->dv) {
-//                 fm->dv = 0;
-//                 fm->dvsize = 0;
-//               }
-//               if (should_trim(fm, tsize))
-//                 sys_trim(fm, 0);
-//               goto postaction;
-//             }
-//             else if (next == fm->dv) {
-//               size_t dsize = fm->dvsize += psize;
-//               fm->dv = p;
-//               set_size_and_pinuse_of_free_chunk(p, dsize);
-//               goto postaction;
-//             }
-//             else {
-//               size_t nsize = chunksize(next);
-//               psize += nsize;
-//               unlink_chunk(fm, next, nsize);
-//               set_size_and_pinuse_of_free_chunk(p, psize);
-//               if (p == fm->dv) {
-//                 fm->dvsize = psize;
-//                 goto postaction;
-//               }
-//             }
-//           }
-//           else
-//             set_free_with_pinuse(p, psize, next);
-
-//           if (is_small(psize)) {
-//             insert_small_chunk(fm, p, psize);
-//             check_free_chunk(fm, p);
-//           }
-//           else {
-//             tchunkptr tp = (tchunkptr)p;
-//             insert_large_chunk(fm, tp, psize);
-//             check_free_chunk(fm, p);
-//             if (--fm->release_checks == 0)
-//               release_unused_segments(fm);
-//           }
-//           goto postaction;
-//         }
-//       }
-//     erroraction:
-//       USAGE_ERROR_ACTION(fm, p);
-//     postaction:
-//       POSTACTION(fm);
-//     }
-//   }
-// }
-
-// void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {
-//   void* mem;
-//   size_t req = 0;
-//   mstate ms = (mstate)msp;
-//   if (!ok_magic(ms)) {
-//     USAGE_ERROR_ACTION(ms,ms);
-//     return 0;
-//   }
-//   if (n_elements != 0) {
-//     req = n_elements * elem_size;
-//     if (((n_elements | elem_size) & ~(size_t)0xffff) &&
-//         (req / n_elements != elem_size))
-//       req = MAX_SIZE_T; /* force downstream failure on overflow */
-//   }
-//   mem = internal_malloc(ms, req);
-//   if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
-//     memset(mem, 0, req);
-//   return mem;
-// }
-
-// void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {
-//   void* mem = 0;
-//   if (oldmem == 0) {
-//     mem = mspace_malloc(msp, bytes);
-//   }
-//   else if (bytes >= MAX_REQUEST) {
-//     MALLOC_FAILURE_ACTION;
-//   }
-// #ifdef REALLOC_ZERO_BYTES_FREES
-//   else if (bytes == 0) {
-//     mspace_free(msp, oldmem);
-//   }
-// #endif /* REALLOC_ZERO_BYTES_FREES */
-//   else {
-//     size_t nb = request2size(bytes);
-//     mchunkptr oldp = mem2chunk(oldmem);
-// #if ! FOOTERS
-//     mstate m = (mstate)msp;
-// #else /* FOOTERS */
-//     mstate m = get_mstate_for(oldp);
-//     if (!ok_magic(m)) {
-//       USAGE_ERROR_ACTION(m, oldmem);
-//       return 0;
-//     }
-// #endif /* FOOTERS */
-//     if (!PREACTION(m)) {
-//       mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
-//       POSTACTION(m);
-//       if (newp != 0) {
-//         check_inuse_chunk(m, newp);
-//         mem = chunk2mem(newp);
-//       }
-//       else {
-//         mem = mspace_malloc(m, bytes);
-//         if (mem != 0) {
-//           size_t oc = chunksize(oldp) - overhead_for(oldp);
-//           memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
-//           mspace_free(m, oldmem);
-//         }
-//       }
-//     }
-//   }
-//   return mem;
-// }
-
-// void* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {
-//   void* mem = 0;
-//   if (oldmem != 0) {
-//     if (bytes >= MAX_REQUEST) {
-//       MALLOC_FAILURE_ACTION;
-//     }
-//     else {
-//       size_t nb = request2size(bytes);
-//       mchunkptr oldp = mem2chunk(oldmem);
-// #if ! FOOTERS
-//       mstate m = (mstate)msp;
-// #else /* FOOTERS */
-//       mstate m = get_mstate_for(oldp);
-//       (void)msp; /* placate people compiling -Wunused */
-//       if (!ok_magic(m)) {
-//         USAGE_ERROR_ACTION(m, oldmem);
-//         return 0;
-//       }
-// #endif /* FOOTERS */
-//       if (!PREACTION(m)) {
-//         mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
-//         POSTACTION(m);
-//         if (newp == oldp) {
-//           check_inuse_chunk(m, newp);
-//           mem = oldmem;
-//         }
-//       }
-//     }
-//   }
-//   return mem;
-// }
-
-// void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {
-//   mstate ms = (mstate)msp;
-//   if (!ok_magic(ms)) {
-//     USAGE_ERROR_ACTION(ms,ms);
-//     return 0;
-//   }
-//   if (alignment <= MALLOC_ALIGNMENT)
-//     return mspace_malloc(msp, bytes);
-//   return internal_memalign(ms, alignment, bytes);
-// }
-
-// void** mspace_independent_calloc(mspace msp, size_t n_elements,
-//                                  size_t elem_size, void* chunks[]) {
-//   size_t sz = elem_size; /* serves as 1-element array */
-//   mstate ms = (mstate)msp;
-//   if (!ok_magic(ms)) {
-//     USAGE_ERROR_ACTION(ms,ms);
-//     return 0;
-//   }
-//   return ialloc(ms, n_elements, &sz, 3, chunks);
-// }
-
-// void** mspace_independent_comalloc(mspace msp, size_t n_elements,
-//                                    size_t sizes[], void* chunks[]) {
-//   mstate ms = (mstate)msp;
-//   if (!ok_magic(ms)) {
-//     USAGE_ERROR_ACTION(ms,ms);
-//     return 0;
-//   }
-//   return ialloc(ms, n_elements, sizes, 0, chunks);
-// }
-
-// size_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {
-//   return internal_bulk_free((mstate)msp, array, nelem);
-// }
-
-// #if MALLOC_INSPECT_ALL
-// void mspace_inspect_all(mspace msp,
-//                         void(*handler)(void *start,
-//                                        void *end,
-//                                        size_t used_bytes,
-//                                        void* callback_arg),
-//                         void* arg) {
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     if (!PREACTION(ms)) {
-//       internal_inspect_all(ms, handler, arg);
-//       POSTACTION(ms);
-//     }
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-// }
-// #endif /* MALLOC_INSPECT_ALL */
-
-// int mspace_trim(mspace msp, size_t pad) {
-//   int result = 0;
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     if (!PREACTION(ms)) {
-//       result = sys_trim(ms, pad);
-//       POSTACTION(ms);
-//     }
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return result;
-// }
-
-// #if !NO_MALLOC_STATS
-// void mspace_malloc_stats(mspace msp) {
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     internal_malloc_stats(ms);
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-// }
-// #endif /* NO_MALLOC_STATS */
-
-// size_t mspace_footprint(mspace msp) {
-//   size_t result = 0;
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     result = ms->footprint;
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return result;
-// }
-
-// size_t mspace_max_footprint(mspace msp) {
-//   size_t result = 0;
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     result = ms->max_footprint;
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return result;
-// }
-
-// size_t mspace_footprint_limit(mspace msp) {
-//   size_t result = 0;
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     size_t maf = ms->footprint_limit;
-//     result = (maf == 0) ? MAX_SIZE_T : maf;
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return result;
-// }
-
-// size_t mspace_set_footprint_limit(mspace msp, size_t bytes) {
-//   size_t result = 0;
-//   mstate ms = (mstate)msp;
-//   if (ok_magic(ms)) {
-//     if (bytes == 0)
-//       result = granularity_align(1); /* Use minimal size */
-//     if (bytes == MAX_SIZE_T)
-//       result = 0;                    /* disable */
-//     else
-//       result = granularity_align(bytes);
-//     ms->footprint_limit = result;
-//   }
-//   else {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return result;
-// }
-
-// #if !NO_MALLINFO
-// struct mallinfo mspace_mallinfo(mspace msp) {
-//   mstate ms = (mstate)msp;
-//   if (!ok_magic(ms)) {
-//     USAGE_ERROR_ACTION(ms,ms);
-//   }
-//   return internal_mallinfo(ms);
-// }
-// #endif /* NO_MALLINFO */
-
-// size_t mspace_usable_size(const void* mem) {
-//   if (mem != 0) {
-//     mchunkptr p = mem2chunk(mem);
-//     if (is_inuse(p))
-//       return chunksize(p) - overhead_for(p);
-//   }
-//   return 0;
-// }
-
-// int mspace_mallopt(int param_number, int value) {
-//   return change_mparam(param_number, value);
-// }
-
-// #endif /* MSPACES */
-
-
-// /* -------------------- Alternative MORECORE functions ------------------- */
-
-// /*
-//   Guidelines for creating a custom version of MORECORE:
-
-//   * For best performance, MORECORE should allocate in multiples of pagesize.
-//   * MORECORE may allocate more memory than requested. (Or even less,
-//       but this will usually result in a malloc failure.)
-//   * MORECORE must not allocate memory when given argument zero, but
-//       instead return one past the end address of memory from previous
-//       nonzero call.
-//   * For best performance, consecutive calls to MORECORE with positive
-//       arguments should return increasing addresses, indicating that
-//       space has been contiguously extended.
-//   * Even though consecutive calls to MORECORE need not return contiguous
-//       addresses, it must be OK for malloc'ed chunks to span multiple
-//       regions in those cases where they do happen to be contiguous.
-//   * MORECORE need not handle negative arguments -- it may instead
-//       just return MFAIL when given negative arguments.
-//       Negative arguments are always multiples of pagesize. MORECORE
-//       must not misinterpret negative args as large positive unsigned
-//       args. You can suppress all such calls from even occurring by defining
-//       MORECORE_CANNOT_TRIM,
-
-//   As an example alternative MORECORE, here is a custom allocator
-//   kindly contributed for pre-OSX macOS.  It uses virtually but not
-//   necessarily physically contiguous non-paged memory (locked in,
-//   present and won't get swapped out).  You can use it by uncommenting
-//   this section, adding some #includes, and setting up the appropriate
-//   defines above:
-
-//       #define MORECORE osMoreCore
-
-//   There is also a shutdown routine that should somehow be called for
-//   cleanup upon program exit.
-
-//   #define MAX_POOL_ENTRIES 100
-//   #define MINIMUM_MORECORE_SIZE  (64 * 1024U)
-//   static int next_os_pool;
-//   void *our_os_pools[MAX_POOL_ENTRIES];
-
-//   void *osMoreCore(int size)
-//   {
-//     void *ptr = 0;
-//     static void *sbrk_top = 0;
-
-//     if (size > 0)
-//     {
-//       if (size < MINIMUM_MORECORE_SIZE)
-//          size = MINIMUM_MORECORE_SIZE;
-//       if (CurrentExecutionLevel() == kTaskLevel)
-//          ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
-//       if (ptr == 0)
-//       {
-//         return (void *) MFAIL;
-//       }
-//       // save ptrs so they can be freed during cleanup
-//       our_os_pools[next_os_pool] = ptr;
-//       next_os_pool++;
-//       ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);
-//       sbrk_top = (char *) ptr + size;
-//       return ptr;
-//     }
-//     else if (size < 0)
-//     {
-//       // we don't currently support shrink behavior
-//       return (void *) MFAIL;
-//     }
-//     else
-//     {
-//       return sbrk_top;
-//     }
-//   }
-
-//   // cleanup any allocated memory pools
-//   // called as last thing before shutting down driver
-
-//   void osCleanupMem(void)
-//   {
-//     void **ptr;
-
-//     for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)
-//       if (*ptr)
-//       {
-//          PoolDeallocate(*ptr);
-//          *ptr = 0;
-//       }
-//   }
-
-// */
-
-
-// /* -----------------------------------------------------------------------
-// History:
-//     v2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
-//       * fix bad comparison in dlposix_memalign
-//       * don't reuse adjusted asize in sys_alloc
-//       * add LOCK_AT_FORK -- thanks to Kirill Artamonov for the suggestion
-//       * reduce compiler warnings -- thanks to all who reported/suggested these
-
-//     v2.8.5 Sun May 22 10:26:02 2011  Doug Lea  (dl at gee)
-//       * Always perform unlink checks unless INSECURE
-//       * Add posix_memalign.
-//       * Improve realloc to expand in more cases; expose realloc_in_place.
-//         Thanks to Peter Buhr for the suggestion.
-//       * Add footprint_limit, inspect_all, bulk_free. Thanks
-//         to Barry Hayes and others for the suggestions.
-//       * Internal refactorings to avoid calls while holding locks
-//       * Use non-reentrant locks by default. Thanks to Roland McGrath
-//         for the suggestion.
-//       * Small fixes to mspace_destroy, reset_on_error.
-//       * Various configuration extensions/changes. Thanks
-//          to all who contributed these.
-
-//     V2.8.4a Thu Apr 28 14:39:43 2011 (dl at gee.cs.oswego.edu)
-//       * Update Creative Commons URL
-
-//     V2.8.4 Wed May 27 09:56:23 2009  Doug Lea  (dl at gee)
-//       * Use zeros instead of prev foot for is_mmapped
-//       * Add mspace_track_large_chunks; thanks to Jean Brouwers
-//       * Fix set_inuse in internal_realloc; thanks to Jean Brouwers
-//       * Fix insufficient sys_alloc padding when using 16byte alignment
-//       * Fix bad error check in mspace_footprint
-//       * Adaptations for ptmalloc; thanks to Wolfram Gloger.
-//       * Reentrant spin locks; thanks to Earl Chew and others
-//       * Win32 improvements; thanks to Niall Douglas and Earl Chew
-//       * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
-//       * Extension hook in malloc_state
-//       * Various small adjustments to reduce warnings on some compilers
-//       * Various configuration extensions/changes for more platforms. Thanks
-//          to all who contributed these.
-
-//     V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
-//       * Add max_footprint functions
-//       * Ensure all appropriate literals are size_t
-//       * Fix conditional compilation problem for some #define settings
-//       * Avoid concatenating segments with the one provided
-//         in create_mspace_with_base
-//       * Rename some variables to avoid compiler shadowing warnings
-//       * Use explicit lock initialization.
-//       * Better handling of sbrk interference.
-//       * Simplify and fix segment insertion, trimming and mspace_destroy
-//       * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
-//       * Thanks especially to Dennis Flanagan for help on these.
-
-//     V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
-//       * Fix memalign brace error.
-
-//     V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)
-//       * Fix improper #endif nesting in C++
-//       * Add explicit casts needed for C++
-
-//     V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)
-//       * Use trees for large bins
-//       * Support mspaces
-//       * Use segments to unify sbrk-based and mmap-based system allocation,
-//         removing need for emulation on most platforms without sbrk.
-//       * Default safety checks
-//       * Optional footer checks. Thanks to William Robertson for the idea.
-//       * Internal code refactoring
-//       * Incorporate suggestions and platform-specific changes.
-//         Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
-//         Aaron Bachmann,  Emery Berger, and others.
-//       * Speed up non-fastbin processing enough to remove fastbins.
-//       * Remove useless cfree() to avoid conflicts with other apps.
-//       * Remove internal memcpy, memset. Compilers handle builtins better.
-//       * Remove some options that no one ever used and rename others.
-
-//     V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
-//       * Fix malloc_state bitmap array misdeclaration
-
-//     V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
-//       * Allow tuning of FIRST_SORTED_BIN_SIZE
-//       * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.
-//       * Better detection and support for non-contiguousness of MORECORE.
-//         Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
-//       * Bypass most of malloc if no frees. Thanks To Emery Berger.
-//       * Fix freeing of old top non-contiguous chunk im sysmalloc.
-//       * Raised default trim and map thresholds to 256K.
-//       * Fix mmap-related #defines. Thanks to Lubos Lunak.
-//       * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.
-//       * Branch-free bin calculation
-//       * Default trim and mmap thresholds now 256K.
-
-//     V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)
-//       * Introduce independent_comalloc and independent_calloc.
-//         Thanks to Michael Pachos for motivation and help.
-//       * Make optional .h file available
-//       * Allow > 2GB requests on 32bit systems.
-//       * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.
-//         Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
-//         and Anonymous.
-//       * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for
-//         helping test this.)
-//       * memalign: check alignment arg
-//       * realloc: don't try to shift chunks backwards, since this
-//         leads to  more fragmentation in some programs and doesn't
-//         seem to help in any others.
-//       * Collect all cases in malloc requiring system memory into sysmalloc
-//       * Use mmap as backup to sbrk
-//       * Place all internal state in malloc_state
-//       * Introduce fastbins (although similar to 2.5.1)
-//       * Many minor tunings and cosmetic improvements
-//       * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK
-//       * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS
-//         Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.
-//       * Include errno.h to support default failure action.
-
-//     V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
-//       * return null for negative arguments
-//       * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>
-//          * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
-//           (e.g. WIN32 platforms)
-//          * Cleanup header file inclusion for WIN32 platforms
-//          * Cleanup code to avoid Microsoft Visual C++ compiler complaints
-//          * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
-//            memory allocation routines
-//          * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
-//          * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
-//            usage of 'assert' in non-WIN32 code
-//          * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
-//            avoid infinite loop
-//       * Always call 'fREe()' rather than 'free()'
-
-//     V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
-//       * Fixed ordering problem with boundary-stamping
-
-//     V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
-//       * Added pvalloc, as recommended by H.J. Liu
-//       * Added 64bit pointer support mainly from Wolfram Gloger
-//       * Added anonymously donated WIN32 sbrk emulation
-//       * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
-//       * malloc_extend_top: fix mask error that caused wastage after
-//         foreign sbrks
-//       * Add linux mremap support code from HJ Liu
-
-//     V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
-//       * Integrated most documentation with the code.
-//       * Add support for mmap, with help from
-//         Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
-//       * Use last_remainder in more cases.
-//       * Pack bins using idea from  colin@nyx10.cs.du.edu
-//       * Use ordered bins instead of best-fit threshhold
-//       * Eliminate block-local decls to simplify tracing and debugging.
-//       * Support another case of realloc via move into top
-//       * Fix error occuring when initial sbrk_base not word-aligned.
-//       * Rely on page size for units instead of SBRK_UNIT to
-//         avoid surprises about sbrk alignment conventions.
-//       * Add mallinfo, mallopt. Thanks to Raymond Nijssen
-//         (raymond@es.ele.tue.nl) for the suggestion.
-//       * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
-//       * More precautions for cases where other routines call sbrk,
-//         courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
-//       * Added macros etc., allowing use in linux libc from
-//         H.J. Lu (hjl@gnu.ai.mit.edu)
-//       * Inverted this history list
-
-//     V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
-//       * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
-//       * Removed all preallocation code since under current scheme
-//         the work required to undo bad preallocations exceeds
-//         the work saved in good cases for most test programs.
-//       * No longer use return list or unconsolidated bins since
-//         no scheme using them consistently outperforms those that don't
-//         given above changes.
-//       * Use best fit for very large chunks to prevent some worst-cases.
-//       * Added some support for debugging
-
-//     V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
-//       * Removed footers when chunks are in use. Thanks to
-//         Paul Wilson (wilson@cs.texas.edu) for the suggestion.
-
-//     V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
-//       * Added malloc_trim, with help from Wolfram Gloger
-//         (wmglo@Dent.MED.Uni-Muenchen.DE).
-
-//     V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)
-
-//     V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
-//       * realloc: try to expand in both directions
-//       * malloc: swap order of clean-bin strategy;
-//       * realloc: only conditionally expand backwards
-//       * Try not to scavenge used bins
-//       * Use bin counts as a guide to preallocation
-//       * Occasionally bin return list chunks in first scan
-//       * Add a few optimizations from colin@nyx10.cs.du.edu
-
-//     V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
-//       * faster bin computation & slightly different binning
-//       * merged all consolidations to one part of malloc proper
-//          (eliminating old malloc_find_space & malloc_clean_bin)
-//       * Scan 2 returns chunks (not just 1)
-//       * Propagate failure in realloc if malloc returns 0
-//       * Add stuff to allow compilation on non-ANSI compilers
-//           from kpv@research.att.com
-
-//     V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
-//       * removed potential for odd address access in prev_chunk
-//       * removed dependency on getpagesize.h
-//       * misc cosmetics and a bit more internal documentation
-//       * anticosmetics: mangled names in macros to evade debugger strangeness
-//       * tested on sparc, hp-700, dec-mips, rs6000
-//           with gcc & native cc (hp, dec only) allowing
-//           Detlefs & Zorn comparison study (in SIGPLAN Notices.)
-
-//     Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
-//       * Based loosely on libg++-1.2X malloc. (It retains some of the overall
-//          structure of old version,  but most details differ.)
-
-// */
diff --git a/src/allocators/stackframe.c b/src/allocators/stackframe.c
index d946c09..279d773 100644
--- a/src/allocators/stackframe.c
+++ b/src/allocators/stackframe.c
@@ -35,8 +35,8 @@ static void *main_bp; // beginning of main's stack frame
 
 struct suballocated_chunk_rec; // FIXME: remove once heap_index has been refactored
 
-// static struct frame_uniqtype_and_offset
-// pc_to_frame_uniqtype(const void *addr);
+static struct frame_uniqtype_and_offset
+pc_to_frame_uniqtype(const void *addr);
 
 void ( __attribute__((constructor(101))) __stackframe_allocator_init)(void)
 {
@@ -369,5 +369,34 @@ void init_frames_info(struct allocs_file_metadata *file)
 	}
 }
 
+static struct frame_uniqtype_and_offset
+pc_to_frame_uniqtype(const void *addr)
+{
+	/* First find the file. */
+	struct big_allocation *file_b = __lookup_bigalloc_from_root(addr,
+		&__static_file_allocator, NULL);
+	if (!file_b) goto fail;
+	/* Now get its frame info. */
+	struct allocs_file_metadata *afile
+	 = (struct allocs_file_metadata *) file_b->allocator_private;
+	assert(afile);
+	if (!afile->frames_info) goto fail;
+	uintptr_t target_vaddr = (uintptr_t) addr - afile->m.l->l_addr;
+#define proj(p) ((p)->entry.allocsite_vaddr)
+	struct frame_allocsite_entry *found = bsearch_leq_generic(
+		struct frame_allocsite_entry, target_vaddr,
+		/*  T*  */ afile->frames_info, /* unsigned */ afile->nframes,
+		proj);
+#undef proj
+	if (found)
+	{
+		return (struct frame_uniqtype_and_offset) {
+			found->entry.uniqtype,
+			found->offset_from_frame_base
+		};
+	}
+fail:
+	return (struct frame_uniqtype_and_offset) { NULL, 0 };
+}
 #undef maximum_vaddr_range_size
 #undef BEGINNING_OF_STACK
diff --git a/src/allocators/static-symbol.c b/src/allocators/static-symbol.c
index 32ca11c..1b28c84 100644
--- a/src/allocators/static-symbol.c
+++ b/src/allocators/static-symbol.c
@@ -289,11 +289,10 @@ static liballocs_err_t get_info(void *obj, struct big_allocation *maybe_bigalloc
 	struct big_allocation *segment_bigalloc
 	 = (b->allocated_by == &__static_section_allocator) ? b->parent
 			: b;
-
 	struct segment_metadata *segment = segment_bigalloc->allocator_private;
-	struct allocs_file_metadata *file = segment_bigalloc->parent->allocator_private;
-	if (!segment->metavector || !file->m.l) goto fail; // No link map or metavector then fail
+
 	uintptr_t obj_addr = (uintptr_t) obj;
+	struct allocs_file_metadata *file = segment_bigalloc->parent->allocator_private;
 	uintptr_t file_load_addr = file->m.l->l_addr;
 	/* Do a binary search in the metavector,
 	 * for the highest-placed symbol starting <=
diff --git a/src/dummyweaks.c b/src/dummyweaks.c
index 10dafa8..b1351ed 100644
--- a/src/dummyweaks.c
+++ b/src/dummyweaks.c
@@ -47,32 +47,7 @@ struct __liballocs_memrange_cache __liballocs_ool_cache; // all zeroes
 _Bool __liballocs_is_initialized;
 
 struct big_allocation;
-liballocs_err_t __generic_heap_get_info(void * obj, struct big_allocation *b, 
-	struct uniqtype **out_type, void **out_base, 
-	unsigned long *out_size, const void **out_site){
-		return NULL;
-}
-liballocs_err_t extract_and_output_alloc_site_and_type(
-    struct insert *p_ins,
-    struct uniqtype **out_type,
-    void **out_site
-){
-	return NULL;
-}
-struct frame_uniqtype_and_offset pc_to_frame_uniqtype(const void *addr)
-{
-	return;
-}
-int __liballocs_debug_level;
-void build_adjacency_list_recursive(
-	__uniqtype_node_rec **p_adj_u_head, __uniqtype_node_rec **p_adj_u_tail, 
-	void *obj_start, struct uniqtype *obj_t, 
-	unsigned long start_offset, struct uniqtype *t_at_offset, 
-	follow_ptr_fn *follow_ptr, void *fp_arg){
-		
-}
-__uniqtype_node_rec; 
-struct allocator __static_file_allocator;
+
 uint16_t *pageindex __attribute__((visibility("protected")));
 
 __thread void *__current_allocfn;
@@ -199,7 +174,6 @@ struct allocator __stack_allocator;
 struct allocator __stackframe_allocator;
 struct allocator __mmap_allocator; /* mmaps */
 struct allocator __sbrk_allocator; /* sbrk() */
-struct allocator __brk_allocator; /* sbrk() */
 struct allocator __static_allocator; /* ldso; nests under file? */
 struct allocator __auxv_allocator; /* nests under stack? */
 struct allocator __alloca_allocator; /* nests under stack? */
@@ -279,18 +253,6 @@ struct big_allocation *__lookup_bigalloc_from_root(const void *mem, struct alloc
 {
 	return NULL;
 }
-struct big_allocation *__lookup_bigalloc_under_pageindex(const void *mem, struct allocator *a, void **out_object_start){
-	return NULL;
-}
-struct big_allocation *__lookup_bigalloc_under(const void *mem, struct allocator *a, struct big_allocation *start, void **out_object_start) {
-	return NULL;
-}
-struct big_allocation *__lookup_bigalloc_top_level(const void *mem) {
-	return NULL;
-}
-struct big_allocation *__lookup_bigalloc_from_root_by_suballocator(const void *mem, struct allocator *sub_a, void **out_object_start) {
-	return NULL;
-}
 
 struct alloc_tree_pos;
 struct alloc_tree_link;
diff --git a/src/liballocs.c b/src/liballocs.c
index 17a49c3..681016e 100644
--- a/src/liballocs.c
+++ b/src/liballocs.c
@@ -1521,11 +1521,11 @@ alloc_get_site(void *obj) __attribute__((alias("__liballocs_get_alloc_site")));
 unsigned long
 __liballocs_get_alloc_size(void *obj)
 {
-	unsigned long alloc_size = 0;
+	unsigned long alloc_size;
 	struct liballocs_err *err = __liballocs_get_alloc_info(obj, NULL, NULL, 
 		&alloc_size, NULL, NULL);
 	
-	if (err && err != __liballocs_err_unrecognised_alloc_site) return 0;
+	if (err && err != &__liballocs_err_unrecognised_alloc_site) return 0;
 	return alloc_size;
 }
 unsigned long
diff --git a/src/liballocs_private.h b/src/liballocs_private.h
index ce39afe..53a49a0 100644
--- a/src/liballocs_private.h
+++ b/src/liballocs_private.h
@@ -138,6 +138,11 @@ struct addrlist
 	unsigned allocsz;
 	void **addrs;
 };
+struct frame_uniqtype_and_offset
+{
+	struct uniqtype *u;
+	unsigned o;
+};
 
 #define META_OBJ_SUFFIX "-meta.so"
 _Bool is_meta_object_for_lib(struct link_map *maybe_types, struct link_map *l);
diff --git a/src/pageindex.c b/src/pageindex.c
index 123d503..50b3fd6 100644
--- a/src/pageindex.c
+++ b/src/pageindex.c
@@ -926,8 +926,7 @@ _Bool __liballocs_delete_all_bigallocs_overlapping_range(const void *begin, cons
 	return 1;
 }
 
-// __attribute__((visibility("hidden")))
-// __attribute__((visibility("protected")))
+__attribute__((visibility("hidden")))
 struct big_allocation *__lookup_bigalloc_under_pageindex(const void *mem, struct allocator *a, void **out_object_start)
 {
 	if (!pageindex) __pageindex_init();
@@ -939,8 +938,7 @@ struct big_allocation *__lookup_bigalloc_under_pageindex(const void *mem, struct
 	return b;
 }
 
-// __attribute__((visibility("hidden")))
-// __attribute__((visibility("protected")))
+__attribute__((visibility("hidden")))
 struct big_allocation *__lookup_bigalloc_under(const void *mem, struct allocator *a, struct big_allocation *start, void **out_object_start)
 {
 	if (!pageindex) __pageindex_init();
@@ -963,7 +961,7 @@ struct big_allocation *__lookup_bigalloc_under_by_suballocator(const void *mem,
 	return b;
 }
 
-// __attribute__((visibility("protected")))
+__attribute__((visibility("protected")))
 struct big_allocation *__lookup_bigalloc_from_root(const void *mem, struct allocator *a, void **out_object_start)
 {
 	if (!pageindex) __pageindex_init();
@@ -975,7 +973,7 @@ struct big_allocation *__lookup_bigalloc_from_root(const void *mem, struct alloc
 	return b;
 }
 
-// __attribute__((visibility("protected")))
+__attribute__((visibility("protected")))
 struct big_allocation *__lookup_bigalloc_from_root_by_suballocator(const void *mem, struct allocator *sub_a, void **out_object_start)
 {
 	if (!pageindex) __pageindex_init();
@@ -986,7 +984,7 @@ struct big_allocation *__lookup_bigalloc_from_root_by_suballocator(const void *m
 	BIG_UNLOCK;
 	return b;
 }
-
+__attribute__((visibility("hidden")))
 struct big_allocation *__lookup_bigalloc_top_level(const void *mem)
 {
 	if (!pageindex) __pageindex_init();
@@ -1060,33 +1058,3 @@ _Bool __liballocs_notify_unindexed_address(const void *ptr)
 	// FIXME: loop through the others
 	return 0;
 }
-
-struct frame_uniqtype_and_offset
-pc_to_frame_uniqtype(const void *addr)
-{
-	/* First find the file. */
-	struct big_allocation *file_b = __lookup_bigalloc_from_root(addr,
-		&__static_file_allocator, NULL);
-	if (!file_b) goto fail;
-	/* Now get its frame info. */
-	struct allocs_file_metadata *afile
-	 = (struct allocs_file_metadata *) file_b->allocator_private;
-	assert(afile);
-	if (!afile->frames_info) goto fail;
-	uintptr_t target_vaddr = (uintptr_t) addr - afile->m.l->l_addr;
-#define proj(p) ((p)->entry.allocsite_vaddr)
-	struct frame_allocsite_entry *found = bsearch_leq_generic(
-		struct frame_allocsite_entry, target_vaddr,
-		/*  T*  */ afile->frames_info, /* unsigned */ afile->nframes,
-		proj);
-#undef proj
-	if (found)
-	{
-		return (struct frame_uniqtype_and_offset) {
-			found->entry.uniqtype,
-			found->offset_from_frame_base
-		};
-	}
-fail:
-	return (struct frame_uniqtype_and_offset) { NULL, 0 };
-}
\ No newline at end of file
diff --git a/src/uniqtype-bfs.c b/src/uniqtype-bfs.c
index a20e391..8c36441 100644
--- a/src/uniqtype-bfs.c
+++ b/src/uniqtype-bfs.c
@@ -23,11 +23,11 @@ const char *debugging_output_filename = DEBUGGING_OUTPUT_FILENAME;
 
 typedef __uniqtype_node_rec node_rec;
 
-// static void build_adjacency_list_recursive(
-// 	node_rec **p_adj_u_head, node_rec **p_adj_u_tail, 
-// 	void *obj_start, struct uniqtype *obj_t, 
-// 	unsigned long start_offset, struct uniqtype *t_at_offset, 
-// 	follow_ptr_fn *follow_ptr, void *fp_arg);
+static void build_adjacency_list_recursive(
+	node_rec **p_adj_u_head, node_rec **p_adj_u_tail, 
+	void *obj_start, struct uniqtype *obj_t, 
+	unsigned long start_offset, struct uniqtype *t_at_offset, 
+	follow_ptr_fn *follow_ptr, void *fp_arg);
 
 enum node_colour { WHITE, GREY, BLACK }; // WHITE == 0, so "absent" pair->v 0 means WHITE
 
@@ -138,9 +138,9 @@ static void visit_one_subobject(int i, struct uniqtype *element_type, long memb_
 				to_enqueue = make_node(ptr, t);
 				__uniqtype_node_queue_push_tail(p_adj_u_head, p_adj_u_tail, to_enqueue);
 
-				printf("\t%s_at_%p -> %s_at_%p;\n",
+				DEBUG_GUARD(fprintf(debug_out, "\t%s_at_%p -> %s_at_%p;\n",
 					NAME_FOR_UNIQTYPE(obj_t), obj_start,
-					NAME_FOR_UNIQTYPE(to_enqueue->t), to_enqueue->obj);
+					NAME_FOR_UNIQTYPE(to_enqueue->t), to_enqueue->obj));
 			}
 		}
 		else if (!pointed_to_object || pointed_to_object == (void*) -1)
@@ -149,14 +149,14 @@ static void visit_one_subobject(int i, struct uniqtype *element_type, long memb_
 		}
 		else
 		{
-			printf("Warning: insane pointer value %p found in field index %d in object %p, type %s\n",
+			fprintf(stderr, "Warning: insane pointer value %p found in field index %d in object %p, type %s\n",
 				pointed_to_object,
 				i,
 				(char*)((uintptr_t) obj_start + start_offset),
 				NAME_FOR_UNIQTYPE(t_at_offset)
 			);
 		}
-		if (to_enqueue && to_enqueue->obj) printf("Found a pointed-to object at %p, statically of type %s, "
+		if (to_enqueue && to_enqueue->obj) fprintf(stderr, "Found a pointed-to object at %p, statically of type %s, "
 			"added as %p of type %s\n",
 			pointed_to_object, NAME_FOR_UNIQTYPE(pointed_to_static_t),
 			to_enqueue->obj, NAME_FOR_UNIQTYPE(to_enqueue->t));
@@ -174,7 +174,7 @@ static void visit_one_subobject(int i, struct uniqtype *element_type, long memb_
 /* This function builds an adjacency list for the current node, by adding
  * *all* nodes, not just (despite the name) those pointed to by subobjects.
  * i.e. the top-level object is a zero-degree subobject. */
-void build_adjacency_list_recursive(
+static void build_adjacency_list_recursive(
 	node_rec **p_adj_u_head, node_rec **p_adj_u_tail, 
 	void *obj_start, struct uniqtype *obj_t, 
 	unsigned long start_offset, struct uniqtype *t_at_offset, 
@@ -184,7 +184,7 @@ void build_adjacency_list_recursive(
 
 	assert(!t_at_offset->make_precise);
 	
-	printf("Descending through subobjects of object at %p, "
+	fprintf(stderr, "Descending through subobjects of object at %p, "
 		"currently at subobject offset %ld of type %s\n",
 		obj_start, start_offset, NAME_FOR_UNIQTYPE(t_at_offset));
 	
